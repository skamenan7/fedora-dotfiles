{"type":"summary","summary":"Python Idioms: Advanced AI Programming Patterns","leafUuid":"3f684232-a111-422a-a3c6-57d2ab10620d"}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","type":"user","message":{"role":"user","content":"@03-python-idioms/examples/01_type_system_advanced.py can you create a juptyer notebook for me to learn form these examples. explain each cell what are the first priciples, python idioms also so i come out well rounded "},"uuid":"1f2aa446-cc66-4981-b58e-803c83605e1b","timestamp":"2025-08-01T17:52:07.465Z"}
{"parentUuid":"1f2aa446-cc66-4981-b58e-803c83605e1b","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_01LyYkVKpMWQmKVWW9LLvTr5","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"I'll create a comprehensive Jupyter notebook to help you learn Python's advanced type system from these examples. Let me break this down into digestible cells with clear explanations of first principles and Python idioms."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":30960,"cache_read_input_tokens":0,"output_tokens":3}},"requestId":"req_vrtx_011CRhR3xQo8muxNwPWVLsa2","type":"assistant","uuid":"ee2dc2c2-40f2-46ad-a323-94367c8506e7","timestamp":"2025-08-01T17:52:15.009Z"}
{"parentUuid":"ee2dc2c2-40f2-46ad-a323-94367c8506e7","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_01LyYkVKpMWQmKVWW9LLvTr5","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_vrtx_01SrddcxhPQRr3p8dn3a67XD","name":"Write","input":{"file_path":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/examples/01_type_system_advanced_learning.ipynb","content":"{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Advanced Python Type System for AI Development\\n\",\n    \"\\n\",\n    \"This notebook will teach you Python's advanced type system through practical AI examples. You'll learn:\\n\",\n    \"\\n\",\n    \"1. **Type Variables & Generics** - Building reusable, type-safe components\\n\",\n    \"2. **Protocols** - Defining interfaces without inheritance\\n\",\n    \"3. **TypedDict** - Structured configuration with type safety\\n\",\n    \"4. **Dataclasses** - Clean data structures with automatic methods\\n\",\n    \"5. **Function Overloading** - Multiple signatures for flexible APIs\\n\",\n    \"6. **Advanced Decorators** - Type-preserving function enhancement\\n\",\n    \"\\n\",\n    \"## Prerequisites\\n\",\n    \"```bash\\n\",\n    \"pip install rich\\n\",\n    \"```\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 1: Essential Imports and Setup\\n\",\n    \"\\n\",\n    \"**First Principle**: Python's typing module provides static type checking capabilities without runtime performance cost.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Import typing components explicitly for better readability and IDE support.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Essential imports for advanced typing\\n\",\n    \"from typing import (\\n\",\n    \"    TypeVar, Generic, Protocol, runtime_checkable, \\n\",\n    \"    Union, Optional, Literal, TypedDict, overload,\\n\",\n    \"    ParamSpec, Concatenate, Callable, Any, Dict, List\\n\",\n    \")\\n\",\n    \"from dataclasses import dataclass\\n\",\n    \"from abc import ABC, abstractmethod\\n\",\n    \"import asyncio\\n\",\n    \"import hashlib\\n\",\n    \"from rich.console import Console\\n\",\n    \"from rich.panel import Panel\\n\",\n    \"from rich.table import Table\\n\",\n    \"\\n\",\n    \"console = Console()\\n\",\n    \"print(\\\"✅ All imports successful!\\\")\\n\",\n    \"print(\\\"📚 Ready to explore advanced Python typing!\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 2: Understanding Type Variables\\n\",\n    \"\\n\",\n    \"**First Principle**: Type variables create generic, reusable code that maintains type safety across different data types.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use descriptive names for type variables (`T` for generic, `ModelInput`/`ModelOutput` for domain-specific).\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Type Variables - The foundation of generic programming\\n\",\n    \"T = TypeVar('T')  # Generic type variable\\n\",\n    \"ModelInput = TypeVar('ModelInput')  # Domain-specific type variable\\n\",\n    \"ModelOutput = TypeVar('ModelOutput')  # Domain-specific type variable\\n\",\n    \"P = ParamSpec('P')  # Parameter specification for functions\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"🔤 Type Variables Explained\\\", style=\\\"bold blue\\\"))\\n\",\n    \"console.print(\\\"\\\"\\\"\\n\",\n    \"Type Variables are placeholders that represent \\\"any type\\\" but maintain \\n\",\n    \"consistency within their scope.\\n\",\n    \"\\n\",\n    \"Key Benefits:\\n\",\n    \"• Type safety: Prevents mixing incompatible types\\n\",\n    \"• Reusability: Same code works with different types\\n\",\n    \"• IDE support: Better autocomplete and error detection\\n\",\n    \"• Documentation: Clear contracts about input/output relationships\\n\",\n    \"\\\"\\\"\\\")\\n\",\n    \"\\n\",\n    \"print(\\\"\\\\n📝 Type variables defined:\\\")\\n\",\n    \"print(f\\\"T: {T}\\\")\\n\",\n    \"print(f\\\"ModelInput: {ModelInput}\\\")\\n\",\n    \"print(f\\\"ModelOutput: {ModelOutput}\\\")\\n\",\n    \"print(f\\\"P: {P}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 3: Dataclasses - Clean Data Structures\\n\",\n    \"\\n\",\n    \"**First Principle**: Dataclasses automatically generate boilerplate methods (`__init__`, `__repr__`, `__eq__`) for data-focused classes.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `__post_init__` for validation and default value initialization that depends on other fields.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"@dataclass\\n\",\n    \"class TextInput:\\n\",\n    \"    \\\"\\\"\\\"Structured text input with automatic method generation.\\\"\\\"\\\"\\n\",\n    \"    text: str\\n\",\n    \"    context: Optional[str] = None\\n\",\n    \"    metadata: Dict[str, Any] = None\\n\",\n    \"    \\n\",\n    \"    def __post_init__(self):\\n\",\n    \"        \\\"\\\"\\\"Called after __init__ for custom initialization.\\\"\\\"\\\"\\n\",\n    \"        if self.metadata is None:\\n\",\n    \"            self.metadata = {}  # Avoid mutable default arguments\\n\",\n    \"\\n\",\n    \"@dataclass\\n\",\n    \"class ClassificationOutput:\\n\",\n    \"    \\\"\\\"\\\"Classification result with confidence scores.\\\"\\\"\\\"\\n\",\n    \"    label: str\\n\",\n    \"    confidence: float\\n\",\n    \"    alternatives: List[tuple[str, float]]\\n\",\n    \"    \\n\",\n    \"    def to_dict(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Convert to dictionary for serialization.\\\"\\\"\\\"\\n\",\n    \"        return {\\n\",\n    \"            \\\"label\\\": self.label,\\n\",\n    \"            \\\"confidence\\\": self.confidence,\\n\",\n    \"            \\\"alternatives\\\": self.alternatives\\n\",\n    \"        }\\n\",\n    \"    \\n\",\n    \"    @classmethod\\n\",\n    \"    def from_dict(cls, data: Dict[str, Any]) -> 'ClassificationOutput':\\n\",\n    \"        \\\"\\\"\\\"Create instance from dictionary.\\\"\\\"\\\"\\n\",\n    \"        return cls(\\n\",\n    \"            label=data[\\\"label\\\"],\\n\",\n    \"            confidence=data[\\\"confidence\\\"],\\n\",\n    \"            alternatives=data[\\\"alternatives\\\"]\\n\",\n    \"        )\\n\",\n    \"\\n\",\n    \"# Demonstrate dataclass usage\\n\",\n    \"console.print(Panel(\\\"📊 Dataclasses in Action\\\", style=\\\"bold green\\\"))\\n\",\n    \"\\n\",\n    \"# Create instances\\n\",\n    \"text_input = TextInput(\\n\",\n    \"    text=\\\"This is a positive example!\\\",\\n\",\n    \"    context=\\\"Sentiment analysis demo\\\"\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"classification = ClassificationOutput(\\n\",\n    \"    label=\\\"positive\\\",\\n\",\n    \"    confidence=0.92,\\n\",\n    \"    alternatives=[(\\\"neutral\\\", 0.06), (\\\"negative\\\", 0.02)]\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"print(f\\\"Text Input: {text_input}\\\")\\n\",\n    \"print(f\\\"Classification: {classification}\\\")\\n\",\n    \"print(f\\\"As dict: {classification.to_dict()}\\\")\\n\",\n    \"\\n\",\n    \"# Show automatic equality\\n\",\n    \"same_classification = ClassificationOutput(\\\"positive\\\", 0.92, [(\\\"neutral\\\", 0.06), (\\\"negative\\\", 0.02)])\\n\",\n    \"print(f\\\"\\\\n📋 Automatic equality: {classification == same_classification}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 4: Protocols - Interface Definition Without Inheritance\\n\",\n    \"\\n\",\n    \"**First Principle**: Protocols define \\\"what an object can do\\\" rather than \\\"what an object is\\\" (structural vs nominal typing).\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `@runtime_checkable` when you need `isinstance()` checks, use `Protocol[T]` for generic interfaces.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"@runtime_checkable\\n\",\n    \"class Serializable(Protocol):\\n\",\n    \"    \\\"\\\"\\\"Protocol for objects that can be serialized to/from dictionaries.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def to_dict(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Convert to dictionary.\\\"\\\"\\\"\\n\",\n    \"        ...\\n\",\n    \"    \\n\",\n    \"    @classmethod\\n\",\n    \"    def from_dict(cls, data: Dict[str, Any]) -> 'Serializable':\\n\",\n    \"        \\\"\\\"\\\"Create from dictionary.\\\"\\\"\\\"\\n\",\n    \"        ...\\n\",\n    \"\\n\",\n    \"@runtime_checkable\\n\",\n    \"class Cacheable(Protocol[T]):\\n\",\n    \"    \\\"\\\"\\\"Generic protocol for cacheable objects.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def cache_key(self) -> str:\\n\",\n    \"        \\\"\\\"\\\"Get unique cache key.\\\"\\\"\\\"\\n\",\n    \"        ...\\n\",\n    \"    \\n\",\n    \"    def serialize(self) -> bytes:\\n\",\n    \"        \\\"\\\"\\\"Serialize for caching.\\\"\\\"\\\"\\n\",\n    \"        ...\\n\",\n    \"    \\n\",\n    \"    @classmethod\\n\",\n    \"    def deserialize(cls, data: bytes) -> T:\\n\",\n    \"        \\\"\\\"\\\"Deserialize from cache.\\\"\\\"\\\"\\n\",\n    \"        ...\\n\",\n    \"\\n\",\n    \"# Test protocol compliance\\n\",\n    \"console.print(Panel(\\\"📋 Protocol Checking\\\", style=\\\"bold yellow\\\"))\\n\",\n    \"\\n\",\n    \"# Our ClassificationOutput automatically satisfies Serializable!\\n\",\n    \"result = ClassificationOutput(\\\"positive\\\", 0.85, [(\\\"neutral\\\", 0.15)])\\n\",\n    \"\\n\",\n    \"print(f\\\"Does ClassificationOutput implement Serializable? {isinstance(result, Serializable)}\\\")\\n\",\n    \"\\n\",\n    \"if isinstance(result, Serializable):\\n\",\n    \"    serialized = result.to_dict()\\n\",\n    \"    restored = ClassificationOutput.from_dict(serialized)\\n\",\n    \"    print(f\\\"✅ Serialization works: {restored.label} ({restored.confidence})\\\")\\n\",\n    \"\\n\",\n    \"# Test with other objects\\n\",\n    \"test_objects = [\\n\",\n    \"    (\\\"ClassificationOutput\\\", result),\\n\",\n    \"    (\\\"String\\\", \\\"hello\\\"),\\n\",\n    \"    (\\\"Dictionary\\\", {\\\"key\\\": \\\"value\\\"}),\\n\",\n    \"    (\\\"TextInput\\\", text_input)\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"print(\\\"\\\\n🔍 Runtime Protocol Checks:\\\")\\n\",\n    \"for name, obj in test_objects:\\n\",\n    \"    is_serializable = isinstance(obj, Serializable)\\n\",\n    \"    print(f\\\"  {name}: Serializable = {is_serializable}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 5: TypedDict - Structured Configuration\\n\",\n    \"\\n\",\n    \"**First Principle**: TypedDict provides type safety for dictionaries while maintaining dict performance and JSON compatibility.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `Literal` types for constrained string values, `total=False` for optional fields in inherited TypedDicts.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Define typed dictionaries for configuration\\n\",\n    \"class ModelConfig(TypedDict):\\n\",\n    \"    \\\"\\\"\\\"Basic model configuration with required fields.\\\"\\\"\\\"\\n\",\n    \"    model_id: str\\n\",\n    \"    max_tokens: int\\n\",\n    \"    temperature: float\\n\",\n    \"    provider: Literal[\\\"openai\\\", \\\"anthropic\\\", \\\"local\\\"]  # Constrained values\\n\",\n    \"    timeout_seconds: Optional[float]\\n\",\n    \"\\n\",\n    \"class AdvancedModelConfig(ModelConfig, total=False):\\n\",\n    \"    \\\"\\\"\\\"Extended config with optional fields.\\\"\\\"\\\"\\n\",\n    \"    retry_attempts: int\\n\",\n    \"    fallback_model: str\\n\",\n    \"    cost_limit_usd: float\\n\",\n    \"    custom_headers: Dict[str, str]\\n\",\n    \"\\n\",\n    \"# Type aliases for clarity\\n\",\n    \"Provider = Literal[\\\"openai\\\", \\\"anthropic\\\", \\\"huggingface\\\", \\\"local\\\"]\\n\",\n    \"ModelSize = Literal[\\\"small\\\", \\\"medium\\\", \\\"large\\\", \\\"xl\\\"]\\n\",\n    \"\\n\",\n    \"def create_model_config(\\n\",\n    \"    provider: Provider,\\n\",\n    \"    model_size: ModelSize,\\n\",\n    \"    temperature: float = 0.7\\n\",\n    \") -> ModelConfig:\\n\",\n    \"    \\\"\\\"\\\"Factory function using literal types for validation.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    # Mapping tuples to model IDs\\n\",\n    \"    model_mapping = {\\n\",\n    \"        (\\\"openai\\\", \\\"small\\\"): \\\"gpt-3.5-turbo\\\",\\n\",\n    \"        (\\\"openai\\\", \\\"large\\\"): \\\"gpt-4\\\",\\n\",\n    \"        (\\\"anthropic\\\", \\\"small\\\"): \\\"claude-3-haiku\\\",\\n\",\n    \"        (\\\"anthropic\\\", \\\"large\\\"): \\\"claude-3-opus\\\",\\n\",\n    \"        (\\\"local\\\", \\\"small\\\"): \\\"local-small-model\\\"\\n\",\n    \"    }\\n\",\n    \"    \\n\",\n    \"    model_id = model_mapping.get((provider, model_size), \\\"default-model\\\")\\n\",\n    \"    \\n\",\n    \"    max_tokens_mapping = {\\n\",\n    \"        \\\"small\\\": 1000, \\\"medium\\\": 2000, \\\"large\\\": 4000, \\\"xl\\\": 8000\\n\",\n    \"    }\\n\",\n    \"    \\n\",\n    \"    return ModelConfig(\\n\",\n    \"        model_id=model_id,\\n\",\n    \"        max_tokens=max_tokens_mapping[model_size],\\n\",\n    \"        temperature=temperature,\\n\",\n    \"        provider=provider,\\n\",\n    \"        timeout_seconds=30.0\\n\",\n    \"    )\\n\",\n    \"\\n\",\n    \"# Demonstrate TypedDict usage\\n\",\n    \"console.print(Panel(\\\"📝 TypedDict Configuration\\\", style=\\\"bold magenta\\\"))\\n\",\n    \"\\n\",\n    \"# Create configurations\\n\",\n    \"basic_config: ModelConfig = {\\n\",\n    \"    \\\"model_id\\\": \\\"gpt-4\\\",\\n\",\n    \"    \\\"max_tokens\\\": 2000,\\n\",\n    \"    \\\"temperature\\\": 0.7,\\n\",\n    \"    \\\"provider\\\": \\\"openai\\\",\\n\",\n    \"    \\\"timeout_seconds\\\": 30.0\\n\",\n    \"}\\n\",\n    \"\\n\",\n    \"advanced_config: AdvancedModelConfig = {\\n\",\n    \"    \\\"model_id\\\": \\\"claude-3-opus\\\",\\n\",\n    \"    \\\"max_tokens\\\": 4000,\\n\",\n    \"    \\\"temperature\\\": 0.5,\\n\",\n    \"    \\\"provider\\\": \\\"anthropic\\\",\\n\",\n    \"    \\\"timeout_seconds\\\": 60.0,\\n\",\n    \"    \\\"retry_attempts\\\": 3,\\n\",\n    \"    \\\"fallback_model\\\": \\\"claude-3-haiku\\\",\\n\",\n    \"    \\\"cost_limit_usd\\\": 10.0\\n\",\n    \"}\\n\",\n    \"\\n\",\n    \"print(\\\"📋 Configuration Examples:\\\")\\n\",\n    \"print(f\\\"Basic: {basic_config['provider']} - {basic_config['model_id']}\\\")\\n\",\n    \"print(f\\\"Advanced: {advanced_config['provider']} - {advanced_config['model_id']}\\\")\\n\",\n    \"print(f\\\"Has retries: {advanced_config.get('retry_attempts', 'No')}\\\")\\n\",\n    \"\\n\",\n    \"# Test factory function\\n\",\n    \"print(\\\"\\\\n🏭 Factory Function Results:\\\")\\n\",\n    \"configs = [\\n\",\n    \"    create_model_config(\\\"openai\\\", \\\"large\\\", 0.8),\\n\",\n    \"    create_model_config(\\\"anthropic\\\", \\\"small\\\", 0.3),\\n\",\n    \"    create_model_config(\\\"local\\\", \\\"small\\\", 1.0)\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"for i, config in enumerate(configs, 1):\\n\",\n    \"    print(f\\\"  Config {i}: {config['provider']} - {config['model_id']}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 6: Generic Classes - Type-Safe Containers\\n\",\n    \"\\n\",\n    \"**First Principle**: Generic classes use type variables to create reusable containers that maintain type safety.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `Generic[T]` for classes that store or operate on arbitrary types, use descriptive variable names for domain-specific generics.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class TypedCache(Generic[T]):\\n\",\n    \"    \\\"\\\"\\\"Type-safe cache that remembers what type it stores.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self):\\n\",\n    \"        self._cache: Dict[str, T] = {}\\n\",\n    \"        self._access_count: Dict[str, int] = {}\\n\",\n    \"    \\n\",\n    \"    def get(self, key: str) -> Optional[T]:\\n\",\n    \"        \\\"\\\"\\\"Get item from cache with type safety.\\\"\\\"\\\"\\n\",\n    \"        if key in self._cache:\\n\",\n    \"            self._access_count[key] = self._access_count.get(key, 0) + 1\\n\",\n    \"            return self._cache[key]\\n\",\n    \"        return None\\n\",\n    \"    \\n\",\n    \"    def put(self, key: str, value: T) -> None:\\n\",\n    \"        \\\"\\\"\\\"Store item in cache.\\\"\\\"\\\"\\n\",\n    \"        self._cache[key] = value\\n\",\n    \"        self._access_count[key] = 0\\n\",\n    \"    \\n\",\n    \"    def get_stats(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get cache statistics.\\\"\\\"\\\"\\n\",\n    \"        return {\\n\",\n    \"            \\\"size\\\": len(self._cache),\\n\",\n    \"            \\\"total_access\\\": sum(self._access_count.values()),\\n\",\n    \"            \\\"keys\\\": list(self._cache.keys())\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"# Generic AI Model base class\\n\",\n    \"class AIModel(Generic[ModelInput, ModelOutput], ABC):\\n\",\n    \"    \\\"\\\"\\\"Generic AI model with typed input/output.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, config: ModelConfig):\\n\",\n    \"        self.config = config\\n\",\n    \"    \\n\",\n    \"    @abstractmethod\\n\",\n    \"    async def predict(self, input_data: ModelInput) -> ModelOutput:\\n\",\n    \"        \\\"\\\"\\\"Make prediction with type safety.\\\"\\\"\\\"\\n\",\n    \"        pass\\n\",\n    \"    \\n\",\n    \"    @abstractmethod\\n\",\n    \"    def validate_input(self, input_data: ModelInput) -> bool:\\n\",\n    \"        \\\"\\\"\\\"Validate input data.\\\"\\\"\\\"\\n\",\n    \"        pass\\n\",\n    \"\\n\",\n    \"# Concrete implementation\\n\",\n    \"class TextClassifier(AIModel[TextInput, ClassificationOutput]):\\n\",\n    \"    \\\"\\\"\\\"Text classifier with specific input/output types.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    async def predict(self, input_data: TextInput) -> ClassificationOutput:\\n\",\n    \"        \\\"\\\"\\\"Classify text with mock implementation.\\\"\\\"\\\"\\n\",\n    \"        # Simple sentiment analysis simulation\\n\",\n    \"        text_lower = input_data.text.lower()\\n\",\n    \"        \\n\",\n    \"        if \\\"positive\\\" in text_lower or \\\"good\\\" in text_lower or \\\"great\\\" in text_lower:\\n\",\n    \"            return ClassificationOutput(\\\"positive\\\", 0.92, [(\\\"neutral\\\", 0.06), (\\\"negative\\\", 0.02)])\\n\",\n    \"        elif \\\"negative\\\" in text_lower or \\\"bad\\\" in text_lower or \\\"terrible\\\" in text_lower:\\n\",\n    \"            return ClassificationOutput(\\\"negative\\\", 0.88, [(\\\"neutral\\\", 0.10), (\\\"positive\\\", 0.02)])\\n\",\n    \"        else:\\n\",\n    \"            return ClassificationOutput(\\\"neutral\\\", 0.75, [(\\\"positive\\\", 0.15), (\\\"negative\\\", 0.10)])\\n\",\n    \"    \\n\",\n    \"    def validate_input(self, input_data: TextInput) -> bool:\\n\",\n    \"        \\\"\\\"\\\"Validate text input.\\\"\\\"\\\"\\n\",\n    \"        return (\\n\",\n    \"            isinstance(input_data.text, str) and\\n\",\n    \"            len(input_data.text.strip()) > 0 and\\n\",\n    \"            len(input_data.text) <= 10000\\n\",\n    \"        )\\n\",\n    \"\\n\",\n    \"# Demonstrate generic usage\\n\",\n    \"console.print(Panel(\\\"🎯 Generic Types in Action\\\", style=\\\"bold blue\\\"))\\n\",\n    \"\\n\",\n    \"# Create typed caches\\n\",\n    \"text_cache = TypedCache[str]()\\n\",\n    \"result_cache = TypedCache[ClassificationOutput]()\\n\",\n    \"\\n\",\n    \"# Use text cache\\n\",\n    \"text_cache.put(\\\"greeting\\\", \\\"Hello, world!\\\")\\n\",\n    \"text_cache.put(\\\"farewell\\\", \\\"Goodbye!\\\")\\n\",\n    \"cached_text = text_cache.get(\\\"greeting\\\")\\n\",\n    \"print(f\\\"📝 Cached text: {cached_text}\\\")\\n\",\n    \"\\n\",\n    \"# Use result cache\\n\",\n    \"sample_result = ClassificationOutput(\\\"positive\\\", 0.95, [(\\\"negative\\\", 0.05)])\\n\",\n    \"result_cache.put(\\\"sample\\\", sample_result)\\n\",\n    \"cached_result = result_cache.get(\\\"sample\\\")\\n\",\n    \"print(f\\\"📊 Cached result: {cached_result.label} ({cached_result.confidence})\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n📈 Cache Stats:\\\")\\n\",\n    \"print(f\\\"  Text cache: {text_cache.get_stats()}\\\")\\n\",\n    \"print(f\\\"  Result cache: {result_cache.get_stats()}\\\")\\n\",\n    \"\\n\",\n    \"# Test the classifier\\n\",\n    \"print(f\\\"\\\\n🤖 Testing TextClassifier:\\\")\\n\",\n    \"config = create_model_config(\\\"openai\\\", \\\"large\\\")\\n\",\n    \"classifier = TextClassifier(config)\\n\",\n    \"\\n\",\n    \"test_inputs = [\\n\",\n    \"    TextInput(\\\"This is a great positive example!\\\"),\\n\",\n    \"    TextInput(\\\"This is a terrible negative example!\\\"),\\n\",\n    \"    TextInput(\\\"This is just a normal example.\\\")\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"for i, test_input in enumerate(test_inputs, 1):\\n\",\n    \"    if classifier.validate_input(test_input):\\n\",\n    \"        result = await classifier.predict(test_input)\\n\",\n    \"        print(f\\\"  {i}. '{test_input.text}' -> {result.label} ({result.confidence:.2f})\\\")\\n\",\n    \"    else:\\n\",\n    \"        print(f\\\"  {i}. Invalid input: {test_input.text}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 7: Function Overloading\\n\",\n    \"\\n\",\n    \"**First Principle**: Function overloading allows multiple type signatures for the same function, improving API flexibility while maintaining type safety.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `@overload` for type hints only, implement the actual logic in the non-decorated function below.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class ModelManager:\\n\",\n    \"    \\\"\\\"\\\"Manages multiple AI models with overloaded methods.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self):\\n\",\n    \"        self.models: Dict[str, AIModel] = {}\\n\",\n    \"        self.cache = TypedCache[Any]()\\n\",\n    \"    \\n\",\n    \"    # Overloaded get_model methods\\n\",\n    \"    @overload\\n\",\n    \"    def get_model(self, name: str) -> Optional[AIModel]:\\n\",\n    \"        \\\"\\\"\\\"Get model by name, return None if not found.\\\"\\\"\\\"\\n\",\n    \"        ...\\n\",\n    \"    \\n\",\n    \"    @overload\\n\",\n    \"    def get_model(self, name: str, default: T) -> Union[AIModel, T]:\\n\",\n    \"        \\\"\\\"\\\"Get model by name, return default if not found.\\\"\\\"\\\"\\n\",\n    \"        ...\\n\",\n    \"    \\n\",\n    \"    def get_model(self, name: str, default=None):\\n\",\n    \"        \\\"\\\"\\\"Implementation for both overloads.\\\"\\\"\\\"\\n\",\n    \"        return self.models.get(name, default)\\n\",\n    \"    \\n\",\n    \"    def register_model(self, name: str, model: AIModel) -> None:\\n\",\n    \"        \\\"\\\"\\\"Register a model with a name.\\\"\\\"\\\"\\n\",\n    \"        self.models[name] = model\\n\",\n    \"    \\n\",\n    \"    # Overloaded predict methods\\n\",\n    \"    @overload\\n\",\n    \"    async def predict(self, model_name: str, input_data: TextInput) -> ClassificationOutput:\\n\",\n    \"        \\\"\\\"\\\"Predict with text classifier.\\\"\\\"\\\"\\n\",\n    \"        ...\\n\",\n    \"    \\n\",\n    \"    @overload\\n\",\n    \"    async def predict(self, model_name: str, input_data: Any) -> Any:\\n\",\n    \"        \\\"\\\"\\\"Generic prediction method.\\\"\\\"\\\"\\n\",\n    \"        ...\\n\",\n    \"    \\n\",\n    \"    async def predict(self, model_name: str, input_data: Any) -> Any:\\n\",\n    \"        \\\"\\\"\\\"Make prediction with caching.\\\"\\\"\\\"\\n\",\n    \"        model = self.get_model(model_name)\\n\",\n    \"        if model is None:\\n\",\n    \"            raise ValueError(f\\\"Model '{model_name}' not found\\\")\\n\",\n    \"        \\n\",\n    \"        # Simple cache key generation\\n\",\n    \"        cache_key = f\\\"{model_name}:{hash(str(input_data.text if hasattr(input_data, 'text') else input_data))}\\\"\\n\",\n    \"        \\n\",\n    \"        # Check cache first\\n\",\n    \"        cached_result = self.cache.get(cache_key)\\n\",\n    \"        if cached_result is not None:\\n\",\n    \"            print(f\\\"🗄️  Cache hit for {model_name}\\\")\\n\",\n    \"            return cached_result\\n\",\n    \"        \\n\",\n    \"        # Make prediction\\n\",\n    \"        print(f\\\"🤖 Making prediction with {model_name}\\\")\\n\",\n    \"        result = await model.predict(input_data)\\n\",\n    \"        \\n\",\n    \"        # Cache the result\\n\",\n    \"        self.cache.put(cache_key, result)\\n\",\n    \"        \\n\",\n    \"        return result\\n\",\n    \"\\n\",\n    \"# Demonstrate function overloading\\n\",\n    \"console.print(Panel(\\\"⚡ Function Overloading\\\", style=\\\"bold cyan\\\"))\\n\",\n    \"\\n\",\n    \"# Setup\\n\",\n    \"manager = ModelManager()\\n\",\n    \"config = create_model_config(\\\"openai\\\", \\\"large\\\")\\n\",\n    \"classifier = TextClassifier(config)\\n\",\n    \"manager.register_model(\\\"sentiment_classifier\\\", classifier)\\n\",\n    \"\\n\",\n    \"print(\\\"🔧 Testing overloaded get_model:\\\")\\n\",\n    \"\\n\",\n    \"# Test get_model without default\\n\",\n    \"model1 = manager.get_model(\\\"sentiment_classifier\\\")\\n\",\n    \"print(f\\\"  Found model: {model1 is not None}\\\")\\n\",\n    \"\\n\",\n    \"# Test get_model with default\\n\",\n    \"model2 = manager.get_model(\\\"nonexistent\\\", \\\"default_value\\\")\\n\",\n    \"print(f\\\"  With default: {model2}\\\")\\n\",\n    \"\\n\",\n    \"print(\\\"\\\\n🎯 Testing overloaded predict:\\\")\\n\",\n    \"\\n\",\n    \"# Test prediction with caching\\n\",\n    \"test_input = TextInput(\\\"This is a fantastic positive example!\\\")\\n\",\n    \"\\n\",\n    \"# First call - should compute\\n\",\n    \"result1 = await manager.predict(\\\"sentiment_classifier\\\", test_input)\\n\",\n    \"print(f\\\"  First call: {result1.label} ({result1.confidence:.2f})\\\")\\n\",\n    \"\\n\",\n    \"# Second call - should use cache\\n\",\n    \"result2 = await manager.predict(\\\"sentiment_classifier\\\", test_input)\\n\",\n    \"print(f\\\"  Second call: {result2.label} ({result2.confidence:.2f})\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n📊 Cache statistics: {manager.cache.get_stats()}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 8: Advanced Decorators with Type Preservation\\n\",\n    \"\\n\",\n    \"**First Principle**: Decorators can preserve function signatures and types using `ParamSpec` and proper generic typing.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `ParamSpec` to maintain parameter types, use `Callable[P, T]` for functions that accept any parameters and return type T.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"def with_retries(max_retries: int = 3) -> Callable[[Callable[P, T]], Callable[P, T]]:\\n\",\n    \"    \\\"\\\"\\\"Decorator that adds retry logic with full type preservation.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def decorator(func: Callable[P, T]) -> Callable[P, T]:\\n\",\n    \"        async def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\\n\",\n    \"            last_exception = None\\n\",\n    \"            \\n\",\n    \"            for attempt in range(max_retries):\\n\",\n    \"                try:\\n\",\n    \"                    # Handle both sync and async functions\\n\",\n    \"                    if asyncio.iscoroutinefunction(func):\\n\",\n    \"                        return await func(*args, **kwargs)\\n\",\n    \"                    else:\\n\",\n    \"                        return func(*args, **kwargs)\\n\",\n    \"                except Exception as e:\\n\",\n    \"                    last_exception = e\\n\",\n    \"                    print(f\\\"❌ Attempt {attempt + 1} failed: {str(e)[:50]}...\\\")\\n\",\n    \"                    \\n\",\n    \"                    if attempt < max_retries - 1:\\n\",\n    \"                        wait_time = 2 ** attempt  # Exponential backoff\\n\",\n    \"                        print(f\\\"⏳ Waiting {wait_time}s before retry...\\\")\\n\",\n    \"                        await asyncio.sleep(wait_time)\\n\",\n    \"            \\n\",\n    \"            print(f\\\"💥 All {max_retries} attempts failed\\\")\\n\",\n    \"            raise last_exception\\n\",\n    \"        \\n\",\n    \"        return wrapper\\n\",\n    \"    return decorator\\n\",\n    \"\\n\",\n    \"def log_calls(func: Callable[P, T]) -> Callable[P, T]:\\n\",\n    \"    \\\"\\\"\\\"Decorator that logs function calls with type preservation.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    async def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\\n\",\n    \"        func_name = func.__name__\\n\",\n    \"        print(f\\\"🚀 Calling {func_name} with {len(args)} args, {len(kwargs)} kwargs\\\")\\n\",\n    \"        \\n\",\n    \"        try:\\n\",\n    \"            if asyncio.iscoroutinefunction(func):\\n\",\n    \"                result = await func(*args, **kwargs)\\n\",\n    \"            else:\\n\",\n    \"                result = func(*args, **kwargs)\\n\",\n    \"            \\n\",\n    \"            print(f\\\"✅ {func_name} completed successfully\\\")\\n\",\n    \"            return result\\n\",\n    \"        except Exception as e:\\n\",\n    \"            print(f\\\"💥 {func_name} failed: {e}\\\")\\n\",\n    \"            raise\\n\",\n    \"    \\n\",\n    \"    return wrapper\\n\",\n    \"\\n\",\n    \"# Example functions using the decorators\\n\",\n    \"@with_retries(max_retries=3)\\n\",\n    \"@log_calls\\n\",\n    \"async def flaky_api_call(text: str, fail_rate: float = 0.7) -> str:\\n\",\n    \"    \\\"\\\"\\\"Simulates an unreliable API call.\\\"\\\"\\\"\\n\",\n    \"    import random\\n\",\n    \"    \\n\",\n    \"    if random.random() < fail_rate:\\n\",\n    \"        raise ConnectionError(f\\\"Simulated network failure for '{text}'\\\")\\n\",\n    \"    \\n\",\n    \"    # Simulate processing time\\n\",\n    \"    await asyncio.sleep(0.1)\\n\",\n    \"    return f\\\"Processed: {text.upper()}\\\"\\n\",\n    \"\\n\",\n    \"@with_retries(max_retries=2)\\n\",\n    \"async def reliable_classification(input_data: TextInput) -> ClassificationOutput:\\n\",\n    \"    \\\"\\\"\\\"Reliable classification with retries.\\\"\\\"\\\"\\n\",\n    \"    # Simulate occasional failures\\n\",\n    \"    import random\\n\",\n    \"    if random.random() < 0.3:\\n\",\n    \"        raise ValueError(\\\"Temporary classification error\\\")\\n\",\n    \"    \\n\",\n    \"    # Simple classification\\n\",\n    \"    text_lower = input_data.text.lower()\\n\",\n    \"    if \\\"good\\\" in text_lower or \\\"great\\\" in text_lower:\\n\",\n    \"        return ClassificationOutput(\\\"positive\\\", 0.90, [(\\\"neutral\\\", 0.08), (\\\"negative\\\", 0.02)])\\n\",\n    \"    else:\\n\",\n    \"        return ClassificationOutput(\\\"neutral\\\", 0.70, [(\\\"positive\\\", 0.20), (\\\"negative\\\", 0.10)])\\n\",\n    \"\\n\",\n    \"# Demonstrate advanced decorators\\n\",\n    \"console.print(Panel(\\\"🎨 Advanced Decorators with Type Preservation\\\", style=\\\"bold red\\\"))\\n\",\n    \"\\n\",\n    \"print(\\\"🧪 Testing flaky API call:\\\")\\n\",\n    \"try:\\n\",\n    \"    result = await flaky_api_call(\\\"hello world\\\", fail_rate=0.8)\\n\",\n    \"    print(f\\\"🎉 Success: {result}\\\")\\n\",\n    \"except Exception as e:\\n\",\n    \"    print(f\\\"🚫 Final failure: {e}\\\")\\n\",\n    \"\\n\",\n    \"print(\\\"\\\\n🧪 Testing reliable classification:\\\")\\n\",\n    \"test_input = TextInput(\\\"This is a good example\\\")\\n\",\n    \"try:\\n\",\n    \"    classification = await reliable_classification(test_input)\\n\",\n    \"    print(f\\\"🎯 Classification: {classification.label} ({classification.confidence:.2f})\\\")\\n\",\n    \"except Exception as e:\\n\",\n    \"    print(f\\\"🚫 Classification failed: {e}\\\")\\n\",\n    \"\\n\",\n    \"# Show that type information is preserved\\n\",\n    \"print(\\\"\\\\n🔍 Type preservation check:\\\")\\n\",\n    \"print(f\\\"flaky_api_call annotations: {flaky_api_call.__annotations__}\\\")\\n\",\n    \"print(f\\\"reliable_classification return type preserved: {hasattr(reliable_classification, '__annotations__')}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 9: Real-World Integration Example\\n\",\n    \"\\n\",\n    \"**First Principle**: Combine all typing features to create a robust, type-safe AI system that's easy to extend and maintain.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use composition of typed components rather than complex inheritance hierarchies.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class AIServiceConfig(TypedDict):\\n\",\n    \"    \\\"\\\"\\\"Configuration for AI service.\\\"\\\"\\\"\\n\",\n    \"    default_provider: Provider\\n\",\n    \"    max_concurrent_requests: int\\n\",\n    \"    cache_ttl_seconds: int\\n\",\n    \"    retry_attempts: int\\n\",\n    \"\\n\",\n    \"class AIService:\\n\",\n    \"    \\\"\\\"\\\"Production-ready AI service using all typing features.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, config: AIServiceConfig):\\n\",\n    \"        self.config = config\\n\",\n    \"        self.manager = ModelManager()\\n\",\n    \"        self.request_cache = TypedCache[ClassificationOutput]()\\n\",\n    \"        self._setup_default_models()\\n\",\n    \"    \\n\",\n    \"    def _setup_default_models(self) -> None:\\n\",\n    \"        \\\"\\\"\\\"Initialize default models.\\\"\\\"\\\"\\n\",\n    \"        model_config = create_model_config(\\n\",\n    \"            self.config[\\\"default_provider\\\"], \\n\",\n    \"            \\\"large\\\", \\n\",\n    \"            temperature=0.5\\n\",\n    \"        )\\n\",\n    \"        \\n\",\n    \"        classifier = TextClassifier(model_config)\\n\",\n    \"        self.manager.register_model(\\\"default_classifier\\\", classifier)\\n\",\n    \"    \\n\",\n    \"    @with_retries(max_retries=3)\\n\",\n    \"    @log_calls\\n\",\n    \"    async def classify_text(\\n\",\n    \"        self, \\n\",\n    \"        text: str, \\n\",\n    \"        context: Optional[str] = None,\\n\",\n    \"        use_cache: bool = True\\n\",\n    \"    ) -> ClassificationOutput:\\n\",\n    \"        \\\"\\\"\\\"Classify text with full error handling and caching.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        # Create structured input\\n\",\n    \"        text_input = TextInput(text=text, context=context)\\n\",\n    \"        \\n\",\n    \"        # Check cache if enabled\\n\",\n    \"        if use_cache:\\n\",\n    \"            cache_key = f\\\"classify:{hash(text)}:{hash(context or '')}\\\"\\n\",\n    \"            cached_result = self.request_cache.get(cache_key)\\n\",\n    \"            if cached_result is not None:\\n\",\n    \"                print(f\\\"💾 Cache hit for text: '{text[:30]}...'\\\")\\n\",\n    \"                return cached_result\\n\",\n    \"        \\n\",\n    \"        # Make prediction\\n\",\n    \"        result = await self.manager.predict(\\\"default_classifier\\\", text_input)\\n\",\n    \"        \\n\",\n    \"        # Cache result\\n\",\n    \"        if use_cache and isinstance(result, ClassificationOutput):\\n\",\n    \"            self.request_cache.put(cache_key, result)\\n\",\n    \"        \\n\",\n    \"        return result\\n\",\n    \"    \\n\",\n    \"    async def batch_classify(\\n\",\n    \"        self, \\n\",\n    \"        texts: List[str], \\n\",\n    \"        context: Optional[str] = None\\n\",\n    \"    ) -> List[ClassificationOutput]:\\n\",\n    \"        \\\"\\\"\\\"Classify multiple texts concurrently.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        # Create tasks for concurrent processing\\n\",\n    \"        tasks = [\\n\",\n    \"            self.classify_text(text, context)\\n\",\n    \"            for text in texts\\n\",\n    \"        ]\\n\",\n    \"        \\n\",\n    \"        # Wait for all classifications\\n\",\n    \"        results = await asyncio.gather(*tasks, return_exceptions=True)\\n\",\n    \"        \\n\",\n    \"        # Handle any failures\\n\",\n    \"        valid_results = []\\n\",\n    \"        for i, result in enumerate(results):\\n\",\n    \"            if isinstance(result, Exception):\\n\",\n    \"                print(f\\\"❌ Failed to classify text {i}: {result}\\\")\\n\",\n    \"                # Return neutral as fallback\\n\",\n    \"                valid_results.append(\\n\",\n    \"                    ClassificationOutput(\\\"neutral\\\", 0.5, [(\\\"positive\\\", 0.25), (\\\"negative\\\", 0.25)])\\n\",\n    \"                )\\n\",\n    \"            else:\\n\",\n    \"                valid_results.append(result)\\n\",\n    \"        \\n\",\n    \"        return valid_results\\n\",\n    \"    \\n\",\n    \"    def get_stats(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get service statistics.\\\"\\\"\\\"\\n\",\n    \"        return {\\n\",\n    \"            \\\"config\\\": self.config,\\n\",\n    \"            \\\"models_registered\\\": len(self.manager.models),\\n\",\n    \"            \\\"cache_stats\\\": self.request_cache.get_stats(),\\n\",\n    \"            \\\"manager_cache_stats\\\": self.manager.cache.get_stats()\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"# Demonstrate the complete system\\n\",\n    \"console.print(Panel(\\\"🏗️ Complete AI Service Integration\\\", style=\\\"bold green\\\"))\\n\",\n    \"\\n\",\n    \"# Create service configuration\\n\",\n    \"service_config: AIServiceConfig = {\\n\",\n    \"    \\\"default_provider\\\": \\\"openai\\\",\\n\",\n    \"    \\\"max_concurrent_requests\\\": 10,\\n\",\n    \"    \\\"cache_ttl_seconds\\\": 3600,\\n\",\n    \"    \\\"retry_attempts\\\": 3\\n\",\n    \"}\\n\",\n    \"\\n\",\n    \"# Initialize service\\n\",\n    \"ai_service = AIService(service_config)\\n\",\n    \"\\n\",\n    \"print(\\\"🧪 Testing single classification:\\\")\\n\",\n    \"single_result = await ai_service.classify_text(\\n\",\n    \"    \\\"This is an amazing product with great features!\\\",\\n\",\n    \"    context=\\\"Product review\\\"\\n\",\n    \")\\n\",\n    \"print(f\\\"Result: {single_result.label} (confidence: {single_result.confidence:.2f})\\\")\\n\",\n    \"\\n\",\n    \"print(\\\"\\\\n🧪 Testing batch classification:\\\")\\n\",\n    \"test_texts = [\\n\",\n    \"    \\\"This product is fantastic!\\\",\\n\",\n    \"    \\\"Terrible customer service experience.\\\",\\n\",\n    \"    \\\"The product works as expected.\\\",\\n\",\n    \"    \\\"Outstanding quality and great value!\\\"\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"batch_results = await ai_service.batch_classify(test_texts, \\\"Product reviews\\\")\\n\",\n    \"\\n\",\n    \"for i, (text, result) in enumerate(zip(test_texts, batch_results), 1):\\n\",\n    \"    print(f\\\"  {i}. '{text}' -> {result.label} ({result.confidence:.2f})\\\")\\n\",\n    \"\\n\",\n    \"print(\\\"\\\\n📊 Service statistics:\\\")\\n\",\n    \"stats = ai_service.get_stats()\\n\",\n    \"print(f\\\"Models registered: {stats['models_registered']}\\\")\\n\",\n    \"print(f\\\"Cache entries: {stats['cache_stats']['size']}\\\")\\n\",\n    \"print(f\\\"Total cache accesses: {stats['cache_stats']['total_access']}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 10: Key Takeaways and Best Practices\\n\",\n    \"\\n\",\n    \"**Summary of Python Typing First Principles and Idioms**\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"console.print(Panel(\\\"🎓 Key Takeaways: Advanced Python Typing\\\", style=\\\"bold blue\\\"))\\n\",\n    \"\\n\",\n    \"takeaways = {\\n\",\n    \"    \\\"Type Variables (Generic[T])\\\": [\\n\",\n    \"        \\\"• Enable reusable, type-safe components\\\",\\n\",\n    \"        \\\"• Use descriptive names: ModelInput, ModelOutput\\\",\\n\",\n    \"        \\\"• Maintain type relationships across function calls\\\"\\n\",\n    \"    ],\\n\",\n    \"    \\\"Protocols\\\": [\\n\",\n    \"        \\\"• Define 'what objects can do' not 'what they are'\\\",\\n\",\n    \"        \\\"• Use @runtime_checkable for isinstance() support\\\",\\n\",\n    \"        \\\"• Protocol[T] enables generic interfaces\\\"\\n\",\n    \"    ],\\n\",\n    \"    \\\"TypedDict\\\": [\\n\",\n    \"        \\\"• Type-safe dictionaries for configuration\\\",\\n\",\n    \"        \\\"• Use Literal types for constrained values\\\",\\n\",\n    \"        \\\"• total=False for optional fields in inheritance\\\"\\n\",\n    \"    ],\\n\",\n    \"    \\\"Dataclasses\\\": [\\n\",\n    \"        \\\"• Automatic __init__, __repr__, __eq__ generation\\\",\\n\",\n    \"        \\\"• Use __post_init__ for validation/defaults\\\",\\n\",\n    \"        \\\"• Avoid mutable defaults (use None + __post_init__)\\\"\\n\",\n    \"    ],\\n\",\n    \"    \\\"Function Overloading\\\": [\\n\",\n    \"        \\\"• Multiple type signatures for flexible APIs\\\",\\n\",\n    \"        \\\"• @overload for type hints, implementation below\\\",\\n\",\n    \"        \\\"• Improves IDE support and type checking\\\"\\n\",\n    \"    ],\\n\",\n    \"    \\\"Advanced Decorators\\\": [\\n\",\n    \"        \\\"• Use ParamSpec (P) to preserve parameter types\\\",\\n\",\n    \"        \\\"• Callable[P, T] for type-preserving decorators\\\",\\n\",\n    \"        \\\"• Handle both sync and async functions\\\"\\n\",\n    \"    ]\\n\",\n    \"}\\n\",\n    \"\\n\",\n    \"for concept, points in takeaways.items():\\n\",\n    \"    console.print(f\\\"\\\\n[bold yellow]{concept}:[/bold yellow]\\\")\\n\",\n    \"    for point in points:\\n\",\n    \"        console.print(f\\\"  {point}\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold green]🚀 Production Tips:[/bold green]\\\")\\n\",\n    \"production_tips = [\\n\",\n    \"    \\\"Use mypy or pyright for static type checking\\\",\\n\",\n    \"    \\\"Start with basic types, add generics as needed\\\",\\n\",\n    \"    \\\"Prefer composition over complex inheritance\\\",\\n\",\n    \"    \\\"Use typing for public APIs, relax for internal code\\\",\\n\",\n    \"    \\\"Document complex generic types with examples\\\",\\n\",\n    \"    \\\"Test type annotations with actual usage patterns\\\"\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"for tip in production_tips:\\n\",\n    \"    console.print(f\\\"  💡 {tip}\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold magenta]🎯 Next Steps:[/bold magenta]\\\")\\n\",\n    \"next_steps = [\\n\",\n    \"    \\\"Practice with your own AI components\\\",\\n\",\n    \"    \\\"Explore async patterns in the next example\\\",\\n\",\n    \"    \\\"Set up mypy in your development workflow\\\",\\n\",\n    \"    \\\"Build a typed plugin system using Protocols\\\",\\n\",\n    \"    \\\"Create generic data processing pipelines\\\"\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"for step in next_steps:\\n\",\n    \"    console.print(f\\\"  📚 {step}\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold blue]🎉 Congratulations![/bold blue] You now understand Python's advanced type system!\\\")\\n\",\n    \"console.print(\\\"Use these patterns to build robust, maintainable AI systems. 🤖✨\\\")\"\n   ]\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"Python 3\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.11.0\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 4\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":30960,"cache_read_input_tokens":0,"output_tokens":3}},"requestId":"req_vrtx_011CRhR3xQo8muxNwPWVLsa2","type":"assistant","uuid":"7e9bdb2c-e451-4eee-896b-e5eb9cb0c374","timestamp":"2025-08-01T17:55:23.128Z"}
{"parentUuid":"7e9bdb2c-e451-4eee-896b-e5eb9cb0c374","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_vrtx_01SrddcxhPQRr3p8dn3a67XD","type":"tool_result","content":"File created successfully at: /home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/examples/01_type_system_advanced_learning.ipynb"}]},"uuid":"c0ffa078-39fd-4f89-95f2-74dbbf3718b3","timestamp":"2025-08-01T17:57:59.228Z","toolUseResult":{"type":"create","filePath":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/examples/01_type_system_advanced_learning.ipynb","content":"{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Advanced Python Type System for AI Development\\n\",\n    \"\\n\",\n    \"This notebook will teach you Python's advanced type system through practical AI examples. You'll learn:\\n\",\n    \"\\n\",\n    \"1. **Type Variables & Generics** - Building reusable, type-safe components\\n\",\n    \"2. **Protocols** - Defining interfaces without inheritance\\n\",\n    \"3. **TypedDict** - Structured configuration with type safety\\n\",\n    \"4. **Dataclasses** - Clean data structures with automatic methods\\n\",\n    \"5. **Function Overloading** - Multiple signatures for flexible APIs\\n\",\n    \"6. **Advanced Decorators** - Type-preserving function enhancement\\n\",\n    \"\\n\",\n    \"## Prerequisites\\n\",\n    \"```bash\\n\",\n    \"pip install rich\\n\",\n    \"```\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 1: Essential Imports and Setup\\n\",\n    \"\\n\",\n    \"**First Principle**: Python's typing module provides static type checking capabilities without runtime performance cost.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Import typing components explicitly for better readability and IDE support.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Essential imports for advanced typing\\n\",\n    \"from typing import (\\n\",\n    \"    TypeVar, Generic, Protocol, runtime_checkable, \\n\",\n    \"    Union, Optional, Literal, TypedDict, overload,\\n\",\n    \"    ParamSpec, Concatenate, Callable, Any, Dict, List\\n\",\n    \")\\n\",\n    \"from dataclasses import dataclass\\n\",\n    \"from abc import ABC, abstractmethod\\n\",\n    \"import asyncio\\n\",\n    \"import hashlib\\n\",\n    \"from rich.console import Console\\n\",\n    \"from rich.panel import Panel\\n\",\n    \"from rich.table import Table\\n\",\n    \"\\n\",\n    \"console = Console()\\n\",\n    \"print(\\\"✅ All imports successful!\\\")\\n\",\n    \"print(\\\"📚 Ready to explore advanced Python typing!\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 2: Understanding Type Variables\\n\",\n    \"\\n\",\n    \"**First Principle**: Type variables create generic, reusable code that maintains type safety across different data types.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use descriptive names for type variables (`T` for generic, `ModelInput`/`ModelOutput` for domain-specific).\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Type Variables - The foundation of generic programming\\n\",\n    \"T = TypeVar('T')  # Generic type variable\\n\",\n    \"ModelInput = TypeVar('ModelInput')  # Domain-specific type variable\\n\",\n    \"ModelOutput = TypeVar('ModelOutput')  # Domain-specific type variable\\n\",\n    \"P = ParamSpec('P')  # Parameter specification for functions\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"🔤 Type Variables Explained\\\", style=\\\"bold blue\\\"))\\n\",\n    \"console.print(\\\"\\\"\\\"\\n\",\n    \"Type Variables are placeholders that represent \\\"any type\\\" but maintain \\n\",\n    \"consistency within their scope.\\n\",\n    \"\\n\",\n    \"Key Benefits:\\n\",\n    \"• Type safety: Prevents mixing incompatible types\\n\",\n    \"• Reusability: Same code works with different types\\n\",\n    \"• IDE support: Better autocomplete and error detection\\n\",\n    \"• Documentation: Clear contracts about input/output relationships\\n\",\n    \"\\\"\\\"\\\")\\n\",\n    \"\\n\",\n    \"print(\\\"\\\\n📝 Type variables defined:\\\")\\n\",\n    \"print(f\\\"T: {T}\\\")\\n\",\n    \"print(f\\\"ModelInput: {ModelInput}\\\")\\n\",\n    \"print(f\\\"ModelOutput: {ModelOutput}\\\")\\n\",\n    \"print(f\\\"P: {P}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 3: Dataclasses - Clean Data Structures\\n\",\n    \"\\n\",\n    \"**First Principle**: Dataclasses automatically generate boilerplate methods (`__init__`, `__repr__`, `__eq__`) for data-focused classes.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `__post_init__` for validation and default value initialization that depends on other fields.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"@dataclass\\n\",\n    \"class TextInput:\\n\",\n    \"    \\\"\\\"\\\"Structured text input with automatic method generation.\\\"\\\"\\\"\\n\",\n    \"    text: str\\n\",\n    \"    context: Optional[str] = None\\n\",\n    \"    metadata: Dict[str, Any] = None\\n\",\n    \"    \\n\",\n    \"    def __post_init__(self):\\n\",\n    \"        \\\"\\\"\\\"Called after __init__ for custom initialization.\\\"\\\"\\\"\\n\",\n    \"        if self.metadata is None:\\n\",\n    \"            self.metadata = {}  # Avoid mutable default arguments\\n\",\n    \"\\n\",\n    \"@dataclass\\n\",\n    \"class ClassificationOutput:\\n\",\n    \"    \\\"\\\"\\\"Classification result with confidence scores.\\\"\\\"\\\"\\n\",\n    \"    label: str\\n\",\n    \"    confidence: float\\n\",\n    \"    alternatives: List[tuple[str, float]]\\n\",\n    \"    \\n\",\n    \"    def to_dict(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Convert to dictionary for serialization.\\\"\\\"\\\"\\n\",\n    \"        return {\\n\",\n    \"            \\\"label\\\": self.label,\\n\",\n    \"            \\\"confidence\\\": self.confidence,\\n\",\n    \"            \\\"alternatives\\\": self.alternatives\\n\",\n    \"        }\\n\",\n    \"    \\n\",\n    \"    @classmethod\\n\",\n    \"    def from_dict(cls, data: Dict[str, Any]) -> 'ClassificationOutput':\\n\",\n    \"        \\\"\\\"\\\"Create instance from dictionary.\\\"\\\"\\\"\\n\",\n    \"        return cls(\\n\",\n    \"            label=data[\\\"label\\\"],\\n\",\n    \"            confidence=data[\\\"confidence\\\"],\\n\",\n    \"            alternatives=data[\\\"alternatives\\\"]\\n\",\n    \"        )\\n\",\n    \"\\n\",\n    \"# Demonstrate dataclass usage\\n\",\n    \"console.print(Panel(\\\"📊 Dataclasses in Action\\\", style=\\\"bold green\\\"))\\n\",\n    \"\\n\",\n    \"# Create instances\\n\",\n    \"text_input = TextInput(\\n\",\n    \"    text=\\\"This is a positive example!\\\",\\n\",\n    \"    context=\\\"Sentiment analysis demo\\\"\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"classification = ClassificationOutput(\\n\",\n    \"    label=\\\"positive\\\",\\n\",\n    \"    confidence=0.92,\\n\",\n    \"    alternatives=[(\\\"neutral\\\", 0.06), (\\\"negative\\\", 0.02)]\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"print(f\\\"Text Input: {text_input}\\\")\\n\",\n    \"print(f\\\"Classification: {classification}\\\")\\n\",\n    \"print(f\\\"As dict: {classification.to_dict()}\\\")\\n\",\n    \"\\n\",\n    \"# Show automatic equality\\n\",\n    \"same_classification = ClassificationOutput(\\\"positive\\\", 0.92, [(\\\"neutral\\\", 0.06), (\\\"negative\\\", 0.02)])\\n\",\n    \"print(f\\\"\\\\n📋 Automatic equality: {classification == same_classification}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 4: Protocols - Interface Definition Without Inheritance\\n\",\n    \"\\n\",\n    \"**First Principle**: Protocols define \\\"what an object can do\\\" rather than \\\"what an object is\\\" (structural vs nominal typing).\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `@runtime_checkable` when you need `isinstance()` checks, use `Protocol[T]` for generic interfaces.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"@runtime_checkable\\n\",\n    \"class Serializable(Protocol):\\n\",\n    \"    \\\"\\\"\\\"Protocol for objects that can be serialized to/from dictionaries.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def to_dict(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Convert to dictionary.\\\"\\\"\\\"\\n\",\n    \"        ...\\n\",\n    \"    \\n\",\n    \"    @classmethod\\n\",\n    \"    def from_dict(cls, data: Dict[str, Any]) -> 'Serializable':\\n\",\n    \"        \\\"\\\"\\\"Create from dictionary.\\\"\\\"\\\"\\n\",\n    \"        ...\\n\",\n    \"\\n\",\n    \"@runtime_checkable\\n\",\n    \"class Cacheable(Protocol[T]):\\n\",\n    \"    \\\"\\\"\\\"Generic protocol for cacheable objects.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def cache_key(self) -> str:\\n\",\n    \"        \\\"\\\"\\\"Get unique cache key.\\\"\\\"\\\"\\n\",\n    \"        ...\\n\",\n    \"    \\n\",\n    \"    def serialize(self) -> bytes:\\n\",\n    \"        \\\"\\\"\\\"Serialize for caching.\\\"\\\"\\\"\\n\",\n    \"        ...\\n\",\n    \"    \\n\",\n    \"    @classmethod\\n\",\n    \"    def deserialize(cls, data: bytes) -> T:\\n\",\n    \"        \\\"\\\"\\\"Deserialize from cache.\\\"\\\"\\\"\\n\",\n    \"        ...\\n\",\n    \"\\n\",\n    \"# Test protocol compliance\\n\",\n    \"console.print(Panel(\\\"📋 Protocol Checking\\\", style=\\\"bold yellow\\\"))\\n\",\n    \"\\n\",\n    \"# Our ClassificationOutput automatically satisfies Serializable!\\n\",\n    \"result = ClassificationOutput(\\\"positive\\\", 0.85, [(\\\"neutral\\\", 0.15)])\\n\",\n    \"\\n\",\n    \"print(f\\\"Does ClassificationOutput implement Serializable? {isinstance(result, Serializable)}\\\")\\n\",\n    \"\\n\",\n    \"if isinstance(result, Serializable):\\n\",\n    \"    serialized = result.to_dict()\\n\",\n    \"    restored = ClassificationOutput.from_dict(serialized)\\n\",\n    \"    print(f\\\"✅ Serialization works: {restored.label} ({restored.confidence})\\\")\\n\",\n    \"\\n\",\n    \"# Test with other objects\\n\",\n    \"test_objects = [\\n\",\n    \"    (\\\"ClassificationOutput\\\", result),\\n\",\n    \"    (\\\"String\\\", \\\"hello\\\"),\\n\",\n    \"    (\\\"Dictionary\\\", {\\\"key\\\": \\\"value\\\"}),\\n\",\n    \"    (\\\"TextInput\\\", text_input)\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"print(\\\"\\\\n🔍 Runtime Protocol Checks:\\\")\\n\",\n    \"for name, obj in test_objects:\\n\",\n    \"    is_serializable = isinstance(obj, Serializable)\\n\",\n    \"    print(f\\\"  {name}: Serializable = {is_serializable}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 5: TypedDict - Structured Configuration\\n\",\n    \"\\n\",\n    \"**First Principle**: TypedDict provides type safety for dictionaries while maintaining dict performance and JSON compatibility.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `Literal` types for constrained string values, `total=False` for optional fields in inherited TypedDicts.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Define typed dictionaries for configuration\\n\",\n    \"class ModelConfig(TypedDict):\\n\",\n    \"    \\\"\\\"\\\"Basic model configuration with required fields.\\\"\\\"\\\"\\n\",\n    \"    model_id: str\\n\",\n    \"    max_tokens: int\\n\",\n    \"    temperature: float\\n\",\n    \"    provider: Literal[\\\"openai\\\", \\\"anthropic\\\", \\\"local\\\"]  # Constrained values\\n\",\n    \"    timeout_seconds: Optional[float]\\n\",\n    \"\\n\",\n    \"class AdvancedModelConfig(ModelConfig, total=False):\\n\",\n    \"    \\\"\\\"\\\"Extended config with optional fields.\\\"\\\"\\\"\\n\",\n    \"    retry_attempts: int\\n\",\n    \"    fallback_model: str\\n\",\n    \"    cost_limit_usd: float\\n\",\n    \"    custom_headers: Dict[str, str]\\n\",\n    \"\\n\",\n    \"# Type aliases for clarity\\n\",\n    \"Provider = Literal[\\\"openai\\\", \\\"anthropic\\\", \\\"huggingface\\\", \\\"local\\\"]\\n\",\n    \"ModelSize = Literal[\\\"small\\\", \\\"medium\\\", \\\"large\\\", \\\"xl\\\"]\\n\",\n    \"\\n\",\n    \"def create_model_config(\\n\",\n    \"    provider: Provider,\\n\",\n    \"    model_size: ModelSize,\\n\",\n    \"    temperature: float = 0.7\\n\",\n    \") -> ModelConfig:\\n\",\n    \"    \\\"\\\"\\\"Factory function using literal types for validation.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    # Mapping tuples to model IDs\\n\",\n    \"    model_mapping = {\\n\",\n    \"        (\\\"openai\\\", \\\"small\\\"): \\\"gpt-3.5-turbo\\\",\\n\",\n    \"        (\\\"openai\\\", \\\"large\\\"): \\\"gpt-4\\\",\\n\",\n    \"        (\\\"anthropic\\\", \\\"small\\\"): \\\"claude-3-haiku\\\",\\n\",\n    \"        (\\\"anthropic\\\", \\\"large\\\"): \\\"claude-3-opus\\\",\\n\",\n    \"        (\\\"local\\\", \\\"small\\\"): \\\"local-small-model\\\"\\n\",\n    \"    }\\n\",\n    \"    \\n\",\n    \"    model_id = model_mapping.get((provider, model_size), \\\"default-model\\\")\\n\",\n    \"    \\n\",\n    \"    max_tokens_mapping = {\\n\",\n    \"        \\\"small\\\": 1000, \\\"medium\\\": 2000, \\\"large\\\": 4000, \\\"xl\\\": 8000\\n\",\n    \"    }\\n\",\n    \"    \\n\",\n    \"    return ModelConfig(\\n\",\n    \"        model_id=model_id,\\n\",\n    \"        max_tokens=max_tokens_mapping[model_size],\\n\",\n    \"        temperature=temperature,\\n\",\n    \"        provider=provider,\\n\",\n    \"        timeout_seconds=30.0\\n\",\n    \"    )\\n\",\n    \"\\n\",\n    \"# Demonstrate TypedDict usage\\n\",\n    \"console.print(Panel(\\\"📝 TypedDict Configuration\\\", style=\\\"bold magenta\\\"))\\n\",\n    \"\\n\",\n    \"# Create configurations\\n\",\n    \"basic_config: ModelConfig = {\\n\",\n    \"    \\\"model_id\\\": \\\"gpt-4\\\",\\n\",\n    \"    \\\"max_tokens\\\": 2000,\\n\",\n    \"    \\\"temperature\\\": 0.7,\\n\",\n    \"    \\\"provider\\\": \\\"openai\\\",\\n\",\n    \"    \\\"timeout_seconds\\\": 30.0\\n\",\n    \"}\\n\",\n    \"\\n\",\n    \"advanced_config: AdvancedModelConfig = {\\n\",\n    \"    \\\"model_id\\\": \\\"claude-3-opus\\\",\\n\",\n    \"    \\\"max_tokens\\\": 4000,\\n\",\n    \"    \\\"temperature\\\": 0.5,\\n\",\n    \"    \\\"provider\\\": \\\"anthropic\\\",\\n\",\n    \"    \\\"timeout_seconds\\\": 60.0,\\n\",\n    \"    \\\"retry_attempts\\\": 3,\\n\",\n    \"    \\\"fallback_model\\\": \\\"claude-3-haiku\\\",\\n\",\n    \"    \\\"cost_limit_usd\\\": 10.0\\n\",\n    \"}\\n\",\n    \"\\n\",\n    \"print(\\\"📋 Configuration Examples:\\\")\\n\",\n    \"print(f\\\"Basic: {basic_config['provider']} - {basic_config['model_id']}\\\")\\n\",\n    \"print(f\\\"Advanced: {advanced_config['provider']} - {advanced_config['model_id']}\\\")\\n\",\n    \"print(f\\\"Has retries: {advanced_config.get('retry_attempts', 'No')}\\\")\\n\",\n    \"\\n\",\n    \"# Test factory function\\n\",\n    \"print(\\\"\\\\n🏭 Factory Function Results:\\\")\\n\",\n    \"configs = [\\n\",\n    \"    create_model_config(\\\"openai\\\", \\\"large\\\", 0.8),\\n\",\n    \"    create_model_config(\\\"anthropic\\\", \\\"small\\\", 0.3),\\n\",\n    \"    create_model_config(\\\"local\\\", \\\"small\\\", 1.0)\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"for i, config in enumerate(configs, 1):\\n\",\n    \"    print(f\\\"  Config {i}: {config['provider']} - {config['model_id']}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 6: Generic Classes - Type-Safe Containers\\n\",\n    \"\\n\",\n    \"**First Principle**: Generic classes use type variables to create reusable containers that maintain type safety.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `Generic[T]` for classes that store or operate on arbitrary types, use descriptive variable names for domain-specific generics.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class TypedCache(Generic[T]):\\n\",\n    \"    \\\"\\\"\\\"Type-safe cache that remembers what type it stores.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self):\\n\",\n    \"        self._cache: Dict[str, T] = {}\\n\",\n    \"        self._access_count: Dict[str, int] = {}\\n\",\n    \"    \\n\",\n    \"    def get(self, key: str) -> Optional[T]:\\n\",\n    \"        \\\"\\\"\\\"Get item from cache with type safety.\\\"\\\"\\\"\\n\",\n    \"        if key in self._cache:\\n\",\n    \"            self._access_count[key] = self._access_count.get(key, 0) + 1\\n\",\n    \"            return self._cache[key]\\n\",\n    \"        return None\\n\",\n    \"    \\n\",\n    \"    def put(self, key: str, value: T) -> None:\\n\",\n    \"        \\\"\\\"\\\"Store item in cache.\\\"\\\"\\\"\\n\",\n    \"        self._cache[key] = value\\n\",\n    \"        self._access_count[key] = 0\\n\",\n    \"    \\n\",\n    \"    def get_stats(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get cache statistics.\\\"\\\"\\\"\\n\",\n    \"        return {\\n\",\n    \"            \\\"size\\\": len(self._cache),\\n\",\n    \"            \\\"total_access\\\": sum(self._access_count.values()),\\n\",\n    \"            \\\"keys\\\": list(self._cache.keys())\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"# Generic AI Model base class\\n\",\n    \"class AIModel(Generic[ModelInput, ModelOutput], ABC):\\n\",\n    \"    \\\"\\\"\\\"Generic AI model with typed input/output.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, config: ModelConfig):\\n\",\n    \"        self.config = config\\n\",\n    \"    \\n\",\n    \"    @abstractmethod\\n\",\n    \"    async def predict(self, input_data: ModelInput) -> ModelOutput:\\n\",\n    \"        \\\"\\\"\\\"Make prediction with type safety.\\\"\\\"\\\"\\n\",\n    \"        pass\\n\",\n    \"    \\n\",\n    \"    @abstractmethod\\n\",\n    \"    def validate_input(self, input_data: ModelInput) -> bool:\\n\",\n    \"        \\\"\\\"\\\"Validate input data.\\\"\\\"\\\"\\n\",\n    \"        pass\\n\",\n    \"\\n\",\n    \"# Concrete implementation\\n\",\n    \"class TextClassifier(AIModel[TextInput, ClassificationOutput]):\\n\",\n    \"    \\\"\\\"\\\"Text classifier with specific input/output types.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    async def predict(self, input_data: TextInput) -> ClassificationOutput:\\n\",\n    \"        \\\"\\\"\\\"Classify text with mock implementation.\\\"\\\"\\\"\\n\",\n    \"        # Simple sentiment analysis simulation\\n\",\n    \"        text_lower = input_data.text.lower()\\n\",\n    \"        \\n\",\n    \"        if \\\"positive\\\" in text_lower or \\\"good\\\" in text_lower or \\\"great\\\" in text_lower:\\n\",\n    \"            return ClassificationOutput(\\\"positive\\\", 0.92, [(\\\"neutral\\\", 0.06), (\\\"negative\\\", 0.02)])\\n\",\n    \"        elif \\\"negative\\\" in text_lower or \\\"bad\\\" in text_lower or \\\"terrible\\\" in text_lower:\\n\",\n    \"            return ClassificationOutput(\\\"negative\\\", 0.88, [(\\\"neutral\\\", 0.10), (\\\"positive\\\", 0.02)])\\n\",\n    \"        else:\\n\",\n    \"            return ClassificationOutput(\\\"neutral\\\", 0.75, [(\\\"positive\\\", 0.15), (\\\"negative\\\", 0.10)])\\n\",\n    \"    \\n\",\n    \"    def validate_input(self, input_data: TextInput) -> bool:\\n\",\n    \"        \\\"\\\"\\\"Validate text input.\\\"\\\"\\\"\\n\",\n    \"        return (\\n\",\n    \"            isinstance(input_data.text, str) and\\n\",\n    \"            len(input_data.text.strip()) > 0 and\\n\",\n    \"            len(input_data.text) <= 10000\\n\",\n    \"        )\\n\",\n    \"\\n\",\n    \"# Demonstrate generic usage\\n\",\n    \"console.print(Panel(\\\"🎯 Generic Types in Action\\\", style=\\\"bold blue\\\"))\\n\",\n    \"\\n\",\n    \"# Create typed caches\\n\",\n    \"text_cache = TypedCache[str]()\\n\",\n    \"result_cache = TypedCache[ClassificationOutput]()\\n\",\n    \"\\n\",\n    \"# Use text cache\\n\",\n    \"text_cache.put(\\\"greeting\\\", \\\"Hello, world!\\\")\\n\",\n    \"text_cache.put(\\\"farewell\\\", \\\"Goodbye!\\\")\\n\",\n    \"cached_text = text_cache.get(\\\"greeting\\\")\\n\",\n    \"print(f\\\"📝 Cached text: {cached_text}\\\")\\n\",\n    \"\\n\",\n    \"# Use result cache\\n\",\n    \"sample_result = ClassificationOutput(\\\"positive\\\", 0.95, [(\\\"negative\\\", 0.05)])\\n\",\n    \"result_cache.put(\\\"sample\\\", sample_result)\\n\",\n    \"cached_result = result_cache.get(\\\"sample\\\")\\n\",\n    \"print(f\\\"📊 Cached result: {cached_result.label} ({cached_result.confidence})\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n📈 Cache Stats:\\\")\\n\",\n    \"print(f\\\"  Text cache: {text_cache.get_stats()}\\\")\\n\",\n    \"print(f\\\"  Result cache: {result_cache.get_stats()}\\\")\\n\",\n    \"\\n\",\n    \"# Test the classifier\\n\",\n    \"print(f\\\"\\\\n🤖 Testing TextClassifier:\\\")\\n\",\n    \"config = create_model_config(\\\"openai\\\", \\\"large\\\")\\n\",\n    \"classifier = TextClassifier(config)\\n\",\n    \"\\n\",\n    \"test_inputs = [\\n\",\n    \"    TextInput(\\\"This is a great positive example!\\\"),\\n\",\n    \"    TextInput(\\\"This is a terrible negative example!\\\"),\\n\",\n    \"    TextInput(\\\"This is just a normal example.\\\")\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"for i, test_input in enumerate(test_inputs, 1):\\n\",\n    \"    if classifier.validate_input(test_input):\\n\",\n    \"        result = await classifier.predict(test_input)\\n\",\n    \"        print(f\\\"  {i}. '{test_input.text}' -> {result.label} ({result.confidence:.2f})\\\")\\n\",\n    \"    else:\\n\",\n    \"        print(f\\\"  {i}. Invalid input: {test_input.text}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 7: Function Overloading\\n\",\n    \"\\n\",\n    \"**First Principle**: Function overloading allows multiple type signatures for the same function, improving API flexibility while maintaining type safety.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `@overload` for type hints only, implement the actual logic in the non-decorated function below.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class ModelManager:\\n\",\n    \"    \\\"\\\"\\\"Manages multiple AI models with overloaded methods.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self):\\n\",\n    \"        self.models: Dict[str, AIModel] = {}\\n\",\n    \"        self.cache = TypedCache[Any]()\\n\",\n    \"    \\n\",\n    \"    # Overloaded get_model methods\\n\",\n    \"    @overload\\n\",\n    \"    def get_model(self, name: str) -> Optional[AIModel]:\\n\",\n    \"        \\\"\\\"\\\"Get model by name, return None if not found.\\\"\\\"\\\"\\n\",\n    \"        ...\\n\",\n    \"    \\n\",\n    \"    @overload\\n\",\n    \"    def get_model(self, name: str, default: T) -> Union[AIModel, T]:\\n\",\n    \"        \\\"\\\"\\\"Get model by name, return default if not found.\\\"\\\"\\\"\\n\",\n    \"        ...\\n\",\n    \"    \\n\",\n    \"    def get_model(self, name: str, default=None):\\n\",\n    \"        \\\"\\\"\\\"Implementation for both overloads.\\\"\\\"\\\"\\n\",\n    \"        return self.models.get(name, default)\\n\",\n    \"    \\n\",\n    \"    def register_model(self, name: str, model: AIModel) -> None:\\n\",\n    \"        \\\"\\\"\\\"Register a model with a name.\\\"\\\"\\\"\\n\",\n    \"        self.models[name] = model\\n\",\n    \"    \\n\",\n    \"    # Overloaded predict methods\\n\",\n    \"    @overload\\n\",\n    \"    async def predict(self, model_name: str, input_data: TextInput) -> ClassificationOutput:\\n\",\n    \"        \\\"\\\"\\\"Predict with text classifier.\\\"\\\"\\\"\\n\",\n    \"        ...\\n\",\n    \"    \\n\",\n    \"    @overload\\n\",\n    \"    async def predict(self, model_name: str, input_data: Any) -> Any:\\n\",\n    \"        \\\"\\\"\\\"Generic prediction method.\\\"\\\"\\\"\\n\",\n    \"        ...\\n\",\n    \"    \\n\",\n    \"    async def predict(self, model_name: str, input_data: Any) -> Any:\\n\",\n    \"        \\\"\\\"\\\"Make prediction with caching.\\\"\\\"\\\"\\n\",\n    \"        model = self.get_model(model_name)\\n\",\n    \"        if model is None:\\n\",\n    \"            raise ValueError(f\\\"Model '{model_name}' not found\\\")\\n\",\n    \"        \\n\",\n    \"        # Simple cache key generation\\n\",\n    \"        cache_key = f\\\"{model_name}:{hash(str(input_data.text if hasattr(input_data, 'text') else input_data))}\\\"\\n\",\n    \"        \\n\",\n    \"        # Check cache first\\n\",\n    \"        cached_result = self.cache.get(cache_key)\\n\",\n    \"        if cached_result is not None:\\n\",\n    \"            print(f\\\"🗄️  Cache hit for {model_name}\\\")\\n\",\n    \"            return cached_result\\n\",\n    \"        \\n\",\n    \"        # Make prediction\\n\",\n    \"        print(f\\\"🤖 Making prediction with {model_name}\\\")\\n\",\n    \"        result = await model.predict(input_data)\\n\",\n    \"        \\n\",\n    \"        # Cache the result\\n\",\n    \"        self.cache.put(cache_key, result)\\n\",\n    \"        \\n\",\n    \"        return result\\n\",\n    \"\\n\",\n    \"# Demonstrate function overloading\\n\",\n    \"console.print(Panel(\\\"⚡ Function Overloading\\\", style=\\\"bold cyan\\\"))\\n\",\n    \"\\n\",\n    \"# Setup\\n\",\n    \"manager = ModelManager()\\n\",\n    \"config = create_model_config(\\\"openai\\\", \\\"large\\\")\\n\",\n    \"classifier = TextClassifier(config)\\n\",\n    \"manager.register_model(\\\"sentiment_classifier\\\", classifier)\\n\",\n    \"\\n\",\n    \"print(\\\"🔧 Testing overloaded get_model:\\\")\\n\",\n    \"\\n\",\n    \"# Test get_model without default\\n\",\n    \"model1 = manager.get_model(\\\"sentiment_classifier\\\")\\n\",\n    \"print(f\\\"  Found model: {model1 is not None}\\\")\\n\",\n    \"\\n\",\n    \"# Test get_model with default\\n\",\n    \"model2 = manager.get_model(\\\"nonexistent\\\", \\\"default_value\\\")\\n\",\n    \"print(f\\\"  With default: {model2}\\\")\\n\",\n    \"\\n\",\n    \"print(\\\"\\\\n🎯 Testing overloaded predict:\\\")\\n\",\n    \"\\n\",\n    \"# Test prediction with caching\\n\",\n    \"test_input = TextInput(\\\"This is a fantastic positive example!\\\")\\n\",\n    \"\\n\",\n    \"# First call - should compute\\n\",\n    \"result1 = await manager.predict(\\\"sentiment_classifier\\\", test_input)\\n\",\n    \"print(f\\\"  First call: {result1.label} ({result1.confidence:.2f})\\\")\\n\",\n    \"\\n\",\n    \"# Second call - should use cache\\n\",\n    \"result2 = await manager.predict(\\\"sentiment_classifier\\\", test_input)\\n\",\n    \"print(f\\\"  Second call: {result2.label} ({result2.confidence:.2f})\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n📊 Cache statistics: {manager.cache.get_stats()}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 8: Advanced Decorators with Type Preservation\\n\",\n    \"\\n\",\n    \"**First Principle**: Decorators can preserve function signatures and types using `ParamSpec` and proper generic typing.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `ParamSpec` to maintain parameter types, use `Callable[P, T]` for functions that accept any parameters and return type T.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"def with_retries(max_retries: int = 3) -> Callable[[Callable[P, T]], Callable[P, T]]:\\n\",\n    \"    \\\"\\\"\\\"Decorator that adds retry logic with full type preservation.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def decorator(func: Callable[P, T]) -> Callable[P, T]:\\n\",\n    \"        async def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\\n\",\n    \"            last_exception = None\\n\",\n    \"            \\n\",\n    \"            for attempt in range(max_retries):\\n\",\n    \"                try:\\n\",\n    \"                    # Handle both sync and async functions\\n\",\n    \"                    if asyncio.iscoroutinefunction(func):\\n\",\n    \"                        return await func(*args, **kwargs)\\n\",\n    \"                    else:\\n\",\n    \"                        return func(*args, **kwargs)\\n\",\n    \"                except Exception as e:\\n\",\n    \"                    last_exception = e\\n\",\n    \"                    print(f\\\"❌ Attempt {attempt + 1} failed: {str(e)[:50]}...\\\")\\n\",\n    \"                    \\n\",\n    \"                    if attempt < max_retries - 1:\\n\",\n    \"                        wait_time = 2 ** attempt  # Exponential backoff\\n\",\n    \"                        print(f\\\"⏳ Waiting {wait_time}s before retry...\\\")\\n\",\n    \"                        await asyncio.sleep(wait_time)\\n\",\n    \"            \\n\",\n    \"            print(f\\\"💥 All {max_retries} attempts failed\\\")\\n\",\n    \"            raise last_exception\\n\",\n    \"        \\n\",\n    \"        return wrapper\\n\",\n    \"    return decorator\\n\",\n    \"\\n\",\n    \"def log_calls(func: Callable[P, T]) -> Callable[P, T]:\\n\",\n    \"    \\\"\\\"\\\"Decorator that logs function calls with type preservation.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    async def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\\n\",\n    \"        func_name = func.__name__\\n\",\n    \"        print(f\\\"🚀 Calling {func_name} with {len(args)} args, {len(kwargs)} kwargs\\\")\\n\",\n    \"        \\n\",\n    \"        try:\\n\",\n    \"            if asyncio.iscoroutinefunction(func):\\n\",\n    \"                result = await func(*args, **kwargs)\\n\",\n    \"            else:\\n\",\n    \"                result = func(*args, **kwargs)\\n\",\n    \"            \\n\",\n    \"            print(f\\\"✅ {func_name} completed successfully\\\")\\n\",\n    \"            return result\\n\",\n    \"        except Exception as e:\\n\",\n    \"            print(f\\\"💥 {func_name} failed: {e}\\\")\\n\",\n    \"            raise\\n\",\n    \"    \\n\",\n    \"    return wrapper\\n\",\n    \"\\n\",\n    \"# Example functions using the decorators\\n\",\n    \"@with_retries(max_retries=3)\\n\",\n    \"@log_calls\\n\",\n    \"async def flaky_api_call(text: str, fail_rate: float = 0.7) -> str:\\n\",\n    \"    \\\"\\\"\\\"Simulates an unreliable API call.\\\"\\\"\\\"\\n\",\n    \"    import random\\n\",\n    \"    \\n\",\n    \"    if random.random() < fail_rate:\\n\",\n    \"        raise ConnectionError(f\\\"Simulated network failure for '{text}'\\\")\\n\",\n    \"    \\n\",\n    \"    # Simulate processing time\\n\",\n    \"    await asyncio.sleep(0.1)\\n\",\n    \"    return f\\\"Processed: {text.upper()}\\\"\\n\",\n    \"\\n\",\n    \"@with_retries(max_retries=2)\\n\",\n    \"async def reliable_classification(input_data: TextInput) -> ClassificationOutput:\\n\",\n    \"    \\\"\\\"\\\"Reliable classification with retries.\\\"\\\"\\\"\\n\",\n    \"    # Simulate occasional failures\\n\",\n    \"    import random\\n\",\n    \"    if random.random() < 0.3:\\n\",\n    \"        raise ValueError(\\\"Temporary classification error\\\")\\n\",\n    \"    \\n\",\n    \"    # Simple classification\\n\",\n    \"    text_lower = input_data.text.lower()\\n\",\n    \"    if \\\"good\\\" in text_lower or \\\"great\\\" in text_lower:\\n\",\n    \"        return ClassificationOutput(\\\"positive\\\", 0.90, [(\\\"neutral\\\", 0.08), (\\\"negative\\\", 0.02)])\\n\",\n    \"    else:\\n\",\n    \"        return ClassificationOutput(\\\"neutral\\\", 0.70, [(\\\"positive\\\", 0.20), (\\\"negative\\\", 0.10)])\\n\",\n    \"\\n\",\n    \"# Demonstrate advanced decorators\\n\",\n    \"console.print(Panel(\\\"🎨 Advanced Decorators with Type Preservation\\\", style=\\\"bold red\\\"))\\n\",\n    \"\\n\",\n    \"print(\\\"🧪 Testing flaky API call:\\\")\\n\",\n    \"try:\\n\",\n    \"    result = await flaky_api_call(\\\"hello world\\\", fail_rate=0.8)\\n\",\n    \"    print(f\\\"🎉 Success: {result}\\\")\\n\",\n    \"except Exception as e:\\n\",\n    \"    print(f\\\"🚫 Final failure: {e}\\\")\\n\",\n    \"\\n\",\n    \"print(\\\"\\\\n🧪 Testing reliable classification:\\\")\\n\",\n    \"test_input = TextInput(\\\"This is a good example\\\")\\n\",\n    \"try:\\n\",\n    \"    classification = await reliable_classification(test_input)\\n\",\n    \"    print(f\\\"🎯 Classification: {classification.label} ({classification.confidence:.2f})\\\")\\n\",\n    \"except Exception as e:\\n\",\n    \"    print(f\\\"🚫 Classification failed: {e}\\\")\\n\",\n    \"\\n\",\n    \"# Show that type information is preserved\\n\",\n    \"print(\\\"\\\\n🔍 Type preservation check:\\\")\\n\",\n    \"print(f\\\"flaky_api_call annotations: {flaky_api_call.__annotations__}\\\")\\n\",\n    \"print(f\\\"reliable_classification return type preserved: {hasattr(reliable_classification, '__annotations__')}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 9: Real-World Integration Example\\n\",\n    \"\\n\",\n    \"**First Principle**: Combine all typing features to create a robust, type-safe AI system that's easy to extend and maintain.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use composition of typed components rather than complex inheritance hierarchies.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class AIServiceConfig(TypedDict):\\n\",\n    \"    \\\"\\\"\\\"Configuration for AI service.\\\"\\\"\\\"\\n\",\n    \"    default_provider: Provider\\n\",\n    \"    max_concurrent_requests: int\\n\",\n    \"    cache_ttl_seconds: int\\n\",\n    \"    retry_attempts: int\\n\",\n    \"\\n\",\n    \"class AIService:\\n\",\n    \"    \\\"\\\"\\\"Production-ready AI service using all typing features.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, config: AIServiceConfig):\\n\",\n    \"        self.config = config\\n\",\n    \"        self.manager = ModelManager()\\n\",\n    \"        self.request_cache = TypedCache[ClassificationOutput]()\\n\",\n    \"        self._setup_default_models()\\n\",\n    \"    \\n\",\n    \"    def _setup_default_models(self) -> None:\\n\",\n    \"        \\\"\\\"\\\"Initialize default models.\\\"\\\"\\\"\\n\",\n    \"        model_config = create_model_config(\\n\",\n    \"            self.config[\\\"default_provider\\\"], \\n\",\n    \"            \\\"large\\\", \\n\",\n    \"            temperature=0.5\\n\",\n    \"        )\\n\",\n    \"        \\n\",\n    \"        classifier = TextClassifier(model_config)\\n\",\n    \"        self.manager.register_model(\\\"default_classifier\\\", classifier)\\n\",\n    \"    \\n\",\n    \"    @with_retries(max_retries=3)\\n\",\n    \"    @log_calls\\n\",\n    \"    async def classify_text(\\n\",\n    \"        self, \\n\",\n    \"        text: str, \\n\",\n    \"        context: Optional[str] = None,\\n\",\n    \"        use_cache: bool = True\\n\",\n    \"    ) -> ClassificationOutput:\\n\",\n    \"        \\\"\\\"\\\"Classify text with full error handling and caching.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        # Create structured input\\n\",\n    \"        text_input = TextInput(text=text, context=context)\\n\",\n    \"        \\n\",\n    \"        # Check cache if enabled\\n\",\n    \"        if use_cache:\\n\",\n    \"            cache_key = f\\\"classify:{hash(text)}:{hash(context or '')}\\\"\\n\",\n    \"            cached_result = self.request_cache.get(cache_key)\\n\",\n    \"            if cached_result is not None:\\n\",\n    \"                print(f\\\"💾 Cache hit for text: '{text[:30]}...'\\\")\\n\",\n    \"                return cached_result\\n\",\n    \"        \\n\",\n    \"        # Make prediction\\n\",\n    \"        result = await self.manager.predict(\\\"default_classifier\\\", text_input)\\n\",\n    \"        \\n\",\n    \"        # Cache result\\n\",\n    \"        if use_cache and isinstance(result, ClassificationOutput):\\n\",\n    \"            self.request_cache.put(cache_key, result)\\n\",\n    \"        \\n\",\n    \"        return result\\n\",\n    \"    \\n\",\n    \"    async def batch_classify(\\n\",\n    \"        self, \\n\",\n    \"        texts: List[str], \\n\",\n    \"        context: Optional[str] = None\\n\",\n    \"    ) -> List[ClassificationOutput]:\\n\",\n    \"        \\\"\\\"\\\"Classify multiple texts concurrently.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        # Create tasks for concurrent processing\\n\",\n    \"        tasks = [\\n\",\n    \"            self.classify_text(text, context)\\n\",\n    \"            for text in texts\\n\",\n    \"        ]\\n\",\n    \"        \\n\",\n    \"        # Wait for all classifications\\n\",\n    \"        results = await asyncio.gather(*tasks, return_exceptions=True)\\n\",\n    \"        \\n\",\n    \"        # Handle any failures\\n\",\n    \"        valid_results = []\\n\",\n    \"        for i, result in enumerate(results):\\n\",\n    \"            if isinstance(result, Exception):\\n\",\n    \"                print(f\\\"❌ Failed to classify text {i}: {result}\\\")\\n\",\n    \"                # Return neutral as fallback\\n\",\n    \"                valid_results.append(\\n\",\n    \"                    ClassificationOutput(\\\"neutral\\\", 0.5, [(\\\"positive\\\", 0.25), (\\\"negative\\\", 0.25)])\\n\",\n    \"                )\\n\",\n    \"            else:\\n\",\n    \"                valid_results.append(result)\\n\",\n    \"        \\n\",\n    \"        return valid_results\\n\",\n    \"    \\n\",\n    \"    def get_stats(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get service statistics.\\\"\\\"\\\"\\n\",\n    \"        return {\\n\",\n    \"            \\\"config\\\": self.config,\\n\",\n    \"            \\\"models_registered\\\": len(self.manager.models),\\n\",\n    \"            \\\"cache_stats\\\": self.request_cache.get_stats(),\\n\",\n    \"            \\\"manager_cache_stats\\\": self.manager.cache.get_stats()\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"# Demonstrate the complete system\\n\",\n    \"console.print(Panel(\\\"🏗️ Complete AI Service Integration\\\", style=\\\"bold green\\\"))\\n\",\n    \"\\n\",\n    \"# Create service configuration\\n\",\n    \"service_config: AIServiceConfig = {\\n\",\n    \"    \\\"default_provider\\\": \\\"openai\\\",\\n\",\n    \"    \\\"max_concurrent_requests\\\": 10,\\n\",\n    \"    \\\"cache_ttl_seconds\\\": 3600,\\n\",\n    \"    \\\"retry_attempts\\\": 3\\n\",\n    \"}\\n\",\n    \"\\n\",\n    \"# Initialize service\\n\",\n    \"ai_service = AIService(service_config)\\n\",\n    \"\\n\",\n    \"print(\\\"🧪 Testing single classification:\\\")\\n\",\n    \"single_result = await ai_service.classify_text(\\n\",\n    \"    \\\"This is an amazing product with great features!\\\",\\n\",\n    \"    context=\\\"Product review\\\"\\n\",\n    \")\\n\",\n    \"print(f\\\"Result: {single_result.label} (confidence: {single_result.confidence:.2f})\\\")\\n\",\n    \"\\n\",\n    \"print(\\\"\\\\n🧪 Testing batch classification:\\\")\\n\",\n    \"test_texts = [\\n\",\n    \"    \\\"This product is fantastic!\\\",\\n\",\n    \"    \\\"Terrible customer service experience.\\\",\\n\",\n    \"    \\\"The product works as expected.\\\",\\n\",\n    \"    \\\"Outstanding quality and great value!\\\"\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"batch_results = await ai_service.batch_classify(test_texts, \\\"Product reviews\\\")\\n\",\n    \"\\n\",\n    \"for i, (text, result) in enumerate(zip(test_texts, batch_results), 1):\\n\",\n    \"    print(f\\\"  {i}. '{text}' -> {result.label} ({result.confidence:.2f})\\\")\\n\",\n    \"\\n\",\n    \"print(\\\"\\\\n📊 Service statistics:\\\")\\n\",\n    \"stats = ai_service.get_stats()\\n\",\n    \"print(f\\\"Models registered: {stats['models_registered']}\\\")\\n\",\n    \"print(f\\\"Cache entries: {stats['cache_stats']['size']}\\\")\\n\",\n    \"print(f\\\"Total cache accesses: {stats['cache_stats']['total_access']}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 10: Key Takeaways and Best Practices\\n\",\n    \"\\n\",\n    \"**Summary of Python Typing First Principles and Idioms**\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"console.print(Panel(\\\"🎓 Key Takeaways: Advanced Python Typing\\\", style=\\\"bold blue\\\"))\\n\",\n    \"\\n\",\n    \"takeaways = {\\n\",\n    \"    \\\"Type Variables (Generic[T])\\\": [\\n\",\n    \"        \\\"• Enable reusable, type-safe components\\\",\\n\",\n    \"        \\\"• Use descriptive names: ModelInput, ModelOutput\\\",\\n\",\n    \"        \\\"• Maintain type relationships across function calls\\\"\\n\",\n    \"    ],\\n\",\n    \"    \\\"Protocols\\\": [\\n\",\n    \"        \\\"• Define 'what objects can do' not 'what they are'\\\",\\n\",\n    \"        \\\"• Use @runtime_checkable for isinstance() support\\\",\\n\",\n    \"        \\\"• Protocol[T] enables generic interfaces\\\"\\n\",\n    \"    ],\\n\",\n    \"    \\\"TypedDict\\\": [\\n\",\n    \"        \\\"• Type-safe dictionaries for configuration\\\",\\n\",\n    \"        \\\"• Use Literal types for constrained values\\\",\\n\",\n    \"        \\\"• total=False for optional fields in inheritance\\\"\\n\",\n    \"    ],\\n\",\n    \"    \\\"Dataclasses\\\": [\\n\",\n    \"        \\\"• Automatic __init__, __repr__, __eq__ generation\\\",\\n\",\n    \"        \\\"• Use __post_init__ for validation/defaults\\\",\\n\",\n    \"        \\\"• Avoid mutable defaults (use None + __post_init__)\\\"\\n\",\n    \"    ],\\n\",\n    \"    \\\"Function Overloading\\\": [\\n\",\n    \"        \\\"• Multiple type signatures for flexible APIs\\\",\\n\",\n    \"        \\\"• @overload for type hints, implementation below\\\",\\n\",\n    \"        \\\"• Improves IDE support and type checking\\\"\\n\",\n    \"    ],\\n\",\n    \"    \\\"Advanced Decorators\\\": [\\n\",\n    \"        \\\"• Use ParamSpec (P) to preserve parameter types\\\",\\n\",\n    \"        \\\"• Callable[P, T] for type-preserving decorators\\\",\\n\",\n    \"        \\\"• Handle both sync and async functions\\\"\\n\",\n    \"    ]\\n\",\n    \"}\\n\",\n    \"\\n\",\n    \"for concept, points in takeaways.items():\\n\",\n    \"    console.print(f\\\"\\\\n[bold yellow]{concept}:[/bold yellow]\\\")\\n\",\n    \"    for point in points:\\n\",\n    \"        console.print(f\\\"  {point}\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold green]🚀 Production Tips:[/bold green]\\\")\\n\",\n    \"production_tips = [\\n\",\n    \"    \\\"Use mypy or pyright for static type checking\\\",\\n\",\n    \"    \\\"Start with basic types, add generics as needed\\\",\\n\",\n    \"    \\\"Prefer composition over complex inheritance\\\",\\n\",\n    \"    \\\"Use typing for public APIs, relax for internal code\\\",\\n\",\n    \"    \\\"Document complex generic types with examples\\\",\\n\",\n    \"    \\\"Test type annotations with actual usage patterns\\\"\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"for tip in production_tips:\\n\",\n    \"    console.print(f\\\"  💡 {tip}\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold magenta]🎯 Next Steps:[/bold magenta]\\\")\\n\",\n    \"next_steps = [\\n\",\n    \"    \\\"Practice with your own AI components\\\",\\n\",\n    \"    \\\"Explore async patterns in the next example\\\",\\n\",\n    \"    \\\"Set up mypy in your development workflow\\\",\\n\",\n    \"    \\\"Build a typed plugin system using Protocols\\\",\\n\",\n    \"    \\\"Create generic data processing pipelines\\\"\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"for step in next_steps:\\n\",\n    \"    console.print(f\\\"  📚 {step}\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold blue]🎉 Congratulations![/bold blue] You now understand Python's advanced type system!\\\")\\n\",\n    \"console.print(\\\"Use these patterns to build robust, maintainable AI systems. 🤖✨\\\")\"\n   ]\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"Python 3\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.11.0\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 4\n}","structuredPatch":[]}}
{"parentUuid":"c0ffa078-39fd-4f89-95f2-74dbbf3718b3","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_01TvRi1ZdRva55QJKUB5J2U6","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"I've created a comprehensive Jupyter notebook that transforms the advanced type system examples into an interactive learning experience. Here's what the notebook covers:\n\n## 📚 **Learning Structure**\n\n**10 Progressive Cells** covering:\n\n1. **Setup & Imports** - Essential typing components\n2. **Type Variables** - Foundation of generic programming  \n3. **Dataclasses** - Clean data structures with automatic methods\n4. **Protocols** - Interface definition without inheritance\n5. **TypedDict** - Structured configuration with type safety\n6. **Generic Classes** - Type-safe containers and AI models\n7. **Function Overloading** - Multiple signatures for flexible APIs\n8. **Advanced Decorators** - Type-preserving function enhancement\n9. **Real-World Integration** - Complete AI service example\n10. **Key Takeaways** - Best practices and production tips\n\n## 🎯 **First Principles Explained**\n\n- **Type Safety**: How Python's type system prevents bugs without runtime cost\n- **Structural vs Nominal Typing**: Why Protocols are powerful for AI systems\n- **Generic Programming**: Building reusable components that work with any type\n- **Composition over Inheritance**: Modern Python patterns for maintainable code\n\n## 🐍 **Python Idioms Covered**\n\n- `@runtime_checkable` for isinstance() with Protocols\n- `__post_init__` for dataclass validation\n- `total=False` for optional TypedDict fields\n- `ParamSpec` for type-preserving decorators\n- `@overload` for multiple function signatures\n\n## 🤖 **AI-Specific Examples**\n\n- **Text Classification Pipeline** with typed inputs/outputs\n- **Model Management System** with caching and retries\n- **Generic AI Model Interface** that works with any data type\n- **Production AI Service** combining all patterns\n\nThe notebook is designed for hands-on learning - each cell builds on the previous one, and you can run them interactively to see the concepts in action. It will help you become well-rounded in both Python typing fundamentals and practical AI development patterns."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":28927,"cache_read_input_tokens":15686,"output_tokens":1}},"requestId":"req_vrtx_011CRhRVtRQkYo1oaDuMCfhk","type":"assistant","uuid":"547241d1-4b28-45f4-9375-1d14550796c5","timestamp":"2025-08-01T17:58:10.322Z"}
{"parentUuid":"547241d1-4b28-45f4-9375-1d14550796c5","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","type":"user","message":{"role":"user","content":"ok great, can you move notebooks directory this one and create similiar for other 2,3,4,5 also start with 3, 2,5,4 python files"},"uuid":"281692fb-bba5-45be-abd6-0a25b66fc69a","timestamp":"2025-08-01T17:59:22.472Z"}
{"parentUuid":"281692fb-bba5-45be-abd6-0a25b66fc69a","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_01XEYN1B4nMQhn3Ro8UwxXYE","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"I'll create a notebooks directory and move the existing notebook there, then create similar interactive learning notebooks for the other Python files in the specified order (3, 2, 5, 4)."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":523,"cache_read_input_tokens":44613,"output_tokens":1}},"requestId":"req_vrtx_011CRhRc2ENvQpAogC3YwFmm","type":"assistant","uuid":"ce230e36-d759-40c8-b6c7-586903ace22e","timestamp":"2025-08-01T17:59:25.690Z"}
{"parentUuid":"ce230e36-d759-40c8-b6c7-586903ace22e","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_01XEYN1B4nMQhn3Ro8UwxXYE","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_vrtx_01EA3KRVAS8iTiFSn72wWLgy","name":"Bash","input":{"command":"mkdir -p /home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/notebooks","description":"Create notebooks directory"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":523,"cache_read_input_tokens":44613,"output_tokens":1}},"requestId":"req_vrtx_011CRhRc2ENvQpAogC3YwFmm","type":"assistant","uuid":"ba1f887e-b3d1-4dac-9c0a-8927a7753808","timestamp":"2025-08-01T17:59:26.495Z"}
{"parentUuid":"ba1f887e-b3d1-4dac-9c0a-8927a7753808","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_vrtx_01EA3KRVAS8iTiFSn72wWLgy","type":"tool_result","content":"","is_error":false}]},"uuid":"577da939-6950-4f8f-a13b-f5929d5310ed","timestamp":"2025-08-01T17:59:31.357Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"577da939-6950-4f8f-a13b-f5929d5310ed","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_01Qdwa8oyL3w9HjX77ZDUsKJ","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_vrtx_017AJakLpnRdu1GcXLWyU3aZ","name":"Bash","input":{"command":"mv /home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/examples/01_type_system_advanced_learning.ipynb /home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/notebooks/","description":"Move notebook to notebooks directory"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":163,"cache_read_input_tokens":45136,"output_tokens":25}},"requestId":"req_vrtx_011CRhRcgKqSUpVWX3XUgXMT","type":"assistant","uuid":"f709e3f6-de9d-42dc-9f52-7557720a7994","timestamp":"2025-08-01T17:59:34.731Z"}
{"parentUuid":"f709e3f6-de9d-42dc-9f52-7557720a7994","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_vrtx_017AJakLpnRdu1GcXLWyU3aZ","type":"tool_result","content":"","is_error":false}]},"uuid":"380435fb-1caf-4e97-92bf-26d08256208f","timestamp":"2025-08-01T17:59:39.180Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"380435fb-1caf-4e97-92bf-26d08256208f","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_01Ri7zKk3GmE6RYPqb9PUTyp","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Now let me read the other Python files to create similar notebooks. Starting with file 3:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":167,"cache_read_input_tokens":45299,"output_tokens":1}},"requestId":"req_vrtx_011CRhRdFSePfKUAXavQsqjj","type":"assistant","uuid":"a2cedc05-e57e-4235-a8b1-a8309f13a7ec","timestamp":"2025-08-01T17:59:42.494Z"}
{"parentUuid":"a2cedc05-e57e-4235-a8b1-a8309f13a7ec","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_01Ri7zKk3GmE6RYPqb9PUTyp","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_vrtx_01LUUKKqTkb5chD215gpDt9b","name":"Read","input":{"file_path":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/examples/03_context_managers.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":167,"cache_read_input_tokens":45299,"output_tokens":1}},"requestId":"req_vrtx_011CRhRdFSePfKUAXavQsqjj","type":"assistant","uuid":"559c2b66-7e45-4951-8150-cf4f17348003","timestamp":"2025-08-01T17:59:43.110Z"}
{"parentUuid":"559c2b66-7e45-4951-8150-cf4f17348003","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_01Ri7zKk3GmE6RYPqb9PUTyp","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_vrtx_01E2ieMrFtemuoFa5Lk3XNUK","name":"Read","input":{"file_path":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/examples/02_async_patterns.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":167,"cache_read_input_tokens":45299,"output_tokens":1}},"requestId":"req_vrtx_011CRhRdFSePfKUAXavQsqjj","type":"assistant","uuid":"57a76767-e1bd-427a-9a27-af76b4b685e0","timestamp":"2025-08-01T17:59:43.830Z"}
{"parentUuid":"57a76767-e1bd-427a-9a27-af76b4b685e0","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_01Ri7zKk3GmE6RYPqb9PUTyp","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_vrtx_01Fg17WrVamtfpEj1VED6Vgr","name":"Read","input":{"file_path":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/examples/05_performance_optimization.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":167,"cache_read_input_tokens":45299,"output_tokens":1}},"requestId":"req_vrtx_011CRhRdFSePfKUAXavQsqjj","type":"assistant","uuid":"cfbbcd2e-d317-4bce-956e-6167f7124572","timestamp":"2025-08-01T17:59:44.698Z"}
{"parentUuid":"cfbbcd2e-d317-4bce-956e-6167f7124572","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_01Ri7zKk3GmE6RYPqb9PUTyp","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_vrtx_011fS3161tFmRKbYSGG5Pi8z","name":"Read","input":{"file_path":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/examples/04_error_handling.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":167,"cache_read_input_tokens":45299,"output_tokens":1}},"requestId":"req_vrtx_011CRhRdFSePfKUAXavQsqjj","type":"assistant","uuid":"36af252e-5632-4a43-9d14-15b313dbc3a8","timestamp":"2025-08-01T17:59:45.242Z"}
{"parentUuid":"36af252e-5632-4a43-9d14-15b313dbc3a8","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File does not exist.","is_error":true,"tool_use_id":"toolu_vrtx_01LUUKKqTkb5chD215gpDt9b"}]},"uuid":"3e9adf2b-6213-474b-951d-f1fa5c328c1e","timestamp":"2025-08-01T17:59:45.283Z","toolUseResult":"Error: File does not exist."}
{"parentUuid":"3e9adf2b-6213-474b-951d-f1fa5c328c1e","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_vrtx_01E2ieMrFtemuoFa5Lk3XNUK","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→\"\"\"\n     3→Example 2: Async Patterns for AI Systems\n     4→\n     5→Learn advanced asyncio patterns for building high-performance\n     6→AI systems with concurrent processing, streaming, and resource management.\n     7→\n     8→Run this file to see the examples in action:\n     9→    python 03-python-idioms/examples/02_async_patterns.py\n    10→\"\"\"\n    11→\n    12→import sys\n    13→import os\n    14→sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))\n    15→\n    16→import asyncio\n    17→from typing import AsyncGenerator, AsyncIterator, Callable, Any, Optional, List, Dict\n    18→from dataclasses import dataclass\n    19→from contextlib import asynccontextmanager\n    20→import time\n    21→from rich.console import Console\n    22→from rich.panel import Panel\n    23→from rich.table import Table\n    24→from rich.live import Live\n    25→from rich.progress import Progress, TaskID\n    26→\n    27→from common import Message, ChatResponse, Choice\n    28→\n    29→console = Console()\n    30→\n    31→\n    32→# 🎯 LEARNING GOAL: Master async patterns for high-performance AI systems\n    33→\n    34→\n    35→@dataclass\n    36→class StreamingChunk:\n    37→    \"\"\"Represents a chunk of streaming data.\"\"\"\n    38→    content: str\n    39→    chunk_id: int\n    40→    is_final: bool\n    41→    metadata: Dict[str, Any] = None\n    42→    \n    43→    def __post_init__(self):\n    44→        if self.metadata is None:\n    45→            self.metadata = {}\n    46→\n    47→\n    48→class AsyncRateLimiter:\n    49→    \"\"\"Async rate limiter for API calls.\"\"\"\n    50→    \n    51→    def __init__(self, max_calls: int, time_window: float):\n    52→        self.max_calls = max_calls\n    53→        self.time_window = time_window\n    54→        self.calls: List[float] = []\n    55→        self._lock = asyncio.Lock()\n    56→    \n    57→    async def acquire(self) -> None:\n    58→        \"\"\"Acquire permission to make a call.\"\"\"\n    59→        async with self._lock:\n    60→            now = time.time()\n    61→            \n    62→            # Remove old calls outside the window\n    63→            self.calls = [call_time for call_time in self.calls \n    64→                         if now - call_time < self.time_window]\n    65→            \n    66→            # If we're at the limit, wait\n    67→            if len(self.calls) >= self.max_calls:\n    68→                oldest_call = min(self.calls)\n    69→                wait_time = self.time_window - (now - oldest_call)\n    70→                if wait_time > 0:\n    71→                    await asyncio.sleep(wait_time)\n    72→                    # Recursive call to try again\n    73→                    return await self.acquire()\n    74→            \n    75→            # Record this call\n    76→            self.calls.append(now)\n    77→    \n    78→    def get_stats(self) -> Dict[str, Any]:\n    79→        \"\"\"Get rate limiter statistics.\"\"\"\n    80→        now = time.time()\n    81→        recent_calls = [call for call in self.calls if now - call < self.time_window]\n    82→        return {\n    83→            \"current_calls\": len(recent_calls),\n    84→            \"max_calls\": self.max_calls,\n    85→            \"time_window\": self.time_window,\n    86→            \"utilization\": len(recent_calls) / self.max_calls\n    87→        }\n    88→\n    89→\n    90→class AsyncConnectionPool:\n    91→    \"\"\"Connection pool for managing async resources.\"\"\"\n    92→    \n    93→    def __init__(self, create_connection: Callable, max_size: int = 10):\n    94→        self.create_connection = create_connection\n    95→        self.max_size = max_size\n    96→        self.pool: asyncio.Queue = asyncio.Queue(maxsize=max_size)\n    97→        self.created_count = 0\n    98→        self.active_connections = 0\n    99→        self._lock = asyncio.Lock()\n   100→    \n   101→    async def get_connection(self):\n   102→        \"\"\"Get a connection from the pool.\"\"\"\n   103→        try:\n   104→            # Try to get existing connection with timeout\n   105→            connection = await asyncio.wait_for(self.pool.get(), timeout=0.1)\n   106→            self.active_connections += 1\n   107→            return connection\n   108→        except asyncio.TimeoutError:\n   109→            # Create new connection if under limit\n   110→            async with self._lock:\n   111→                if self.created_count < self.max_size:\n   112→                    connection = await self.create_connection()\n   113→                    self.created_count += 1\n   114→                    self.active_connections += 1\n   115→                    return connection\n   116→            \n   117→            # Wait for available connection\n   118→            connection = await self.pool.get()\n   119→            self.active_connections += 1\n   120→            return connection\n   121→    \n   122→    async def return_connection(self, connection):\n   123→        \"\"\"Return connection to pool.\"\"\"\n   124→        self.active_connections -= 1\n   125→        await self.pool.put(connection)\n   126→    \n   127→    @asynccontextmanager\n   128→    async def connection(self):\n   129→        \"\"\"Context manager for automatic connection management.\"\"\"\n   130→        conn = await self.get_connection()\n   131→        try:\n   132→            yield conn\n   133→        finally:\n   134→            await self.return_connection(conn)\n   135→    \n   136→    def get_stats(self) -> Dict[str, Any]:\n   137→        \"\"\"Get pool statistics.\"\"\"\n   138→        return {\n   139→            \"pool_size\": self.pool.qsize(),\n   140→            \"created_count\": self.created_count,\n   141→            \"active_connections\": self.active_connections,\n   142→            \"max_size\": self.max_size\n   143→        }\n   144→\n   145→\n   146→class StreamingAIProvider:\n   147→    \"\"\"AI provider that supports streaming responses.\"\"\"\n   148→    \n   149→    def __init__(self, response_delay: float = 0.1):\n   150→        self.response_delay = response_delay\n   151→        self.call_count = 0\n   152→    \n   153→    async def stream_completion(\n   154→        self, \n   155→        model_id: str, \n   156→        messages: List[Message]\n   157→    ) -> AsyncGenerator[StreamingChunk, None]:\n   158→        \"\"\"Stream chat completion chunks.\"\"\"\n   159→        self.call_count += 1\n   160→        \n   161→        # Simulate streaming response\n   162→        response_text = f\"This is a streaming response to: {messages[-1].content}\"\n   163→        words = response_text.split()\n   164→        \n   165→        for i, word in enumerate(words):\n   166→            await asyncio.sleep(self.response_delay)\n   167→            \n   168→            chunk = StreamingChunk(\n   169→                content=word + (\" \" if i < len(words) - 1 else \"\"),\n   170→                chunk_id=i,\n   171→                is_final=i == len(words) - 1,\n   172→                metadata={\n   173→                    \"model\": model_id,\n   174→                    \"total_chunks\": len(words),\n   175→                    \"call_id\": self.call_count\n   176→                }\n   177→            )\n   178→            \n   179→            yield chunk\n   180→\n   181→\n   182→class ConcurrentInferenceEngine:\n   183→    \"\"\"Engine for managing concurrent AI inference requests.\"\"\"\n   184→    \n   185→    def __init__(self, max_concurrent: int = 5):\n   186→        self.max_concurrent = max_concurrent\n   187→        self.semaphore = asyncio.Semaphore(max_concurrent)\n   188→        self.active_tasks: Dict[str, asyncio.Task] = {}\n   189→        self.completed_tasks: List[Dict[str, Any]] = []\n   190→    \n   191→    async def submit_task(\n   192→        self, \n   193→        task_id: str, \n   194→        coro: Callable,\n   195→        *args, \n   196→        **kwargs\n   197→    ) -> str:\n   198→        \"\"\"Submit a task for concurrent execution.\"\"\"\n   199→        \n   200→        async def wrapped_task():\n   201→            async with self.semaphore:\n   202→                start_time = time.time()\n   203→                try:\n   204→                    result = await coro(*args, **kwargs)\n   205→                    end_time = time.time()\n   206→                    \n   207→                    self.completed_tasks.append({\n   208→                        \"task_id\": task_id,\n   209→                        \"result\": result,\n   210→                        \"duration\": end_time - start_time,\n   211→                        \"status\": \"success\",\n   212→                        \"error\": None\n   213→                    })\n   214→                    \n   215→                    return result\n   216→                    \n   217→                except Exception as e:\n   218→                    end_time = time.time()\n   219→                    \n   220→                    self.completed_tasks.append({\n   221→                        \"task_id\": task_id,\n   222→                        \"result\": None,\n   223→                        \"duration\": end_time - start_time,\n   224→                        \"status\": \"error\",\n   225→                        \"error\": str(e)\n   226→                    })\n   227→                    \n   228→                    raise\n   229→                finally:\n   230→                    # Remove from active tasks\n   231→                    if task_id in self.active_tasks:\n   232→                        del self.active_tasks[task_id]\n   233→        \n   234→        # Create and store task\n   235→        task = asyncio.create_task(wrapped_task())\n   236→        self.active_tasks[task_id] = task\n   237→        \n   238→        return task_id\n   239→    \n   240→    async def wait_for_task(self, task_id: str) -> Any:\n   241→        \"\"\"Wait for specific task to complete.\"\"\"\n   242→        if task_id in self.active_tasks:\n   243→            return await self.active_tasks[task_id]\n   244→        \n   245→        # Check completed tasks\n   246→        for completed in self.completed_tasks:\n   247→            if completed[\"task_id\"] == task_id:\n   248→                if completed[\"status\"] == \"error\":\n   249→                    raise Exception(completed[\"error\"])\n   250→                return completed[\"result\"]\n   251→        \n   252→        raise ValueError(f\"Task {task_id} not found\")\n   253→    \n   254→    async def wait_for_all(self) -> List[Any]:\n   255→        \"\"\"Wait for all active tasks to complete.\"\"\"\n   256→        if not self.active_tasks:\n   257→            return []\n   258→        \n   259→        results = await asyncio.gather(*self.active_tasks.values(), return_exceptions=True)\n   260→        return results\n   261→    \n   262→    def get_stats(self) -> Dict[str, Any]:\n   263→        \"\"\"Get engine statistics.\"\"\"\n   264→        return {\n   265→            \"active_tasks\": len(self.active_tasks),\n   266→            \"completed_tasks\": len(self.completed_tasks),\n   267→            \"max_concurrent\": self.max_concurrent,\n   268→            \"available_slots\": self.semaphore._value\n   269→        }\n   270→\n   271→\n   272→async def async_batch_processor(\n   273→    items: List[Any], \n   274→    processor: Callable, \n   275→    batch_size: int = 10,\n   276→    max_concurrent: int = 3\n   277→) -> List[Any]:\n   278→    \"\"\"Process items in concurrent batches.\"\"\"\n   279→    \n   280→    async def process_batch(batch: List[Any]) -> List[Any]:\n   281→        \"\"\"Process a single batch.\"\"\"\n   282→        tasks = [processor(item) for item in batch]\n   283→        return await asyncio.gather(*tasks, return_exceptions=True)\n   284→    \n   285→    # Split into batches\n   286→    batches = [items[i:i + batch_size] for i in range(0, len(items), batch_size)]\n   287→    \n   288→    # Process batches concurrently\n   289→    semaphore = asyncio.Semaphore(max_concurrent)\n   290→    \n   291→    async def process_with_semaphore(batch):\n   292→        async with semaphore:\n   293→            return await process_batch(batch)\n   294→    \n   295→    batch_results = await asyncio.gather(*[\n   296→        process_with_semaphore(batch) for batch in batches\n   297→    ])\n   298→    \n   299→    # Flatten results\n   300→    results = []\n   301→    for batch_result in batch_results:\n   302→        results.extend(batch_result)\n   303→    \n   304→    return results\n   305→\n   306→\n   307→@asynccontextmanager\n   308→async def async_resource_manager(resource_factory: Callable, cleanup_func: Callable = None):\n   309→    \"\"\"Generic async context manager for resources.\"\"\"\n   310→    resource = None\n   311→    try:\n   312→        resource = await resource_factory()\n   313→        yield resource\n   314→    finally:\n   315→        if resource is not None and cleanup_func:\n   316→            await cleanup_func(resource)\n   317→\n   318→\n   319→async def demonstrate_streaming():\n   320→    \"\"\"Show streaming patterns.\"\"\"\n   321→    \n   322→    console.print(Panel(\"🌊 Streaming Patterns\", style=\"bold blue\"))\n   323→    \n   324→    provider = StreamingAIProvider(response_delay=0.2)\n   325→    \n   326→    console.print(\"[bold yellow]Streaming chat completion...[/bold yellow]\")\n   327→    \n   328→    messages = [Message(role=\"user\", content=\"Tell me about async programming\")]\n   329→    \n   330→    # Collect streaming chunks\n   331→    chunks = []\n   332→    full_response = \"\"\n   333→    \n   334→    async for chunk in provider.stream_completion(\"gpt-4\", messages):\n   335→        chunks.append(chunk)\n   336→        full_response += chunk.content\n   337→        \n   338→        # Show real-time progress\n   339→        console.print(f\"Chunk {chunk.chunk_id}: '{chunk.content.strip()}'\", end=\"\")\n   340→        if chunk.is_final:\n   341→            console.print(\" [FINAL]\")\n   342→        else:\n   343→            console.print()\n   344→    \n   345→    console.print(f\"\\n[bold cyan]Streaming Summary:[/bold cyan]\")\n   346→    console.print(f\"Total chunks: {len(chunks)}\")\n   347→    console.print(f\"Full response: {full_response}\")\n   348→    console.print(f\"Final chunk metadata: {chunks[-1].metadata}\")\n   349→\n   350→\n   351→async def demonstrate_rate_limiting():\n   352→    \"\"\"Show rate limiting patterns.\"\"\"\n   353→    \n   354→    console.print(Panel(\"🚦 Rate Limiting\", style=\"bold green\"))\n   355→    \n   356→    # Create rate limiter (5 calls per 2 seconds)\n   357→    rate_limiter = AsyncRateLimiter(max_calls=5, time_window=2.0)\n   358→    \n   359→    async def make_api_call(call_id: int) -> str:\n   360→        \"\"\"Simulate API call with rate limiting.\"\"\"\n   361→        await rate_limiter.acquire()\n   362→        # Simulate API processing time\n   363→        await asyncio.sleep(0.1)\n   364→        return f\"API call {call_id} completed\"\n   365→    \n   366→    console.print(\"[bold yellow]Making 10 rapid API calls with rate limiting...[/bold yellow]\")\n   367→    \n   368→    start_time = time.time()\n   369→    \n   370→    # Create tasks for 10 rapid calls\n   371→    tasks = [make_api_call(i) for i in range(10)]\n   372→    \n   373→    # Execute with progress tracking\n   374→    results = []\n   375→    for i, task in enumerate(asyncio.as_completed(tasks)):\n   376→        result = await task\n   377→        elapsed = time.time() - start_time\n   378→        console.print(f\"  {elapsed:.2f}s: {result}\")\n   379→        results.append(result)\n   380→    \n   381→    total_time = time.time() - start_time\n   382→    console.print(f\"\\n[bold cyan]Rate Limiting Summary:[/bold cyan]\")\n   383→    console.print(f\"Total time: {total_time:.2f}s\")\n   384→    console.print(f\"Rate limiter stats: {rate_limiter.get_stats()}\")\n   385→\n   386→\n   387→async def demonstrate_connection_pooling():\n   388→    \"\"\"Show connection pooling patterns.\"\"\"\n   389→    \n   390→    console.print(Panel(\"🏊 Connection Pooling\", style=\"bold magenta\"))\n   391→    \n   392→    async def create_mock_connection():\n   393→        \"\"\"Create a mock database connection.\"\"\"\n   394→        await asyncio.sleep(0.1)  # Simulate connection setup\n   395→        return {\"id\": id(object()), \"created_at\": time.time()}\n   396→    \n   397→    # Create connection pool\n   398→    pool = AsyncConnectionPool(create_mock_connection, max_size=3)\n   399→    \n   400→    async def database_operation(operation_id: int):\n   401→        \"\"\"Simulate database operation using connection pool.\"\"\"\n   402→        async with pool.connection() as conn:\n   403→            # Simulate work\n   404→            await asyncio.sleep(0.2)\n   405→            return f\"Operation {operation_id} completed with connection {conn['id']}\"\n   406→    \n   407→    console.print(\"[bold yellow]Running concurrent database operations...[/bold yellow]\")\n   408→    \n   409→    # Run 8 concurrent operations with pool of 3 connections\n   410→    start_time = time.time()\n   411→    \n   412→    tasks = [database_operation(i) for i in range(8)]\n   413→    results = []\n   414→    \n   415→    for task in asyncio.as_completed(tasks):\n   416→        result = await task\n   417→        elapsed = time.time() - start_time\n   418→        stats = pool.get_stats()\n   419→        console.print(f\"  {elapsed:.2f}s: {result}\")\n   420→        console.print(f\"    Pool stats: {stats}\")\n   421→    \n   422→    final_stats = pool.get_stats()\n   423→    console.print(f\"\\n[bold cyan]Final Pool Stats:[/bold cyan]\")\n   424→    console.print(f\"Created connections: {final_stats['created_count']}\")\n   425→    console.print(f\"Active connections: {final_stats['active_connections']}\")\n   426→\n   427→\n   428→async def demonstrate_concurrent_processing():\n   429→    \"\"\"Show concurrent processing patterns.\"\"\"\n   430→    \n   431→    console.print(Panel(\"⚡ Concurrent Processing\", style=\"bold cyan\"))\n   432→    \n   433→    # Create inference engine\n   434→    engine = ConcurrentInferenceEngine(max_concurrent=3)\n   435→    \n   436→    async def mock_inference(text: str, delay: float = 0.5) -> str:\n   437→        \"\"\"Mock AI inference with variable delay.\"\"\"\n   438→        await asyncio.sleep(delay)\n   439→        return f\"Processed: {text}\"\n   440→    \n   441→    console.print(\"[bold yellow]Submitting concurrent inference tasks...[/bold yellow]\")\n   442→    \n   443→    # Submit multiple tasks\n   444→    tasks_data = [\n   445→        (\"task_1\", \"Analyze sentiment\", 0.3),\n   446→        (\"task_2\", \"Summarize document\", 0.8),\n   447→        (\"task_3\", \"Extract entities\", 0.5),\n   448→        (\"task_4\", \"Classify text\", 0.4),\n   449→        (\"task_5\", \"Generate response\", 0.6)\n   450→    ]\n   451→    \n   452→    submitted_tasks = []\n   453→    for task_id, text, delay in tasks_data:\n   454→        await engine.submit_task(task_id, mock_inference, text, delay)\n   455→        submitted_tasks.append(task_id)\n   456→        console.print(f\"  Submitted: {task_id}\")\n   457→    \n   458→    # Wait for all tasks and show progress\n   459→    console.print(f\"\\n[bold yellow]Waiting for tasks to complete...[/bold yellow]\")\n   460→    \n   461→    while engine.active_tasks:\n   462→        stats = engine.get_stats()\n   463→        console.print(f\"  Active: {stats['active_tasks']}, Completed: {stats['completed_tasks']}\")\n   464→        await asyncio.sleep(0.2)\n   465→    \n   466→    # Show final results\n   467→    console.print(f\"\\n[bold cyan]Task Results:[/bold cyan]\")\n   468→    for completed in engine.completed_tasks:\n   469→        status_icon = \"✅\" if completed[\"status\"] == \"success\" else \"❌\"\n   470→        console.print(f\"  {status_icon} {completed['task_id']}: {completed['duration']:.2f}s\")\n   471→\n   472→\n   473→async def demonstrate_batch_processing():\n   474→    \"\"\"Show batch processing patterns.\"\"\"\n   475→    \n   476→    console.print(Panel(\"📦 Batch Processing\", style=\"bold red\"))\n   477→    \n   478→    async def process_text(text: str) -> str:\n   479→        \"\"\"Process a single text item.\"\"\"\n   480→        await asyncio.sleep(0.1)  # Simulate processing\n   481→        return f\"PROCESSED: {text.upper()}\"\n   482→    \n   483→    # Create test data\n   484→    texts = [f\"text item {i}\" for i in range(25)]\n   485→    \n   486→    console.print(f\"[bold yellow]Processing {len(texts)} items in batches...[/bold yellow]\")\n   487→    \n   488→    start_time = time.time()\n   489→    \n   490→    # Process in batches with concurrency\n   491→    results = await async_batch_processor(\n   492→        items=texts,\n   493→        processor=process_text,\n   494→        batch_size=5,\n   495→        max_concurrent=3\n   496→    )\n   497→    \n   498→    processing_time = time.time() - start_time\n   499→    \n   500→    console.print(f\"\\n[bold cyan]Batch Processing Results:[/bold cyan]\")\n   501→    console.print(f\"Total items: {len(texts)}\")\n   502→    console.print(f\"Processing time: {processing_time:.2f}s\")\n   503→    console.print(f\"Items per second: {len(texts) / processing_time:.1f}\")\n   504→    console.print(f\"Sample results: {results[:3]}...\")\n   505→    \n   506→    # Count errors\n   507→    errors = [r for r in results if isinstance(r, Exception)]\n   508→    console.print(f\"Errors: {len(errors)}\")\n   509→\n   510→\n   511→async def demonstrate_async_context_managers():\n   512→    \"\"\"Show async context manager patterns.\"\"\"\n   513→    \n   514→    console.print(Panel(\"🔒 Async Context Managers\", style=\"bold yellow\"))\n   515→    \n   516→    async def create_ai_session():\n   517→        \"\"\"Create an AI session with setup/teardown.\"\"\"\n   518→        console.print(\"  🚀 Creating AI session...\")\n   519→        await asyncio.sleep(0.1)\n   520→        session = {\n   521→            \"id\": \"session_\" + str(int(time.time())),\n   522→            \"created_at\": time.time(),\n   523→            \"request_count\": 0\n   524→        }\n   525→        return session\n   526→    \n   527→    async def cleanup_session(session):\n   528→        \"\"\"Clean up AI session.\"\"\"\n   529→        console.print(f\"  🧹 Cleaning up session {session['id']} ({session['request_count']} requests)\")\n   530→        await asyncio.sleep(0.05)\n   531→    \n   532→    console.print(\"[bold yellow]Using async context manager for AI sessions...[/bold yellow]\")\n   533→    \n   534→    # Use the async context manager\n   535→    async with async_resource_manager(create_ai_session, cleanup_session) as session:\n   536→        console.print(f\"  📝 Session active: {session['id']}\")\n   537→        \n   538→        # Simulate some work\n   539→        for i in range(3):\n   540→            await asyncio.sleep(0.1)\n   541→            session[\"request_count\"] += 1\n   542→            console.print(f\"    Request {session['request_count']} processed\")\n   543→    \n   544→    console.print(\"  ✅ Session context manager completed\")\n   545→\n   546→\n   547→async def demonstrate_async_generators():\n   548→    \"\"\"Show async generator patterns.\"\"\"\n   549→    \n   550→    console.print(Panel(\"🔄 Async Generators\", style=\"bold purple\"))\n   551→    \n   552→    async def generate_predictions(texts: List[str]) -> AsyncGenerator[Dict[str, Any], None]:\n   553→        \"\"\"Generate predictions one by one.\"\"\"\n   554→        for i, text in enumerate(texts):\n   555→            # Simulate prediction time\n   556→            await asyncio.sleep(0.2)\n   557→            \n   558→            yield {\n   559→                \"text\": text,\n   560→                \"prediction\": f\"prediction_{i}\",\n   561→                \"confidence\": 0.9 - (i * 0.1),\n   562→                \"processing_time\": 0.2,\n   563→                \"batch_id\": i // 3  # Group into batches of 3\n   564→            }\n   565→    \n   566→    console.print(\"[bold yellow]Streaming predictions with async generator...[/bold yellow]\")\n   567→    \n   568→    test_texts = [f\"input text {i}\" for i in range(7)]\n   569→    \n   570→    predictions_by_batch = {}\n   571→    \n   572→    async for prediction in generate_predictions(test_texts):\n   573→        batch_id = prediction[\"batch_id\"]\n   574→        if batch_id not in predictions_by_batch:\n   575→            predictions_by_batch[batch_id] = []\n   576→        \n   577→        predictions_by_batch[batch_id].append(prediction)\n   578→        \n   579→        console.print(f\"  📊 Prediction {len(predictions_by_batch[batch_id])} for batch {batch_id}: \"\n   580→                     f\"{prediction['prediction']} (confidence: {prediction['confidence']:.2f})\")\n   581→    \n   582→    console.print(f\"\\n[bold cyan]Generated {sum(len(preds) for preds in predictions_by_batch.values())} predictions in {len(predictions_by_batch)} batches[/bold cyan]\")\n   583→\n   584→\n   585→def interactive_exercise():\n   586→    \"\"\"Interactive exercise for async patterns.\"\"\"\n   587→    \n   588→    console.print(Panel(\"🎮 Interactive Exercise: Design Your Async Architecture\", style=\"bold magenta\"))\n   589→    \n   590→    scenarios = [\n   591→        {\n   592→            \"system\": \"Real-time AI Chat Service\",\n   593→            \"requirements\": [\n   594→                \"Handle 1000+ concurrent users\",\n   595→                \"Stream responses in real-time\",\n   596→                \"Rate limit per user and globally\",\n   597→                \"Graceful handling of AI model failures\"\n   598→            ],\n   599→            \"challenge\": \"Design the async architecture\"\n   600→        },\n   601→        {\n   602→            \"system\": \"Batch Document Processing\",\n   603→            \"requirements\": [\n   604→                \"Process thousands of documents daily\",\n   605→                \"Multiple AI models per document\",\n   606→                \"Prioritize urgent documents\",\n   607→                \"Monitor progress and handle failures\"\n   608→            ],\n   609→            \"challenge\": \"Design concurrent processing strategy\"\n   610→        },\n   611→        {\n   612→            \"system\": \"Multi-Model AI Inference API\",\n   613→            \"requirements\": [\n   614→                \"Support multiple AI providers\",\n   615→                \"Connection pooling for efficiency\",\n   616→                \"Fallback between providers\",\n   617→                \"Streaming and batch modes\"\n   618→            ],\n   619→            \"challenge\": \"Design resource management patterns\"\n   620→        }\n   621→    ]\n   622→    \n   623→    for i, scenario in enumerate(scenarios, 1):\n   624→        console.print(f\"\\n[bold cyan]Scenario {i}: {scenario['system']}[/bold cyan]\")\n   625→        console.print(\"[bold yellow]Requirements:[/bold yellow]\")\n   626→        for req in scenario[\"requirements\"]:\n   627→            console.print(f\"  • {req}\")\n   628→        console.print(f\"\\n[bold yellow]Challenge: {scenario['challenge']}[/bold yellow]\")\n   629→        console.print(\"\\n[bold green]Consider These Patterns:[/bold green]\")\n   630→        console.print(\"  • Streaming with AsyncGenerators\")\n   631→        console.print(\"  • Rate limiting with semaphores\")\n   632→        console.print(\"  • Connection pooling for resources\")\n   633→        console.print(\"  • Concurrent processing with task management\")\n   634→        console.print(\"  • Async context managers for cleanup\")\n   635→        console.print(\"  • Batch processing for efficiency\")\n   636→        console.print(\"---\")\n   637→\n   638→\n   639→if __name__ == \"__main__\":\n   640→    console.print(\"[bold blue]🚀 AI Architecture Patterns: Async Patterns[/bold blue]\")\n   641→    console.print(\"Learn to build high-performance async AI systems\\n\")\n   642→    \n   643→    async def main():\n   644→        await demonstrate_streaming()\n   645→        console.print(\"\\n\" + \"=\"*60)\n   646→        \n   647→        await demonstrate_rate_limiting()\n   648→        console.print(\"\\n\" + \"=\"*60)\n   649→        \n   650→        await demonstrate_connection_pooling()\n   651→        console.print(\"\\n\" + \"=\"*60)\n   652→        \n   653→        await demonstrate_concurrent_processing()\n   654→        console.print(\"\\n\" + \"=\"*60)\n   655→        \n   656→        await demonstrate_batch_processing()\n   657→        console.print(\"\\n\" + \"=\"*60)\n   658→        \n   659→        await demonstrate_async_context_managers()\n   660→        console.print(\"\\n\" + \"=\"*60)\n   661→        \n   662→        await demonstrate_async_generators()\n   663→        console.print(\"\\n\" + \"=\"*60)\n   664→        \n   665→        interactive_exercise()\n   666→        \n   667→        console.print(f\"\\n[bold green]✅ Completed![/bold green] Next: Run example 03_functional_programming.py\")\n   668→        console.print(\"💡 Pro tip: Async patterns are crucial for scalable AI systems!\")\n   669→    \n   670→    asyncio.run(main())\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"66cecd32-01da-4ae6-bc89-f6bbc4c8f1d9","timestamp":"2025-08-01T17:59:45.290Z","toolUseResult":{"type":"text","file":{"filePath":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/examples/02_async_patterns.py","content":"#!/usr/bin/env python3\n\"\"\"\nExample 2: Async Patterns for AI Systems\n\nLearn advanced asyncio patterns for building high-performance\nAI systems with concurrent processing, streaming, and resource management.\n\nRun this file to see the examples in action:\n    python 03-python-idioms/examples/02_async_patterns.py\n\"\"\"\n\nimport sys\nimport os\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))\n\nimport asyncio\nfrom typing import AsyncGenerator, AsyncIterator, Callable, Any, Optional, List, Dict\nfrom dataclasses import dataclass\nfrom contextlib import asynccontextmanager\nimport time\nfrom rich.console import Console\nfrom rich.panel import Panel\nfrom rich.table import Table\nfrom rich.live import Live\nfrom rich.progress import Progress, TaskID\n\nfrom common import Message, ChatResponse, Choice\n\nconsole = Console()\n\n\n# 🎯 LEARNING GOAL: Master async patterns for high-performance AI systems\n\n\n@dataclass\nclass StreamingChunk:\n    \"\"\"Represents a chunk of streaming data.\"\"\"\n    content: str\n    chunk_id: int\n    is_final: bool\n    metadata: Dict[str, Any] = None\n    \n    def __post_init__(self):\n        if self.metadata is None:\n            self.metadata = {}\n\n\nclass AsyncRateLimiter:\n    \"\"\"Async rate limiter for API calls.\"\"\"\n    \n    def __init__(self, max_calls: int, time_window: float):\n        self.max_calls = max_calls\n        self.time_window = time_window\n        self.calls: List[float] = []\n        self._lock = asyncio.Lock()\n    \n    async def acquire(self) -> None:\n        \"\"\"Acquire permission to make a call.\"\"\"\n        async with self._lock:\n            now = time.time()\n            \n            # Remove old calls outside the window\n            self.calls = [call_time for call_time in self.calls \n                         if now - call_time < self.time_window]\n            \n            # If we're at the limit, wait\n            if len(self.calls) >= self.max_calls:\n                oldest_call = min(self.calls)\n                wait_time = self.time_window - (now - oldest_call)\n                if wait_time > 0:\n                    await asyncio.sleep(wait_time)\n                    # Recursive call to try again\n                    return await self.acquire()\n            \n            # Record this call\n            self.calls.append(now)\n    \n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"Get rate limiter statistics.\"\"\"\n        now = time.time()\n        recent_calls = [call for call in self.calls if now - call < self.time_window]\n        return {\n            \"current_calls\": len(recent_calls),\n            \"max_calls\": self.max_calls,\n            \"time_window\": self.time_window,\n            \"utilization\": len(recent_calls) / self.max_calls\n        }\n\n\nclass AsyncConnectionPool:\n    \"\"\"Connection pool for managing async resources.\"\"\"\n    \n    def __init__(self, create_connection: Callable, max_size: int = 10):\n        self.create_connection = create_connection\n        self.max_size = max_size\n        self.pool: asyncio.Queue = asyncio.Queue(maxsize=max_size)\n        self.created_count = 0\n        self.active_connections = 0\n        self._lock = asyncio.Lock()\n    \n    async def get_connection(self):\n        \"\"\"Get a connection from the pool.\"\"\"\n        try:\n            # Try to get existing connection with timeout\n            connection = await asyncio.wait_for(self.pool.get(), timeout=0.1)\n            self.active_connections += 1\n            return connection\n        except asyncio.TimeoutError:\n            # Create new connection if under limit\n            async with self._lock:\n                if self.created_count < self.max_size:\n                    connection = await self.create_connection()\n                    self.created_count += 1\n                    self.active_connections += 1\n                    return connection\n            \n            # Wait for available connection\n            connection = await self.pool.get()\n            self.active_connections += 1\n            return connection\n    \n    async def return_connection(self, connection):\n        \"\"\"Return connection to pool.\"\"\"\n        self.active_connections -= 1\n        await self.pool.put(connection)\n    \n    @asynccontextmanager\n    async def connection(self):\n        \"\"\"Context manager for automatic connection management.\"\"\"\n        conn = await self.get_connection()\n        try:\n            yield conn\n        finally:\n            await self.return_connection(conn)\n    \n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"Get pool statistics.\"\"\"\n        return {\n            \"pool_size\": self.pool.qsize(),\n            \"created_count\": self.created_count,\n            \"active_connections\": self.active_connections,\n            \"max_size\": self.max_size\n        }\n\n\nclass StreamingAIProvider:\n    \"\"\"AI provider that supports streaming responses.\"\"\"\n    \n    def __init__(self, response_delay: float = 0.1):\n        self.response_delay = response_delay\n        self.call_count = 0\n    \n    async def stream_completion(\n        self, \n        model_id: str, \n        messages: List[Message]\n    ) -> AsyncGenerator[StreamingChunk, None]:\n        \"\"\"Stream chat completion chunks.\"\"\"\n        self.call_count += 1\n        \n        # Simulate streaming response\n        response_text = f\"This is a streaming response to: {messages[-1].content}\"\n        words = response_text.split()\n        \n        for i, word in enumerate(words):\n            await asyncio.sleep(self.response_delay)\n            \n            chunk = StreamingChunk(\n                content=word + (\" \" if i < len(words) - 1 else \"\"),\n                chunk_id=i,\n                is_final=i == len(words) - 1,\n                metadata={\n                    \"model\": model_id,\n                    \"total_chunks\": len(words),\n                    \"call_id\": self.call_count\n                }\n            )\n            \n            yield chunk\n\n\nclass ConcurrentInferenceEngine:\n    \"\"\"Engine for managing concurrent AI inference requests.\"\"\"\n    \n    def __init__(self, max_concurrent: int = 5):\n        self.max_concurrent = max_concurrent\n        self.semaphore = asyncio.Semaphore(max_concurrent)\n        self.active_tasks: Dict[str, asyncio.Task] = {}\n        self.completed_tasks: List[Dict[str, Any]] = []\n    \n    async def submit_task(\n        self, \n        task_id: str, \n        coro: Callable,\n        *args, \n        **kwargs\n    ) -> str:\n        \"\"\"Submit a task for concurrent execution.\"\"\"\n        \n        async def wrapped_task():\n            async with self.semaphore:\n                start_time = time.time()\n                try:\n                    result = await coro(*args, **kwargs)\n                    end_time = time.time()\n                    \n                    self.completed_tasks.append({\n                        \"task_id\": task_id,\n                        \"result\": result,\n                        \"duration\": end_time - start_time,\n                        \"status\": \"success\",\n                        \"error\": None\n                    })\n                    \n                    return result\n                    \n                except Exception as e:\n                    end_time = time.time()\n                    \n                    self.completed_tasks.append({\n                        \"task_id\": task_id,\n                        \"result\": None,\n                        \"duration\": end_time - start_time,\n                        \"status\": \"error\",\n                        \"error\": str(e)\n                    })\n                    \n                    raise\n                finally:\n                    # Remove from active tasks\n                    if task_id in self.active_tasks:\n                        del self.active_tasks[task_id]\n        \n        # Create and store task\n        task = asyncio.create_task(wrapped_task())\n        self.active_tasks[task_id] = task\n        \n        return task_id\n    \n    async def wait_for_task(self, task_id: str) -> Any:\n        \"\"\"Wait for specific task to complete.\"\"\"\n        if task_id in self.active_tasks:\n            return await self.active_tasks[task_id]\n        \n        # Check completed tasks\n        for completed in self.completed_tasks:\n            if completed[\"task_id\"] == task_id:\n                if completed[\"status\"] == \"error\":\n                    raise Exception(completed[\"error\"])\n                return completed[\"result\"]\n        \n        raise ValueError(f\"Task {task_id} not found\")\n    \n    async def wait_for_all(self) -> List[Any]:\n        \"\"\"Wait for all active tasks to complete.\"\"\"\n        if not self.active_tasks:\n            return []\n        \n        results = await asyncio.gather(*self.active_tasks.values(), return_exceptions=True)\n        return results\n    \n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"Get engine statistics.\"\"\"\n        return {\n            \"active_tasks\": len(self.active_tasks),\n            \"completed_tasks\": len(self.completed_tasks),\n            \"max_concurrent\": self.max_concurrent,\n            \"available_slots\": self.semaphore._value\n        }\n\n\nasync def async_batch_processor(\n    items: List[Any], \n    processor: Callable, \n    batch_size: int = 10,\n    max_concurrent: int = 3\n) -> List[Any]:\n    \"\"\"Process items in concurrent batches.\"\"\"\n    \n    async def process_batch(batch: List[Any]) -> List[Any]:\n        \"\"\"Process a single batch.\"\"\"\n        tasks = [processor(item) for item in batch]\n        return await asyncio.gather(*tasks, return_exceptions=True)\n    \n    # Split into batches\n    batches = [items[i:i + batch_size] for i in range(0, len(items), batch_size)]\n    \n    # Process batches concurrently\n    semaphore = asyncio.Semaphore(max_concurrent)\n    \n    async def process_with_semaphore(batch):\n        async with semaphore:\n            return await process_batch(batch)\n    \n    batch_results = await asyncio.gather(*[\n        process_with_semaphore(batch) for batch in batches\n    ])\n    \n    # Flatten results\n    results = []\n    for batch_result in batch_results:\n        results.extend(batch_result)\n    \n    return results\n\n\n@asynccontextmanager\nasync def async_resource_manager(resource_factory: Callable, cleanup_func: Callable = None):\n    \"\"\"Generic async context manager for resources.\"\"\"\n    resource = None\n    try:\n        resource = await resource_factory()\n        yield resource\n    finally:\n        if resource is not None and cleanup_func:\n            await cleanup_func(resource)\n\n\nasync def demonstrate_streaming():\n    \"\"\"Show streaming patterns.\"\"\"\n    \n    console.print(Panel(\"🌊 Streaming Patterns\", style=\"bold blue\"))\n    \n    provider = StreamingAIProvider(response_delay=0.2)\n    \n    console.print(\"[bold yellow]Streaming chat completion...[/bold yellow]\")\n    \n    messages = [Message(role=\"user\", content=\"Tell me about async programming\")]\n    \n    # Collect streaming chunks\n    chunks = []\n    full_response = \"\"\n    \n    async for chunk in provider.stream_completion(\"gpt-4\", messages):\n        chunks.append(chunk)\n        full_response += chunk.content\n        \n        # Show real-time progress\n        console.print(f\"Chunk {chunk.chunk_id}: '{chunk.content.strip()}'\", end=\"\")\n        if chunk.is_final:\n            console.print(\" [FINAL]\")\n        else:\n            console.print()\n    \n    console.print(f\"\\n[bold cyan]Streaming Summary:[/bold cyan]\")\n    console.print(f\"Total chunks: {len(chunks)}\")\n    console.print(f\"Full response: {full_response}\")\n    console.print(f\"Final chunk metadata: {chunks[-1].metadata}\")\n\n\nasync def demonstrate_rate_limiting():\n    \"\"\"Show rate limiting patterns.\"\"\"\n    \n    console.print(Panel(\"🚦 Rate Limiting\", style=\"bold green\"))\n    \n    # Create rate limiter (5 calls per 2 seconds)\n    rate_limiter = AsyncRateLimiter(max_calls=5, time_window=2.0)\n    \n    async def make_api_call(call_id: int) -> str:\n        \"\"\"Simulate API call with rate limiting.\"\"\"\n        await rate_limiter.acquire()\n        # Simulate API processing time\n        await asyncio.sleep(0.1)\n        return f\"API call {call_id} completed\"\n    \n    console.print(\"[bold yellow]Making 10 rapid API calls with rate limiting...[/bold yellow]\")\n    \n    start_time = time.time()\n    \n    # Create tasks for 10 rapid calls\n    tasks = [make_api_call(i) for i in range(10)]\n    \n    # Execute with progress tracking\n    results = []\n    for i, task in enumerate(asyncio.as_completed(tasks)):\n        result = await task\n        elapsed = time.time() - start_time\n        console.print(f\"  {elapsed:.2f}s: {result}\")\n        results.append(result)\n    \n    total_time = time.time() - start_time\n    console.print(f\"\\n[bold cyan]Rate Limiting Summary:[/bold cyan]\")\n    console.print(f\"Total time: {total_time:.2f}s\")\n    console.print(f\"Rate limiter stats: {rate_limiter.get_stats()}\")\n\n\nasync def demonstrate_connection_pooling():\n    \"\"\"Show connection pooling patterns.\"\"\"\n    \n    console.print(Panel(\"🏊 Connection Pooling\", style=\"bold magenta\"))\n    \n    async def create_mock_connection():\n        \"\"\"Create a mock database connection.\"\"\"\n        await asyncio.sleep(0.1)  # Simulate connection setup\n        return {\"id\": id(object()), \"created_at\": time.time()}\n    \n    # Create connection pool\n    pool = AsyncConnectionPool(create_mock_connection, max_size=3)\n    \n    async def database_operation(operation_id: int):\n        \"\"\"Simulate database operation using connection pool.\"\"\"\n        async with pool.connection() as conn:\n            # Simulate work\n            await asyncio.sleep(0.2)\n            return f\"Operation {operation_id} completed with connection {conn['id']}\"\n    \n    console.print(\"[bold yellow]Running concurrent database operations...[/bold yellow]\")\n    \n    # Run 8 concurrent operations with pool of 3 connections\n    start_time = time.time()\n    \n    tasks = [database_operation(i) for i in range(8)]\n    results = []\n    \n    for task in asyncio.as_completed(tasks):\n        result = await task\n        elapsed = time.time() - start_time\n        stats = pool.get_stats()\n        console.print(f\"  {elapsed:.2f}s: {result}\")\n        console.print(f\"    Pool stats: {stats}\")\n    \n    final_stats = pool.get_stats()\n    console.print(f\"\\n[bold cyan]Final Pool Stats:[/bold cyan]\")\n    console.print(f\"Created connections: {final_stats['created_count']}\")\n    console.print(f\"Active connections: {final_stats['active_connections']}\")\n\n\nasync def demonstrate_concurrent_processing():\n    \"\"\"Show concurrent processing patterns.\"\"\"\n    \n    console.print(Panel(\"⚡ Concurrent Processing\", style=\"bold cyan\"))\n    \n    # Create inference engine\n    engine = ConcurrentInferenceEngine(max_concurrent=3)\n    \n    async def mock_inference(text: str, delay: float = 0.5) -> str:\n        \"\"\"Mock AI inference with variable delay.\"\"\"\n        await asyncio.sleep(delay)\n        return f\"Processed: {text}\"\n    \n    console.print(\"[bold yellow]Submitting concurrent inference tasks...[/bold yellow]\")\n    \n    # Submit multiple tasks\n    tasks_data = [\n        (\"task_1\", \"Analyze sentiment\", 0.3),\n        (\"task_2\", \"Summarize document\", 0.8),\n        (\"task_3\", \"Extract entities\", 0.5),\n        (\"task_4\", \"Classify text\", 0.4),\n        (\"task_5\", \"Generate response\", 0.6)\n    ]\n    \n    submitted_tasks = []\n    for task_id, text, delay in tasks_data:\n        await engine.submit_task(task_id, mock_inference, text, delay)\n        submitted_tasks.append(task_id)\n        console.print(f\"  Submitted: {task_id}\")\n    \n    # Wait for all tasks and show progress\n    console.print(f\"\\n[bold yellow]Waiting for tasks to complete...[/bold yellow]\")\n    \n    while engine.active_tasks:\n        stats = engine.get_stats()\n        console.print(f\"  Active: {stats['active_tasks']}, Completed: {stats['completed_tasks']}\")\n        await asyncio.sleep(0.2)\n    \n    # Show final results\n    console.print(f\"\\n[bold cyan]Task Results:[/bold cyan]\")\n    for completed in engine.completed_tasks:\n        status_icon = \"✅\" if completed[\"status\"] == \"success\" else \"❌\"\n        console.print(f\"  {status_icon} {completed['task_id']}: {completed['duration']:.2f}s\")\n\n\nasync def demonstrate_batch_processing():\n    \"\"\"Show batch processing patterns.\"\"\"\n    \n    console.print(Panel(\"📦 Batch Processing\", style=\"bold red\"))\n    \n    async def process_text(text: str) -> str:\n        \"\"\"Process a single text item.\"\"\"\n        await asyncio.sleep(0.1)  # Simulate processing\n        return f\"PROCESSED: {text.upper()}\"\n    \n    # Create test data\n    texts = [f\"text item {i}\" for i in range(25)]\n    \n    console.print(f\"[bold yellow]Processing {len(texts)} items in batches...[/bold yellow]\")\n    \n    start_time = time.time()\n    \n    # Process in batches with concurrency\n    results = await async_batch_processor(\n        items=texts,\n        processor=process_text,\n        batch_size=5,\n        max_concurrent=3\n    )\n    \n    processing_time = time.time() - start_time\n    \n    console.print(f\"\\n[bold cyan]Batch Processing Results:[/bold cyan]\")\n    console.print(f\"Total items: {len(texts)}\")\n    console.print(f\"Processing time: {processing_time:.2f}s\")\n    console.print(f\"Items per second: {len(texts) / processing_time:.1f}\")\n    console.print(f\"Sample results: {results[:3]}...\")\n    \n    # Count errors\n    errors = [r for r in results if isinstance(r, Exception)]\n    console.print(f\"Errors: {len(errors)}\")\n\n\nasync def demonstrate_async_context_managers():\n    \"\"\"Show async context manager patterns.\"\"\"\n    \n    console.print(Panel(\"🔒 Async Context Managers\", style=\"bold yellow\"))\n    \n    async def create_ai_session():\n        \"\"\"Create an AI session with setup/teardown.\"\"\"\n        console.print(\"  🚀 Creating AI session...\")\n        await asyncio.sleep(0.1)\n        session = {\n            \"id\": \"session_\" + str(int(time.time())),\n            \"created_at\": time.time(),\n            \"request_count\": 0\n        }\n        return session\n    \n    async def cleanup_session(session):\n        \"\"\"Clean up AI session.\"\"\"\n        console.print(f\"  🧹 Cleaning up session {session['id']} ({session['request_count']} requests)\")\n        await asyncio.sleep(0.05)\n    \n    console.print(\"[bold yellow]Using async context manager for AI sessions...[/bold yellow]\")\n    \n    # Use the async context manager\n    async with async_resource_manager(create_ai_session, cleanup_session) as session:\n        console.print(f\"  📝 Session active: {session['id']}\")\n        \n        # Simulate some work\n        for i in range(3):\n            await asyncio.sleep(0.1)\n            session[\"request_count\"] += 1\n            console.print(f\"    Request {session['request_count']} processed\")\n    \n    console.print(\"  ✅ Session context manager completed\")\n\n\nasync def demonstrate_async_generators():\n    \"\"\"Show async generator patterns.\"\"\"\n    \n    console.print(Panel(\"🔄 Async Generators\", style=\"bold purple\"))\n    \n    async def generate_predictions(texts: List[str]) -> AsyncGenerator[Dict[str, Any], None]:\n        \"\"\"Generate predictions one by one.\"\"\"\n        for i, text in enumerate(texts):\n            # Simulate prediction time\n            await asyncio.sleep(0.2)\n            \n            yield {\n                \"text\": text,\n                \"prediction\": f\"prediction_{i}\",\n                \"confidence\": 0.9 - (i * 0.1),\n                \"processing_time\": 0.2,\n                \"batch_id\": i // 3  # Group into batches of 3\n            }\n    \n    console.print(\"[bold yellow]Streaming predictions with async generator...[/bold yellow]\")\n    \n    test_texts = [f\"input text {i}\" for i in range(7)]\n    \n    predictions_by_batch = {}\n    \n    async for prediction in generate_predictions(test_texts):\n        batch_id = prediction[\"batch_id\"]\n        if batch_id not in predictions_by_batch:\n            predictions_by_batch[batch_id] = []\n        \n        predictions_by_batch[batch_id].append(prediction)\n        \n        console.print(f\"  📊 Prediction {len(predictions_by_batch[batch_id])} for batch {batch_id}: \"\n                     f\"{prediction['prediction']} (confidence: {prediction['confidence']:.2f})\")\n    \n    console.print(f\"\\n[bold cyan]Generated {sum(len(preds) for preds in predictions_by_batch.values())} predictions in {len(predictions_by_batch)} batches[/bold cyan]\")\n\n\ndef interactive_exercise():\n    \"\"\"Interactive exercise for async patterns.\"\"\"\n    \n    console.print(Panel(\"🎮 Interactive Exercise: Design Your Async Architecture\", style=\"bold magenta\"))\n    \n    scenarios = [\n        {\n            \"system\": \"Real-time AI Chat Service\",\n            \"requirements\": [\n                \"Handle 1000+ concurrent users\",\n                \"Stream responses in real-time\",\n                \"Rate limit per user and globally\",\n                \"Graceful handling of AI model failures\"\n            ],\n            \"challenge\": \"Design the async architecture\"\n        },\n        {\n            \"system\": \"Batch Document Processing\",\n            \"requirements\": [\n                \"Process thousands of documents daily\",\n                \"Multiple AI models per document\",\n                \"Prioritize urgent documents\",\n                \"Monitor progress and handle failures\"\n            ],\n            \"challenge\": \"Design concurrent processing strategy\"\n        },\n        {\n            \"system\": \"Multi-Model AI Inference API\",\n            \"requirements\": [\n                \"Support multiple AI providers\",\n                \"Connection pooling for efficiency\",\n                \"Fallback between providers\",\n                \"Streaming and batch modes\"\n            ],\n            \"challenge\": \"Design resource management patterns\"\n        }\n    ]\n    \n    for i, scenario in enumerate(scenarios, 1):\n        console.print(f\"\\n[bold cyan]Scenario {i}: {scenario['system']}[/bold cyan]\")\n        console.print(\"[bold yellow]Requirements:[/bold yellow]\")\n        for req in scenario[\"requirements\"]:\n            console.print(f\"  • {req}\")\n        console.print(f\"\\n[bold yellow]Challenge: {scenario['challenge']}[/bold yellow]\")\n        console.print(\"\\n[bold green]Consider These Patterns:[/bold green]\")\n        console.print(\"  • Streaming with AsyncGenerators\")\n        console.print(\"  • Rate limiting with semaphores\")\n        console.print(\"  • Connection pooling for resources\")\n        console.print(\"  • Concurrent processing with task management\")\n        console.print(\"  • Async context managers for cleanup\")\n        console.print(\"  • Batch processing for efficiency\")\n        console.print(\"---\")\n\n\nif __name__ == \"__main__\":\n    console.print(\"[bold blue]🚀 AI Architecture Patterns: Async Patterns[/bold blue]\")\n    console.print(\"Learn to build high-performance async AI systems\\n\")\n    \n    async def main():\n        await demonstrate_streaming()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_rate_limiting()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_connection_pooling()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_concurrent_processing()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_batch_processing()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_async_context_managers()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_async_generators()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        interactive_exercise()\n        \n        console.print(f\"\\n[bold green]✅ Completed![/bold green] Next: Run example 03_functional_programming.py\")\n        console.print(\"💡 Pro tip: Async patterns are crucial for scalable AI systems!\")\n    \n    asyncio.run(main())","numLines":670,"startLine":1,"totalLines":670}}}
{"parentUuid":"66cecd32-01da-4ae6-bc89-f6bbc4c8f1d9","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File does not exist.","is_error":true,"tool_use_id":"toolu_vrtx_011fS3161tFmRKbYSGG5Pi8z"}]},"uuid":"d1f14c87-c7d5-4c9b-a7cb-43be481fb1c2","timestamp":"2025-08-01T17:59:45.284Z","toolUseResult":"Error: File does not exist."}
{"parentUuid":"d1f14c87-c7d5-4c9b-a7cb-43be481fb1c2","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_vrtx_01Fg17WrVamtfpEj1VED6Vgr","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→\"\"\"\n     3→Example 5: Performance Optimization for AI Systems\n     4→\n     5→Learn performance optimization techniques for AI applications including\n     6→profiling, memory management, vectorization, and parallel processing.\n     7→\n     8→Run this file to see the examples in action:\n     9→    python 03-python-idioms/examples/05_performance_optimization.py\n    10→\"\"\"\n    11→\n    12→import sys\n    13→import os\n    14→sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))\n    15→\n    16→import time\n    17→import gc\n    18→import weakref\n    19→import threading\n    20→import multiprocessing as mp\n    21→from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, as_completed\n    22→from typing import List, Dict, Any, Callable, Iterator, Optional, Tuple\n    23→from dataclasses import dataclass\n    24→from functools import lru_cache, partial\n    25→import cProfile\n    26→import pstats\n    27→import tracemalloc\n    28→from contextlib import contextmanager\n    29→from collections import deque, defaultdict\n    30→import numpy as np\n    31→from rich.console import Console\n    32→from rich.panel import Panel\n    33→from rich.table import Table\n    34→from rich.progress import Progress, TaskID\n    35→\n    36→console = Console()\n    37→\n    38→# 🎯 LEARNING GOAL: Master performance optimization for AI systems\n    39→\n    40→\n    41→# Memory-Efficient Data Structures\n    42→class MemoryEfficientCache:\n    43→    \"\"\"Memory-efficient LRU cache with size limits.\"\"\"\n    44→    \n    45→    def __init__(self, max_size: int = 1000, max_memory_mb: float = 100.0):\n    46→        self.max_size = max_size\n    47→        self.max_memory_bytes = max_memory_mb * 1024 * 1024\n    48→        self.cache = {}\n    49→        self.access_order = deque()\n    50→        self.current_memory = 0\n    51→    \n    52→    def _estimate_size(self, obj: Any) -> int:\n    53→        \"\"\"Estimate object size in bytes.\"\"\"\n    54→        return sys.getsizeof(obj)\n    55→    \n    56→    def _evict_if_needed(self):\n    57→        \"\"\"Evict items if cache is too large.\"\"\"\n    58→        while (len(self.cache) > self.max_size or \n    59→               self.current_memory > self.max_memory_bytes):\n    60→            if not self.access_order:\n    61→                break\n    62→            \n    63→            key = self.access_order.popleft()\n    64→            if key in self.cache:\n    65→                value = self.cache.pop(key)\n    66→                self.current_memory -= self._estimate_size(value)\n    67→    \n    68→    def get(self, key: str) -> Optional[Any]:\n    69→        \"\"\"Get item from cache.\"\"\"\n    70→        if key in self.cache:\n    71→            # Move to end (most recent)\n    72→            self.access_order.remove(key)\n    73→            self.access_order.append(key)\n    74→            return self.cache[key]\n    75→        return None\n    76→    \n    77→    def put(self, key: str, value: Any) -> None:\n    78→        \"\"\"Put item in cache.\"\"\"\n    79→        if key in self.cache:\n    80→            # Update existing\n    81→            old_value = self.cache[key]\n    82→            self.current_memory -= self._estimate_size(old_value)\n    83→            self.access_order.remove(key)\n    84→        \n    85→        size = self._estimate_size(value)\n    86→        self.cache[key] = value\n    87→        self.access_order.append(key)\n    88→        self.current_memory += size\n    89→        \n    90→        self._evict_if_needed()\n    91→    \n    92→    def get_stats(self) -> Dict[str, Any]:\n    93→        \"\"\"Get cache statistics.\"\"\"\n    94→        return {\n    95→            \"size\": len(self.cache),\n    96→            \"max_size\": self.max_size,\n    97→            \"memory_mb\": self.current_memory / (1024 * 1024),\n    98→            \"max_memory_mb\": self.max_memory_bytes / (1024 * 1024),\n    99→            \"hit_ratio\": 0.0  # Simplified for demo\n   100→        }\n   101→\n   102→\n   103→class ObjectPool:\n   104→    \"\"\"Object pool for expensive-to-create objects.\"\"\"\n   105→    \n   106→    def __init__(self, factory: Callable, max_size: int = 10):\n   107→        self.factory = factory\n   108→        self.max_size = max_size\n   109→        self.available = deque()\n   110→        self.in_use = weakref.WeakSet()\n   111→        self.total_created = 0\n   112→    \n   113→    def acquire(self):\n   114→        \"\"\"Acquire object from pool.\"\"\"\n   115→        if self.available:\n   116→            obj = self.available.popleft()\n   117→        else:\n   118→            if self.total_created < self.max_size:\n   119→                obj = self.factory()\n   120→                self.total_created += 1\n   121→            else:\n   122→                # Wait or create temporary\n   123→                obj = self.factory()\n   124→        \n   125→        self.in_use.add(obj)\n   126→        return obj\n   127→    \n   128→    def release(self, obj):\n   129→        \"\"\"Release object back to pool.\"\"\"\n   130→        if obj in self.in_use:\n   131→            self.in_use.remove(obj)\n   132→            if len(self.available) < self.max_size:\n   133→                # Reset object state if needed\n   134→                if hasattr(obj, 'reset'):\n   135→                    obj.reset()\n   136→                self.available.append(obj)\n   137→    \n   138→    @contextmanager\n   139→    def borrow(self):\n   140→        \"\"\"Context manager for automatic object management.\"\"\"\n   141→        obj = self.acquire()\n   142→        try:\n   143→            yield obj\n   144→        finally:\n   145→            self.release(obj)\n   146→    \n   147→    def get_stats(self) -> Dict[str, Any]:\n   148→        return {\n   149→            \"available\": len(self.available),\n   150→            \"in_use\": len(self.in_use),\n   151→            \"total_created\": self.total_created,\n   152→            \"max_size\": self.max_size\n   153→        }\n   154→\n   155→\n   156→# Performance Profiling Utilities\n   157→@contextmanager\n   158→def profile_memory():\n   159→    \"\"\"Context manager for memory profiling.\"\"\"\n   160→    tracemalloc.start()\n   161→    start_memory = tracemalloc.get_traced_memory()[0]\n   162→    \n   163→    yield\n   164→    \n   165→    end_memory = tracemalloc.get_traced_memory()[0]\n   166→    tracemalloc.stop()\n   167→    \n   168→    memory_used = (end_memory - start_memory) / (1024 * 1024)  # MB\n   169→    console.print(f\"[dim]🧠 Memory used: {memory_used:.2f} MB[/dim]\")\n   170→\n   171→\n   172→@contextmanager\n   173→def profile_time():\n   174→    \"\"\"Context manager for timing operations.\"\"\"\n   175→    start_time = time.perf_counter()\n   176→    yield\n   177→    end_time = time.perf_counter()\n   178→    duration = end_time - start_time\n   179→    console.print(f\"[dim]⏱️  Execution time: {duration:.4f}s[/dim]\")\n   180→\n   181→\n   182→class PerformanceMonitor:\n   183→    \"\"\"Monitor for tracking performance metrics.\"\"\"\n   184→    \n   185→    def __init__(self):\n   186→        self.metrics = defaultdict(list)\n   187→        self.counters = defaultdict(int)\n   188→    \n   189→    def record_time(self, operation: str, duration: float):\n   190→        \"\"\"Record operation timing.\"\"\"\n   191→        self.metrics[f\"{operation}_time\"].append(duration)\n   192→        self.counters[f\"{operation}_count\"] += 1\n   193→    \n   194→    def record_memory(self, operation: str, memory_mb: float):\n   195→        \"\"\"Record memory usage.\"\"\"\n   196→        self.metrics[f\"{operation}_memory\"].append(memory_mb)\n   197→    \n   198→    def get_summary(self) -> Dict[str, Any]:\n   199→        \"\"\"Get performance summary.\"\"\"\n   200→        summary = {}\n   201→        \n   202→        for metric_name, values in self.metrics.items():\n   203→            if values:\n   204→                summary[metric_name] = {\n   205→                    \"avg\": sum(values) / len(values),\n   206→                    \"min\": min(values),\n   207→                    \"max\": max(values),\n   208→                    \"count\": len(values)\n   209→                }\n   210→        \n   211→        summary[\"counters\"] = dict(self.counters)\n   212→        return summary\n   213→\n   214→\n   215→# Vectorized Operations\n   216→class VectorizedTextProcessor:\n   217→    \"\"\"Text processor using vectorized operations.\"\"\"\n   218→    \n   219→    @staticmethod\n   220→    def batch_tokenize(texts: List[str]) -> List[List[str]]:\n   221→        \"\"\"Vectorized tokenization.\"\"\"\n   222→        # Simulate vectorized operation\n   223→        return [text.lower().split() for text in texts]\n   224→    \n   225→    @staticmethod\n   226→    def batch_compute_lengths(texts: List[str]) -> np.ndarray:\n   227→        \"\"\"Compute text lengths using NumPy.\"\"\"\n   228→        return np.array([len(text) for text in texts])\n   229→    \n   230→    @staticmethod\n   231→    def batch_filter_by_length(texts: List[str], min_length: int) -> List[str]:\n   232→        \"\"\"Filter texts by length using vectorized operations.\"\"\"\n   233→        lengths = VectorizedTextProcessor.batch_compute_lengths(texts)\n   234→        mask = lengths >= min_length\n   235→        return [text for text, keep in zip(texts, mask) if keep]\n   236→    \n   237→    @staticmethod\n   238→    def batch_similarity_matrix(texts: List[str]) -> np.ndarray:\n   239→        \"\"\"Compute similarity matrix (simplified).\"\"\"\n   240→        n = len(texts)\n   241→        similarity = np.zeros((n, n))\n   242→        \n   243→        # Simplified similarity based on length\n   244→        lengths = VectorizedTextProcessor.batch_compute_lengths(texts)\n   245→        for i in range(n):\n   246→            for j in range(n):\n   247→                if i != j:\n   248→                    similarity[i, j] = 1.0 / (1.0 + abs(lengths[i] - lengths[j]))\n   249→                else:\n   250→                    similarity[i, j] = 1.0\n   251→        \n   252→        return similarity\n   253→\n   254→\n   255→# Parallel Processing Patterns\n   256→class ParallelProcessor:\n   257→    \"\"\"Utilities for parallel processing.\"\"\"\n   258→    \n   259→    @staticmethod\n   260→    def parallel_map_threads(func: Callable, items: List[Any], max_workers: int = 4) -> List[Any]:\n   261→        \"\"\"Parallel map using threads (I/O bound tasks).\"\"\"\n   262→        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n   263→            results = list(executor.map(func, items))\n   264→        return results\n   265→    \n   266→    @staticmethod\n   267→    def parallel_map_processes(func: Callable, items: List[Any], max_workers: int = None) -> List[Any]:\n   268→        \"\"\"Parallel map using processes (CPU bound tasks).\"\"\"\n   269→        if max_workers is None:\n   270→            max_workers = mp.cpu_count()\n   271→        \n   272→        with ProcessPoolExecutor(max_workers=max_workers) as executor:\n   273→            results = list(executor.map(func, items))\n   274→        return results\n   275→    \n   276→    @staticmethod\n   277→    def parallel_batch_process(\n   278→        items: List[Any], \n   279→        batch_func: Callable[[List[Any]], List[Any]], \n   280→        batch_size: int = 100,\n   281→        max_workers: int = 4\n   282→    ) -> List[Any]:\n   283→        \"\"\"Process items in parallel batches.\"\"\"\n   284→        \n   285→        # Split into batches\n   286→        batches = [items[i:i + batch_size] for i in range(0, len(items), batch_size)]\n   287→        \n   288→        # Process batches in parallel\n   289→        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n   290→            batch_results = list(executor.map(batch_func, batches))\n   291→        \n   292→        # Flatten results\n   293→        results = []\n   294→        for batch_result in batch_results:\n   295→            results.extend(batch_result)\n   296→        \n   297→        return results\n   298→\n   299→\n   300→# Lazy Loading and Generators\n   301→class LazyDataLoader:\n   302→    \"\"\"Lazy data loader for large datasets.\"\"\"\n   303→    \n   304→    def __init__(self, data_source: Callable[[], Iterator[Any]]):\n   305→        self.data_source = data_source\n   306→        self._cache = {}\n   307→        self._loaded_chunks = set()\n   308→    \n   309→    def get_chunk(self, chunk_id: int, chunk_size: int = 1000) -> List[Any]:\n   310→        \"\"\"Get data chunk by ID.\"\"\"\n   311→        if chunk_id in self._cache:\n   312→            return self._cache[chunk_id]\n   313→        \n   314→        # Load chunk lazily\n   315→        data_iter = self.data_source()\n   316→        chunk_data = []\n   317→        \n   318→        # Skip to the right position\n   319→        for i, item in enumerate(data_iter):\n   320→            if i >= chunk_id * chunk_size and i < (chunk_id + 1) * chunk_size:\n   321→                chunk_data.append(item)\n   322→            elif i >= (chunk_id + 1) * chunk_size:\n   323→                break\n   324→        \n   325→        self._cache[chunk_id] = chunk_data\n   326→        self._loaded_chunks.add(chunk_id)\n   327→        return chunk_data\n   328→    \n   329→    def get_stats(self) -> Dict[str, Any]:\n   330→        return {\n   331→            \"loaded_chunks\": len(self._loaded_chunks),\n   332→            \"cache_size\": len(self._cache)\n   333→        }\n   334→\n   335→\n   336→def create_sample_data_generator(size: int = 10000) -> Iterator[str]:\n   337→    \"\"\"Create sample data generator.\"\"\"\n   338→    for i in range(size):\n   339→        yield f\"Sample text item {i} with some content for processing\"\n   340→\n   341→\n   342→# Optimization Decorators\n   343→def memoize_disk(cache_dir: str = \"/tmp/ai_cache\"):\n   344→    \"\"\"Decorator for disk-based memoization.\"\"\"\n   345→    import pickle\n   346→    import hashlib\n   347→    import os\n   348→    \n   349→    os.makedirs(cache_dir, exist_ok=True)\n   350→    \n   351→    def decorator(func):\n   352→        def wrapper(*args, **kwargs):\n   353→            # Create cache key\n   354→            key = hashlib.md5(str(args).encode() + str(kwargs).encode()).hexdigest()\n   355→            cache_file = os.path.join(cache_dir, f\"{func.__name__}_{key}.pkl\")\n   356→            \n   357→            # Check cache\n   358→            if os.path.exists(cache_file):\n   359→                try:\n   360→                    with open(cache_file, 'rb') as f:\n   361→                        result = pickle.load(f)\n   362→                    console.print(f\"[dim green]💾 Disk cache hit for {func.__name__}[/dim green]\")\n   363→                    return result\n   364→                except:\n   365→                    pass\n   366→            \n   367→            # Compute and cache\n   368→            result = func(*args, **kwargs)\n   369→            try:\n   370→                with open(cache_file, 'wb') as f:\n   371→                    pickle.dump(result, f)\n   372→                console.print(f\"[dim yellow]💿 Cached {func.__name__} to disk[/dim yellow]\")\n   373→            except:\n   374→                pass\n   375→            \n   376→            return result\n   377→        return wrapper\n   378→    return decorator\n   379→\n   380→\n   381→def batch_decorator(batch_size: int = 10):\n   382→    \"\"\"Decorator to automatically batch function calls.\"\"\"\n   383→    def decorator(func):\n   384→        def wrapper(items: List[Any], *args, **kwargs):\n   385→            results = []\n   386→            for i in range(0, len(items), batch_size):\n   387→                batch = items[i:i + batch_size]\n   388→                batch_results = func(batch, *args, **kwargs)\n   389→                results.extend(batch_results)\n   390→            return results\n   391→        return wrapper\n   392→    return decorator\n   393→\n   394→\n   395→# Example AI Processing Functions\n   396→@memoize_disk()\n   397→def expensive_model_inference(text: str) -> Dict[str, Any]:\n   398→    \"\"\"Simulate expensive model inference.\"\"\"\n   399→    time.sleep(0.1)  # Simulate processing time\n   400→    \n   401→    # Mock inference results\n   402→    return {\n   403→        \"sentiment\": \"positive\" if \"good\" in text.lower() else \"neutral\",\n   404→        \"confidence\": 0.85,\n   405→        \"processing_time\": 0.1,\n   406→        \"tokens\": len(text.split())\n   407→    }\n   408→\n   409→\n   410→@batch_decorator(batch_size=5)\n   411→def batch_text_analysis(texts: List[str]) -> List[Dict[str, Any]]:\n   412→    \"\"\"Batch text analysis.\"\"\"\n   413→    # Simulate batch processing advantage\n   414→    time.sleep(0.02)  # Much faster per item than individual calls\n   415→    \n   416→    return [\n   417→        {\n   418→            \"length\": len(text),\n   419→            \"word_count\": len(text.split()),\n   420→            \"char_diversity\": len(set(text.lower())),\n   421→            \"batch_processed\": True\n   422→        }\n   423→        for text in texts\n   424→    ]\n   425→\n   426→\n   427→def cpu_intensive_task(data: str) -> str:\n   428→    \"\"\"CPU-intensive task for parallel processing demo.\"\"\"\n   429→    # Simulate CPU work\n   430→    result = \"\"\n   431→    for _ in range(1000):\n   432→        result = str(hash(data + result))[:10]\n   433→    return result\n   434→\n   435→\n   436→def io_intensive_task(data: str) -> str:\n   437→    \"\"\"I/O-intensive task for parallel processing demo.\"\"\"\n   438→    # Simulate I/O wait\n   439→    time.sleep(0.01)\n   440→    return f\"Processed: {data.upper()}\"\n   441→\n   442→\n   443→async def demonstrate_memory_efficient_structures():\n   444→    \"\"\"Show memory-efficient data structures.\"\"\"\n   445→    \n   446→    console.print(Panel(\"🧠 Memory-Efficient Structures\", style=\"bold blue\"))\n   447→    \n   448→    # Test memory-efficient cache\n   449→    console.print(\"[bold yellow]Testing memory-efficient cache:[/bold yellow]\")\n   450→    \n   451→    cache = MemoryEfficientCache(max_size=5, max_memory_mb=0.1)\n   452→    \n   453→    # Add items to cache\n   454→    test_data = [f\"large_data_item_{i}\" * 100 for i in range(10)]\n   455→    \n   456→    for i, data in enumerate(test_data):\n   457→        cache.put(f\"key_{i}\", data)\n   458→        stats = cache.get_stats()\n   459→        console.print(f\"  Added item {i}: cache size={stats['size']}, memory={stats['memory_mb']:.3f}MB\")\n   460→    \n   461→    # Test retrieval\n   462→    console.print(f\"\\n[bold cyan]Cache retrieval test:[/bold cyan]\")\n   463→    for i in [0, 3, 7, 9]:\n   464→        result = cache.get(f\"key_{i}\")\n   465→        status = \"HIT\" if result else \"MISS\"\n   466→        console.print(f\"  key_{i}: {status}\")\n   467→    \n   468→    # Test object pool\n   469→    console.print(f\"\\n[bold yellow]Testing object pool:[/bold yellow]\")\n   470→    \n   471→    class ExpensiveResource:\n   472→        def __init__(self):\n   473→            time.sleep(0.01)  # Simulate expensive creation\n   474→            self.created_at = time.time()\n   475→            self.usage_count = 0\n   476→        \n   477→        def reset(self):\n   478→            self.usage_count = 0\n   479→    \n   480→    pool = ObjectPool(ExpensiveResource, max_size=3)\n   481→    \n   482→    # Use objects from pool\n   483→    with pool.borrow() as obj1:\n   484→        obj1.usage_count += 1\n   485→        console.print(f\"  Using object 1: created at {obj1.created_at:.3f}\")\n   486→        \n   487→        with pool.borrow() as obj2:\n   488→            obj2.usage_count += 1\n   489→            console.print(f\"  Using object 2: created at {obj2.created_at:.3f}\")\n   490→    \n   491→    console.print(f\"  Pool stats: {pool.get_stats()}\")\n   492→\n   493→\n   494→async def demonstrate_profiling():\n   495→    \"\"\"Show profiling techniques.\"\"\"\n   496→    \n   497→    console.print(Panel(\"📊 Performance Profiling\", style=\"bold green\"))\n   498→    \n   499→    monitor = PerformanceMonitor()\n   500→    \n   501→    console.print(\"[bold yellow]Profiling different operations:[/bold yellow]\")\n   502→    \n   503→    # Profile memory usage\n   504→    with profile_memory():\n   505→        with profile_time():\n   506→            # Create large data structure\n   507→            large_list = [f\"item_{i}\" for i in range(100000)]\n   508→            \n   509→            start_time = time.perf_counter()\n   510→            # Simulate processing\n   511→            processed = [item.upper() for item in large_list[:1000]]\n   512→            duration = time.perf_counter() - start_time\n   513→            \n   514→            monitor.record_time(\"list_processing\", duration)\n   515→    \n   516→    # Profile function calls\n   517→    console.print(f\"\\n[bold cyan]Function call profiling:[/bold cyan]\")\n   518→    \n   519→    def profile_function():\n   520→        \"\"\"Function to profile.\"\"\"\n   521→        result = []\n   522→        for i in range(1000):\n   523→            result.append(expensive_model_inference(f\"test text {i % 10}\"))  # Will hit cache\n   524→        return result\n   525→    \n   526→    # Use cProfile\n   527→    profiler = cProfile.Profile()\n   528→    profiler.enable()\n   529→    \n   530→    start_time = time.perf_counter()\n   531→    results = profile_function()\n   532→    duration = time.perf_counter() - start_time\n   533→    \n   534→    profiler.disable()\n   535→    \n   536→    # Show results\n   537→    console.print(f\"  Processed {len(results)} items in {duration:.4f}s\")\n   538→    console.print(f\"  Rate: {len(results) / duration:.1f} items/second\")\n   539→    \n   540→    # Show performance summary\n   541→    summary = monitor.get_summary()\n   542→    console.print(f\"\\n[bold magenta]Performance summary:[/bold magenta]\")\n   543→    for metric, stats in summary.items():\n   544→        if isinstance(stats, dict) and 'avg' in stats:\n   545→            console.print(f\"  {metric}: avg={stats['avg']:.4f}, count={stats['count']}\")\n   546→\n   547→\n   548→async def demonstrate_vectorization():\n   549→    \"\"\"Show vectorized operations.\"\"\"\n   550→    \n   551→    console.print(Panel(\"⚡ Vectorized Operations\", style=\"bold magenta\"))\n   552→    \n   553→    # Create test data\n   554→    test_texts = [f\"Sample text number {i} for processing\" for i in range(1000)]\n   555→    \n   556→    console.print(\"[bold yellow]Comparing scalar vs vectorized operations:[/bold yellow]\")\n   557→    \n   558→    # Scalar operations\n   559→    start_time = time.perf_counter()\n   560→    scalar_lengths = [len(text) for text in test_texts]\n   561→    scalar_time = time.perf_counter() - start_time\n   562→    \n   563→    # Vectorized operations\n   564→    start_time = time.perf_counter()\n   565→    vector_lengths = VectorizedTextProcessor.batch_compute_lengths(test_texts)\n   566→    vector_time = time.perf_counter() - start_time\n   567→    \n   568→    console.print(f\"  Scalar processing: {scalar_time:.4f}s\")\n   569→    console.print(f\"  Vectorized processing: {vector_time:.4f}s\")\n   570→    console.print(f\"  Speedup: {scalar_time / vector_time:.1f}x\")\n   571→    \n   572→    # Test batch operations\n   573→    console.print(f\"\\n[bold cyan]Batch text processing:[/bold cyan]\")\n   574→    \n   575→    start_time = time.perf_counter()\n   576→    tokenized = VectorizedTextProcessor.batch_tokenize(test_texts[:100])\n   577→    filtered = VectorizedTextProcessor.batch_filter_by_length(test_texts[:100], min_length=20)\n   578→    processing_time = time.perf_counter() - start_time\n   579→    \n   580→    console.print(f\"  Processed {len(test_texts[:100])} texts in {processing_time:.4f}s\")\n   581→    console.print(f\"  Tokenized: {len(tokenized)} texts\")\n   582→    console.print(f\"  Filtered: {len(filtered)} texts (length >= 20)\")\n   583→    \n   584→    # Similarity matrix\n   585→    console.print(f\"\\n[bold yellow]Computing similarity matrix:[/bold yellow]\")\n   586→    sample_texts = test_texts[:10]\n   587→    \n   588→    start_time = time.perf_counter()\n   589→    similarity_matrix = VectorizedTextProcessor.batch_similarity_matrix(sample_texts)\n   590→    matrix_time = time.perf_counter() - start_time\n   591→    \n   592→    console.print(f\"  {len(sample_texts)}x{len(sample_texts)} matrix computed in {matrix_time:.4f}s\")\n   593→    console.print(f\"  Average similarity: {np.mean(similarity_matrix[similarity_matrix != 1.0]):.3f}\")\n   594→\n   595→\n   596→async def demonstrate_parallel_processing():\n   597→    \"\"\"Show parallel processing patterns.\"\"\"\n   598→    \n   599→    console.print(Panel(\"🚀 Parallel Processing\", style=\"bold cyan\"))\n   600→    \n   601→    # Create test data\n   602→    test_data = [f\"data_item_{i}\" for i in range(100)]\n   603→    \n   604→    console.print(\"[bold yellow]Comparing sequential vs parallel processing:[/bold yellow]\")\n   605→    \n   606→    # Sequential processing (CPU-bound)\n   607→    start_time = time.perf_counter()\n   608→    sequential_results = [cpu_intensive_task(item) for item in test_data[:20]]\n   609→    sequential_time = time.perf_counter() - start_time\n   610→    \n   611→    # Parallel processing (CPU-bound)\n   612→    start_time = time.perf_counter()\n   613→    parallel_results = ParallelProcessor.parallel_map_processes(\n   614→        cpu_intensive_task, test_data[:20], max_workers=2\n   615→    )\n   616→    parallel_time = time.perf_counter() - start_time\n   617→    \n   618→    console.print(f\"  Sequential (CPU): {sequential_time:.4f}s\")\n   619→    console.print(f\"  Parallel (CPU): {parallel_time:.4f}s\")\n   620→    console.print(f\"  Speedup: {sequential_time / parallel_time:.1f}x\")\n   621→    \n   622→    # I/O-bound comparison\n   623→    console.print(f\"\\n[bold cyan]I/O-bound task comparison:[/bold cyan]\")\n   624→    \n   625→    start_time = time.perf_counter()\n   626→    sequential_io = [io_intensive_task(item) for item in test_data[:50]]\n   627→    sequential_io_time = time.perf_counter() - start_time\n   628→    \n   629→    start_time = time.perf_counter()\n   630→    parallel_io = ParallelProcessor.parallel_map_threads(\n   631→        io_intensive_task, test_data[:50], max_workers=10\n   632→    )\n   633→    parallel_io_time = time.perf_counter() - start_time\n   634→    \n   635→    console.print(f\"  Sequential (I/O): {sequential_io_time:.4f}s\")\n   636→    console.print(f\"  Parallel (I/O): {parallel_io_time:.4f}s\")\n   637→    console.print(f\"  Speedup: {sequential_io_time / parallel_io_time:.1f}x\")\n   638→    \n   639→    # Batch processing\n   640→    console.print(f\"\\n[bold yellow]Parallel batch processing:[/bold yellow]\")\n   641→    \n   642→    def process_batch(batch: List[str]) -> List[str]:\n   643→        return [item.upper() for item in batch]\n   644→    \n   645→    start_time = time.perf_counter()\n   646→    batch_results = ParallelProcessor.parallel_batch_process(\n   647→        test_data, process_batch, batch_size=25, max_workers=4\n   648→    )\n   649→    batch_time = time.perf_counter() - start_time\n   650→    \n   651→    console.print(f\"  Processed {len(batch_results)} items in {batch_time:.4f}s\")\n   652→    console.print(f\"  Rate: {len(batch_results) / batch_time:.1f} items/second\")\n   653→\n   654→\n   655→async def demonstrate_lazy_loading():\n   656→    \"\"\"Show lazy loading patterns.\"\"\"\n   657→    \n   658→    console.print(Panel(\"😴 Lazy Loading\", style=\"bold red\"))\n   659→    \n   660→    console.print(\"[bold yellow]Creating lazy data loader:[/bold yellow]\")\n   661→    \n   662→    # Create lazy loader\n   663→    loader = LazyDataLoader(lambda: create_sample_data_generator(10000))\n   664→    \n   665→    console.print(f\"  Initial stats: {loader.get_stats()}\")\n   666→    \n   667→    # Load some chunks\n   668→    console.print(f\"\\n[bold cyan]Loading data chunks on demand:[/bold cyan]\")\n   669→    \n   670→    for chunk_id in [0, 2, 5]:\n   671→        start_time = time.perf_counter()\n   672→        chunk_data = loader.get_chunk(chunk_id, chunk_size=100)\n   673→        load_time = time.perf_counter() - start_time\n   674→        \n   675→        console.print(f\"  Chunk {chunk_id}: {len(chunk_data)} items loaded in {load_time:.4f}s\")\n   676→    \n   677→    console.print(f\"  Final stats: {loader.get_stats()}\")\n   678→    \n   679→    # Access cached chunk\n   680→    start_time = time.perf_counter()\n   681→    cached_chunk = loader.get_chunk(0, chunk_size=100)  # Should be cached\n   682→    cached_time = time.perf_counter() - start_time\n   683→    \n   684→    console.print(f\"  Cached access: {len(cached_chunk)} items in {cached_time:.6f}s\")\n   685→\n   686→\n   687→async def demonstrate_batch_processing():\n   688→    \"\"\"Show batch processing optimization.\"\"\"\n   689→    \n   690→    console.print(Panel(\"📦 Batch Processing\", style=\"bold yellow\"))\n   691→    \n   692→    # Create test data\n   693→    test_texts = [f\"Text sample {i} for analysis\" for i in range(100)]\n   694→    \n   695→    console.print(\"[bold yellow]Comparing individual vs batch processing:[/bold yellow]\")\n   696→    \n   697→    # Individual processing\n   698→    start_time = time.perf_counter()\n   699→    individual_results = []\n   700→    for text in test_texts[:20]:\n   701→        result = {\n   702→            \"length\": len(text),\n   703→            \"word_count\": len(text.split()),\n   704→            \"char_diversity\": len(set(text.lower())),\n   705→            \"batch_processed\": False\n   706→        }\n   707→        individual_results.append(result)\n   708→    individual_time = time.perf_counter() - start_time\n   709→    \n   710→    # Batch processing\n   711→    start_time = time.perf_counter()\n   712→    batch_results = batch_text_analysis(test_texts[:20])\n   713→    batch_time = time.perf_counter() - start_time\n   714→    \n   715→    console.print(f\"  Individual processing: {individual_time:.4f}s\")\n   716→    console.print(f\"  Batch processing: {batch_time:.4f}s\")\n   717→    console.print(f\"  Speedup: {individual_time / batch_time:.1f}x\")\n   718→    \n   719→    # Verify results\n   720→    console.print(f\"\\n[bold cyan]Result verification:[/bold cyan]\")\n   721→    console.print(f\"  Individual results: {len(individual_results)} items\")\n   722→    console.print(f\"  Batch results: {len(batch_results)} items\")\n   723→    console.print(f\"  Batch flag in results: {batch_results[0]['batch_processed']}\")\n   724→\n   725→\n   726→async def demonstrate_gc_optimization():\n   727→    \"\"\"Show garbage collection optimization.\"\"\"\n   728→    \n   729→    console.print(Panel(\"🗑️ Garbage Collection Optimization\", style=\"bold purple\"))\n   730→    \n   731→    console.print(\"[bold yellow]Memory management with garbage collection:[/bold yellow]\")\n   732→    \n   733→    # Check initial memory\n   734→    gc.collect()  # Force collection\n   735→    initial_objects = len(gc.get_objects())\n   736→    \n   737→    console.print(f\"  Initial objects: {initial_objects}\")\n   738→    \n   739→    # Create many objects\n   740→    large_objects = []\n   741→    for i in range(1000):\n   742→        obj = {\n   743→            \"id\": i,\n   744→            \"data\": [f\"item_{j}\" for j in range(100)],\n   745→            \"metadata\": {\"created\": time.time(), \"type\": \"test\"}\n   746→        }\n   747→        large_objects.append(obj)\n   748→    \n   749→    mid_objects = len(gc.get_objects())\n   750→    console.print(f\"  After creation: {mid_objects} objects (+{mid_objects - initial_objects})\")\n   751→    \n   752→    # Clear references and force collection\n   753→    del large_objects\n   754→    gc.collect()\n   755→    \n   756→    final_objects = len(gc.get_objects())\n   757→    console.print(f\"  After cleanup: {final_objects} objects (-{mid_objects - final_objects})\")\n   758→    \n   759→    # Show GC stats\n   760→    console.print(f\"\\n[bold cyan]Garbage collection stats:[/bold cyan]\")\n   761→    for generation, stats in enumerate(gc.get_stats()):\n   762→        console.print(f\"  Generation {generation}: {stats}\")\n   763→\n   764→\n   765→def benchmark_comparison():\n   766→    \"\"\"Compare different optimization techniques.\"\"\"\n   767→    \n   768→    console.print(Panel(\"🏆 Performance Benchmark\", style=\"bold orange\"))\n   769→    \n   770→    test_data = [f\"benchmark text {i}\" for i in range(1000)]\n   771→    \n   772→    console.print(\"[bold yellow]Benchmarking optimization techniques:[/bold yellow]\")\n   773→    \n   774→    techniques = [\n   775→        (\"No optimization\", lambda data: [len(item) for item in data]),\n   776→        (\"List comprehension\", lambda data: [len(item) for item in data]),\n   777→        (\"Generator expression\", lambda data: list(len(item) for item in data)),\n   778→        (\"NumPy vectorized\", lambda data: VectorizedTextProcessor.batch_compute_lengths(data)),\n   779→        (\"Parallel threads\", lambda data: ParallelProcessor.parallel_map_threads(len, data)),\n   780→    ]\n   781→    \n   782→    results = []\n   783→    \n   784→    for name, technique in techniques:\n   785→        # Warm up\n   786→        technique(test_data[:10])\n   787→        \n   788→        # Benchmark\n   789→        start_time = time.perf_counter()\n   790→        result = technique(test_data)\n   791→        end_time = time.perf_counter()\n   792→        \n   793→        duration = end_time - start_time\n   794→        rate = len(test_data) / duration\n   795→        \n   796→        results.append((name, duration, rate))\n   797→        console.print(f\"  {name}: {duration:.4f}s ({rate:.1f} items/sec)\")\n   798→    \n   799→    # Find best technique\n   800→    best_technique = min(results, key=lambda x: x[1])\n   801→    console.print(f\"\\n[bold green]Best technique: {best_technique[0]} ({best_technique[1]:.4f}s)[/bold green]\")\n   802→\n   803→\n   804→def interactive_exercise():\n   805→    \"\"\"Interactive exercise for performance optimization.\"\"\"\n   806→    \n   807→    console.print(Panel(\"🎮 Interactive Exercise: Optimize AI Performance\", style=\"bold magenta\"))\n   808→    \n   809→    scenarios = [\n   810→        {\n   811→            \"challenge\": \"Large-Scale Text Processing\",\n   812→            \"problem\": \"Process 1M+ text documents with multiple AI models\",\n   813→            \"bottlenecks\": [\n   814→                \"Memory usage grows unbounded\",\n   815→                \"CPU utilization is poor\",\n   816→                \"I/O operations are blocking\",\n   817→                \"Cache misses are frequent\"\n   818→            ],\n   819→            \"solutions\": \"Memory pooling, vectorization, async I/O, intelligent caching\"\n   820→        },\n   821→        {\n   822→            \"challenge\": \"Real-Time AI Inference\",\n   823→            \"problem\": \"Serve AI predictions with <100ms latency\",\n   824→            \"bottlenecks\": [\n   825→                \"Model loading takes too long\",\n   826→                \"Batch processing adds latency\",\n   827→                \"Memory allocations cause GC pauses\",\n   828→                \"Network serialization is slow\"\n   829→            ],\n   830→            \"solutions\": \"Model pooling, streaming inference, object reuse, binary protocols\"\n   831→        },\n   832→        {\n   833→            \"challenge\": \"Multi-Model Ensemble\",\n   834→            \"problem\": \"Run multiple AI models concurrently\",\n   835→            \"bottlenecks\": [\n   836→                \"Models compete for resources\",\n   837→                \"Sequential processing is slow\",\n   838→                \"Memory pressure causes swapping\",\n   839→                \"Error handling blocks pipeline\"\n   840→            ],\n   841→            \"solutions\": \"Resource isolation, parallel execution, memory management, circuit breakers\"\n   842→        }\n   843→    ]\n   844→    \n   845→    for i, scenario in enumerate(scenarios, 1):\n   846→        console.print(f\"\\n[bold cyan]Challenge {i}: {scenario['challenge']}[/bold cyan]\")\n   847→        console.print(f\"[bold yellow]Problem: {scenario['problem']}[/bold yellow]\")\n   848→        console.print(\"[bold red]Common Bottlenecks:[/bold red]\")\n   849→        for bottleneck in scenario[\"bottlenecks\"]:\n   850→            console.print(f\"  • {bottleneck}\")\n   851→        console.print(f\"\\n[bold green]Optimization Strategies: {scenario['solutions']}[/bold green]\")\n   852→        console.print(\"\\n[bold magenta]Consider:[/bold magenta]\")\n   853→        console.print(\"  • Profile first, optimize second\")\n   854→        console.print(\"  • Memory vs CPU vs I/O trade-offs\")\n   855→        console.print(\"  • Caching strategies and invalidation\")\n   856→        console.print(\"  • Parallel vs concurrent execution\")\n   857→        console.print(\"  • Resource pooling and lifecycle management\")\n   858→        console.print(\"---\")\n   859→\n   860→\n   861→if __name__ == \"__main__\":\n   862→    console.print(\"[bold blue]🚀 AI Architecture Patterns: Performance Optimization[/bold blue]\")\n   863→    console.print(\"Learn to build high-performance AI systems\\n\")\n   864→    \n   865→    async def main():\n   866→        await demonstrate_memory_efficient_structures()\n   867→        console.print(\"\\n\" + \"=\"*60)\n   868→        \n   869→        await demonstrate_profiling()\n   870→        console.print(\"\\n\" + \"=\"*60)\n   871→        \n   872→        await demonstrate_vectorization()\n   873→        console.print(\"\\n\" + \"=\"*60)\n   874→        \n   875→        await demonstrate_parallel_processing()\n   876→        console.print(\"\\n\" + \"=\"*60)\n   877→        \n   878→        await demonstrate_lazy_loading()\n   879→        console.print(\"\\n\" + \"=\"*60)\n   880→        \n   881→        await demonstrate_batch_processing()\n   882→        console.print(\"\\n\" + \"=\"*60)\n   883→        \n   884→        await demonstrate_gc_optimization()\n   885→        console.print(\"\\n\" + \"=\"*60)\n   886→        \n   887→        benchmark_comparison()\n   888→        console.print(\"\\n\" + \"=\"*60)\n   889→        \n   890→        interactive_exercise()\n   891→        \n   892→        console.print(f\"\\n[bold green]✅ Completed![/bold green] All Python idioms examples are ready!\")\n   893→        console.print(\"💡 Pro tip: Always profile before optimizing - measure, don't guess!\")\n   894→    \n   895→    import asyncio\n   896→    asyncio.run(main())\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"7b73cd4b-d5a5-4ead-aef0-1274e0966420","timestamp":"2025-08-01T17:59:45.955Z","toolUseResult":{"type":"text","file":{"filePath":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/examples/05_performance_optimization.py","content":"#!/usr/bin/env python3\n\"\"\"\nExample 5: Performance Optimization for AI Systems\n\nLearn performance optimization techniques for AI applications including\nprofiling, memory management, vectorization, and parallel processing.\n\nRun this file to see the examples in action:\n    python 03-python-idioms/examples/05_performance_optimization.py\n\"\"\"\n\nimport sys\nimport os\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))\n\nimport time\nimport gc\nimport weakref\nimport threading\nimport multiprocessing as mp\nfrom concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, as_completed\nfrom typing import List, Dict, Any, Callable, Iterator, Optional, Tuple\nfrom dataclasses import dataclass\nfrom functools import lru_cache, partial\nimport cProfile\nimport pstats\nimport tracemalloc\nfrom contextlib import contextmanager\nfrom collections import deque, defaultdict\nimport numpy as np\nfrom rich.console import Console\nfrom rich.panel import Panel\nfrom rich.table import Table\nfrom rich.progress import Progress, TaskID\n\nconsole = Console()\n\n# 🎯 LEARNING GOAL: Master performance optimization for AI systems\n\n\n# Memory-Efficient Data Structures\nclass MemoryEfficientCache:\n    \"\"\"Memory-efficient LRU cache with size limits.\"\"\"\n    \n    def __init__(self, max_size: int = 1000, max_memory_mb: float = 100.0):\n        self.max_size = max_size\n        self.max_memory_bytes = max_memory_mb * 1024 * 1024\n        self.cache = {}\n        self.access_order = deque()\n        self.current_memory = 0\n    \n    def _estimate_size(self, obj: Any) -> int:\n        \"\"\"Estimate object size in bytes.\"\"\"\n        return sys.getsizeof(obj)\n    \n    def _evict_if_needed(self):\n        \"\"\"Evict items if cache is too large.\"\"\"\n        while (len(self.cache) > self.max_size or \n               self.current_memory > self.max_memory_bytes):\n            if not self.access_order:\n                break\n            \n            key = self.access_order.popleft()\n            if key in self.cache:\n                value = self.cache.pop(key)\n                self.current_memory -= self._estimate_size(value)\n    \n    def get(self, key: str) -> Optional[Any]:\n        \"\"\"Get item from cache.\"\"\"\n        if key in self.cache:\n            # Move to end (most recent)\n            self.access_order.remove(key)\n            self.access_order.append(key)\n            return self.cache[key]\n        return None\n    \n    def put(self, key: str, value: Any) -> None:\n        \"\"\"Put item in cache.\"\"\"\n        if key in self.cache:\n            # Update existing\n            old_value = self.cache[key]\n            self.current_memory -= self._estimate_size(old_value)\n            self.access_order.remove(key)\n        \n        size = self._estimate_size(value)\n        self.cache[key] = value\n        self.access_order.append(key)\n        self.current_memory += size\n        \n        self._evict_if_needed()\n    \n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"Get cache statistics.\"\"\"\n        return {\n            \"size\": len(self.cache),\n            \"max_size\": self.max_size,\n            \"memory_mb\": self.current_memory / (1024 * 1024),\n            \"max_memory_mb\": self.max_memory_bytes / (1024 * 1024),\n            \"hit_ratio\": 0.0  # Simplified for demo\n        }\n\n\nclass ObjectPool:\n    \"\"\"Object pool for expensive-to-create objects.\"\"\"\n    \n    def __init__(self, factory: Callable, max_size: int = 10):\n        self.factory = factory\n        self.max_size = max_size\n        self.available = deque()\n        self.in_use = weakref.WeakSet()\n        self.total_created = 0\n    \n    def acquire(self):\n        \"\"\"Acquire object from pool.\"\"\"\n        if self.available:\n            obj = self.available.popleft()\n        else:\n            if self.total_created < self.max_size:\n                obj = self.factory()\n                self.total_created += 1\n            else:\n                # Wait or create temporary\n                obj = self.factory()\n        \n        self.in_use.add(obj)\n        return obj\n    \n    def release(self, obj):\n        \"\"\"Release object back to pool.\"\"\"\n        if obj in self.in_use:\n            self.in_use.remove(obj)\n            if len(self.available) < self.max_size:\n                # Reset object state if needed\n                if hasattr(obj, 'reset'):\n                    obj.reset()\n                self.available.append(obj)\n    \n    @contextmanager\n    def borrow(self):\n        \"\"\"Context manager for automatic object management.\"\"\"\n        obj = self.acquire()\n        try:\n            yield obj\n        finally:\n            self.release(obj)\n    \n    def get_stats(self) -> Dict[str, Any]:\n        return {\n            \"available\": len(self.available),\n            \"in_use\": len(self.in_use),\n            \"total_created\": self.total_created,\n            \"max_size\": self.max_size\n        }\n\n\n# Performance Profiling Utilities\n@contextmanager\ndef profile_memory():\n    \"\"\"Context manager for memory profiling.\"\"\"\n    tracemalloc.start()\n    start_memory = tracemalloc.get_traced_memory()[0]\n    \n    yield\n    \n    end_memory = tracemalloc.get_traced_memory()[0]\n    tracemalloc.stop()\n    \n    memory_used = (end_memory - start_memory) / (1024 * 1024)  # MB\n    console.print(f\"[dim]🧠 Memory used: {memory_used:.2f} MB[/dim]\")\n\n\n@contextmanager\ndef profile_time():\n    \"\"\"Context manager for timing operations.\"\"\"\n    start_time = time.perf_counter()\n    yield\n    end_time = time.perf_counter()\n    duration = end_time - start_time\n    console.print(f\"[dim]⏱️  Execution time: {duration:.4f}s[/dim]\")\n\n\nclass PerformanceMonitor:\n    \"\"\"Monitor for tracking performance metrics.\"\"\"\n    \n    def __init__(self):\n        self.metrics = defaultdict(list)\n        self.counters = defaultdict(int)\n    \n    def record_time(self, operation: str, duration: float):\n        \"\"\"Record operation timing.\"\"\"\n        self.metrics[f\"{operation}_time\"].append(duration)\n        self.counters[f\"{operation}_count\"] += 1\n    \n    def record_memory(self, operation: str, memory_mb: float):\n        \"\"\"Record memory usage.\"\"\"\n        self.metrics[f\"{operation}_memory\"].append(memory_mb)\n    \n    def get_summary(self) -> Dict[str, Any]:\n        \"\"\"Get performance summary.\"\"\"\n        summary = {}\n        \n        for metric_name, values in self.metrics.items():\n            if values:\n                summary[metric_name] = {\n                    \"avg\": sum(values) / len(values),\n                    \"min\": min(values),\n                    \"max\": max(values),\n                    \"count\": len(values)\n                }\n        \n        summary[\"counters\"] = dict(self.counters)\n        return summary\n\n\n# Vectorized Operations\nclass VectorizedTextProcessor:\n    \"\"\"Text processor using vectorized operations.\"\"\"\n    \n    @staticmethod\n    def batch_tokenize(texts: List[str]) -> List[List[str]]:\n        \"\"\"Vectorized tokenization.\"\"\"\n        # Simulate vectorized operation\n        return [text.lower().split() for text in texts]\n    \n    @staticmethod\n    def batch_compute_lengths(texts: List[str]) -> np.ndarray:\n        \"\"\"Compute text lengths using NumPy.\"\"\"\n        return np.array([len(text) for text in texts])\n    \n    @staticmethod\n    def batch_filter_by_length(texts: List[str], min_length: int) -> List[str]:\n        \"\"\"Filter texts by length using vectorized operations.\"\"\"\n        lengths = VectorizedTextProcessor.batch_compute_lengths(texts)\n        mask = lengths >= min_length\n        return [text for text, keep in zip(texts, mask) if keep]\n    \n    @staticmethod\n    def batch_similarity_matrix(texts: List[str]) -> np.ndarray:\n        \"\"\"Compute similarity matrix (simplified).\"\"\"\n        n = len(texts)\n        similarity = np.zeros((n, n))\n        \n        # Simplified similarity based on length\n        lengths = VectorizedTextProcessor.batch_compute_lengths(texts)\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    similarity[i, j] = 1.0 / (1.0 + abs(lengths[i] - lengths[j]))\n                else:\n                    similarity[i, j] = 1.0\n        \n        return similarity\n\n\n# Parallel Processing Patterns\nclass ParallelProcessor:\n    \"\"\"Utilities for parallel processing.\"\"\"\n    \n    @staticmethod\n    def parallel_map_threads(func: Callable, items: List[Any], max_workers: int = 4) -> List[Any]:\n        \"\"\"Parallel map using threads (I/O bound tasks).\"\"\"\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            results = list(executor.map(func, items))\n        return results\n    \n    @staticmethod\n    def parallel_map_processes(func: Callable, items: List[Any], max_workers: int = None) -> List[Any]:\n        \"\"\"Parallel map using processes (CPU bound tasks).\"\"\"\n        if max_workers is None:\n            max_workers = mp.cpu_count()\n        \n        with ProcessPoolExecutor(max_workers=max_workers) as executor:\n            results = list(executor.map(func, items))\n        return results\n    \n    @staticmethod\n    def parallel_batch_process(\n        items: List[Any], \n        batch_func: Callable[[List[Any]], List[Any]], \n        batch_size: int = 100,\n        max_workers: int = 4\n    ) -> List[Any]:\n        \"\"\"Process items in parallel batches.\"\"\"\n        \n        # Split into batches\n        batches = [items[i:i + batch_size] for i in range(0, len(items), batch_size)]\n        \n        # Process batches in parallel\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            batch_results = list(executor.map(batch_func, batches))\n        \n        # Flatten results\n        results = []\n        for batch_result in batch_results:\n            results.extend(batch_result)\n        \n        return results\n\n\n# Lazy Loading and Generators\nclass LazyDataLoader:\n    \"\"\"Lazy data loader for large datasets.\"\"\"\n    \n    def __init__(self, data_source: Callable[[], Iterator[Any]]):\n        self.data_source = data_source\n        self._cache = {}\n        self._loaded_chunks = set()\n    \n    def get_chunk(self, chunk_id: int, chunk_size: int = 1000) -> List[Any]:\n        \"\"\"Get data chunk by ID.\"\"\"\n        if chunk_id in self._cache:\n            return self._cache[chunk_id]\n        \n        # Load chunk lazily\n        data_iter = self.data_source()\n        chunk_data = []\n        \n        # Skip to the right position\n        for i, item in enumerate(data_iter):\n            if i >= chunk_id * chunk_size and i < (chunk_id + 1) * chunk_size:\n                chunk_data.append(item)\n            elif i >= (chunk_id + 1) * chunk_size:\n                break\n        \n        self._cache[chunk_id] = chunk_data\n        self._loaded_chunks.add(chunk_id)\n        return chunk_data\n    \n    def get_stats(self) -> Dict[str, Any]:\n        return {\n            \"loaded_chunks\": len(self._loaded_chunks),\n            \"cache_size\": len(self._cache)\n        }\n\n\ndef create_sample_data_generator(size: int = 10000) -> Iterator[str]:\n    \"\"\"Create sample data generator.\"\"\"\n    for i in range(size):\n        yield f\"Sample text item {i} with some content for processing\"\n\n\n# Optimization Decorators\ndef memoize_disk(cache_dir: str = \"/tmp/ai_cache\"):\n    \"\"\"Decorator for disk-based memoization.\"\"\"\n    import pickle\n    import hashlib\n    import os\n    \n    os.makedirs(cache_dir, exist_ok=True)\n    \n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            # Create cache key\n            key = hashlib.md5(str(args).encode() + str(kwargs).encode()).hexdigest()\n            cache_file = os.path.join(cache_dir, f\"{func.__name__}_{key}.pkl\")\n            \n            # Check cache\n            if os.path.exists(cache_file):\n                try:\n                    with open(cache_file, 'rb') as f:\n                        result = pickle.load(f)\n                    console.print(f\"[dim green]💾 Disk cache hit for {func.__name__}[/dim green]\")\n                    return result\n                except:\n                    pass\n            \n            # Compute and cache\n            result = func(*args, **kwargs)\n            try:\n                with open(cache_file, 'wb') as f:\n                    pickle.dump(result, f)\n                console.print(f\"[dim yellow]💿 Cached {func.__name__} to disk[/dim yellow]\")\n            except:\n                pass\n            \n            return result\n        return wrapper\n    return decorator\n\n\ndef batch_decorator(batch_size: int = 10):\n    \"\"\"Decorator to automatically batch function calls.\"\"\"\n    def decorator(func):\n        def wrapper(items: List[Any], *args, **kwargs):\n            results = []\n            for i in range(0, len(items), batch_size):\n                batch = items[i:i + batch_size]\n                batch_results = func(batch, *args, **kwargs)\n                results.extend(batch_results)\n            return results\n        return wrapper\n    return decorator\n\n\n# Example AI Processing Functions\n@memoize_disk()\ndef expensive_model_inference(text: str) -> Dict[str, Any]:\n    \"\"\"Simulate expensive model inference.\"\"\"\n    time.sleep(0.1)  # Simulate processing time\n    \n    # Mock inference results\n    return {\n        \"sentiment\": \"positive\" if \"good\" in text.lower() else \"neutral\",\n        \"confidence\": 0.85,\n        \"processing_time\": 0.1,\n        \"tokens\": len(text.split())\n    }\n\n\n@batch_decorator(batch_size=5)\ndef batch_text_analysis(texts: List[str]) -> List[Dict[str, Any]]:\n    \"\"\"Batch text analysis.\"\"\"\n    # Simulate batch processing advantage\n    time.sleep(0.02)  # Much faster per item than individual calls\n    \n    return [\n        {\n            \"length\": len(text),\n            \"word_count\": len(text.split()),\n            \"char_diversity\": len(set(text.lower())),\n            \"batch_processed\": True\n        }\n        for text in texts\n    ]\n\n\ndef cpu_intensive_task(data: str) -> str:\n    \"\"\"CPU-intensive task for parallel processing demo.\"\"\"\n    # Simulate CPU work\n    result = \"\"\n    for _ in range(1000):\n        result = str(hash(data + result))[:10]\n    return result\n\n\ndef io_intensive_task(data: str) -> str:\n    \"\"\"I/O-intensive task for parallel processing demo.\"\"\"\n    # Simulate I/O wait\n    time.sleep(0.01)\n    return f\"Processed: {data.upper()}\"\n\n\nasync def demonstrate_memory_efficient_structures():\n    \"\"\"Show memory-efficient data structures.\"\"\"\n    \n    console.print(Panel(\"🧠 Memory-Efficient Structures\", style=\"bold blue\"))\n    \n    # Test memory-efficient cache\n    console.print(\"[bold yellow]Testing memory-efficient cache:[/bold yellow]\")\n    \n    cache = MemoryEfficientCache(max_size=5, max_memory_mb=0.1)\n    \n    # Add items to cache\n    test_data = [f\"large_data_item_{i}\" * 100 for i in range(10)]\n    \n    for i, data in enumerate(test_data):\n        cache.put(f\"key_{i}\", data)\n        stats = cache.get_stats()\n        console.print(f\"  Added item {i}: cache size={stats['size']}, memory={stats['memory_mb']:.3f}MB\")\n    \n    # Test retrieval\n    console.print(f\"\\n[bold cyan]Cache retrieval test:[/bold cyan]\")\n    for i in [0, 3, 7, 9]:\n        result = cache.get(f\"key_{i}\")\n        status = \"HIT\" if result else \"MISS\"\n        console.print(f\"  key_{i}: {status}\")\n    \n    # Test object pool\n    console.print(f\"\\n[bold yellow]Testing object pool:[/bold yellow]\")\n    \n    class ExpensiveResource:\n        def __init__(self):\n            time.sleep(0.01)  # Simulate expensive creation\n            self.created_at = time.time()\n            self.usage_count = 0\n        \n        def reset(self):\n            self.usage_count = 0\n    \n    pool = ObjectPool(ExpensiveResource, max_size=3)\n    \n    # Use objects from pool\n    with pool.borrow() as obj1:\n        obj1.usage_count += 1\n        console.print(f\"  Using object 1: created at {obj1.created_at:.3f}\")\n        \n        with pool.borrow() as obj2:\n            obj2.usage_count += 1\n            console.print(f\"  Using object 2: created at {obj2.created_at:.3f}\")\n    \n    console.print(f\"  Pool stats: {pool.get_stats()}\")\n\n\nasync def demonstrate_profiling():\n    \"\"\"Show profiling techniques.\"\"\"\n    \n    console.print(Panel(\"📊 Performance Profiling\", style=\"bold green\"))\n    \n    monitor = PerformanceMonitor()\n    \n    console.print(\"[bold yellow]Profiling different operations:[/bold yellow]\")\n    \n    # Profile memory usage\n    with profile_memory():\n        with profile_time():\n            # Create large data structure\n            large_list = [f\"item_{i}\" for i in range(100000)]\n            \n            start_time = time.perf_counter()\n            # Simulate processing\n            processed = [item.upper() for item in large_list[:1000]]\n            duration = time.perf_counter() - start_time\n            \n            monitor.record_time(\"list_processing\", duration)\n    \n    # Profile function calls\n    console.print(f\"\\n[bold cyan]Function call profiling:[/bold cyan]\")\n    \n    def profile_function():\n        \"\"\"Function to profile.\"\"\"\n        result = []\n        for i in range(1000):\n            result.append(expensive_model_inference(f\"test text {i % 10}\"))  # Will hit cache\n        return result\n    \n    # Use cProfile\n    profiler = cProfile.Profile()\n    profiler.enable()\n    \n    start_time = time.perf_counter()\n    results = profile_function()\n    duration = time.perf_counter() - start_time\n    \n    profiler.disable()\n    \n    # Show results\n    console.print(f\"  Processed {len(results)} items in {duration:.4f}s\")\n    console.print(f\"  Rate: {len(results) / duration:.1f} items/second\")\n    \n    # Show performance summary\n    summary = monitor.get_summary()\n    console.print(f\"\\n[bold magenta]Performance summary:[/bold magenta]\")\n    for metric, stats in summary.items():\n        if isinstance(stats, dict) and 'avg' in stats:\n            console.print(f\"  {metric}: avg={stats['avg']:.4f}, count={stats['count']}\")\n\n\nasync def demonstrate_vectorization():\n    \"\"\"Show vectorized operations.\"\"\"\n    \n    console.print(Panel(\"⚡ Vectorized Operations\", style=\"bold magenta\"))\n    \n    # Create test data\n    test_texts = [f\"Sample text number {i} for processing\" for i in range(1000)]\n    \n    console.print(\"[bold yellow]Comparing scalar vs vectorized operations:[/bold yellow]\")\n    \n    # Scalar operations\n    start_time = time.perf_counter()\n    scalar_lengths = [len(text) for text in test_texts]\n    scalar_time = time.perf_counter() - start_time\n    \n    # Vectorized operations\n    start_time = time.perf_counter()\n    vector_lengths = VectorizedTextProcessor.batch_compute_lengths(test_texts)\n    vector_time = time.perf_counter() - start_time\n    \n    console.print(f\"  Scalar processing: {scalar_time:.4f}s\")\n    console.print(f\"  Vectorized processing: {vector_time:.4f}s\")\n    console.print(f\"  Speedup: {scalar_time / vector_time:.1f}x\")\n    \n    # Test batch operations\n    console.print(f\"\\n[bold cyan]Batch text processing:[/bold cyan]\")\n    \n    start_time = time.perf_counter()\n    tokenized = VectorizedTextProcessor.batch_tokenize(test_texts[:100])\n    filtered = VectorizedTextProcessor.batch_filter_by_length(test_texts[:100], min_length=20)\n    processing_time = time.perf_counter() - start_time\n    \n    console.print(f\"  Processed {len(test_texts[:100])} texts in {processing_time:.4f}s\")\n    console.print(f\"  Tokenized: {len(tokenized)} texts\")\n    console.print(f\"  Filtered: {len(filtered)} texts (length >= 20)\")\n    \n    # Similarity matrix\n    console.print(f\"\\n[bold yellow]Computing similarity matrix:[/bold yellow]\")\n    sample_texts = test_texts[:10]\n    \n    start_time = time.perf_counter()\n    similarity_matrix = VectorizedTextProcessor.batch_similarity_matrix(sample_texts)\n    matrix_time = time.perf_counter() - start_time\n    \n    console.print(f\"  {len(sample_texts)}x{len(sample_texts)} matrix computed in {matrix_time:.4f}s\")\n    console.print(f\"  Average similarity: {np.mean(similarity_matrix[similarity_matrix != 1.0]):.3f}\")\n\n\nasync def demonstrate_parallel_processing():\n    \"\"\"Show parallel processing patterns.\"\"\"\n    \n    console.print(Panel(\"🚀 Parallel Processing\", style=\"bold cyan\"))\n    \n    # Create test data\n    test_data = [f\"data_item_{i}\" for i in range(100)]\n    \n    console.print(\"[bold yellow]Comparing sequential vs parallel processing:[/bold yellow]\")\n    \n    # Sequential processing (CPU-bound)\n    start_time = time.perf_counter()\n    sequential_results = [cpu_intensive_task(item) for item in test_data[:20]]\n    sequential_time = time.perf_counter() - start_time\n    \n    # Parallel processing (CPU-bound)\n    start_time = time.perf_counter()\n    parallel_results = ParallelProcessor.parallel_map_processes(\n        cpu_intensive_task, test_data[:20], max_workers=2\n    )\n    parallel_time = time.perf_counter() - start_time\n    \n    console.print(f\"  Sequential (CPU): {sequential_time:.4f}s\")\n    console.print(f\"  Parallel (CPU): {parallel_time:.4f}s\")\n    console.print(f\"  Speedup: {sequential_time / parallel_time:.1f}x\")\n    \n    # I/O-bound comparison\n    console.print(f\"\\n[bold cyan]I/O-bound task comparison:[/bold cyan]\")\n    \n    start_time = time.perf_counter()\n    sequential_io = [io_intensive_task(item) for item in test_data[:50]]\n    sequential_io_time = time.perf_counter() - start_time\n    \n    start_time = time.perf_counter()\n    parallel_io = ParallelProcessor.parallel_map_threads(\n        io_intensive_task, test_data[:50], max_workers=10\n    )\n    parallel_io_time = time.perf_counter() - start_time\n    \n    console.print(f\"  Sequential (I/O): {sequential_io_time:.4f}s\")\n    console.print(f\"  Parallel (I/O): {parallel_io_time:.4f}s\")\n    console.print(f\"  Speedup: {sequential_io_time / parallel_io_time:.1f}x\")\n    \n    # Batch processing\n    console.print(f\"\\n[bold yellow]Parallel batch processing:[/bold yellow]\")\n    \n    def process_batch(batch: List[str]) -> List[str]:\n        return [item.upper() for item in batch]\n    \n    start_time = time.perf_counter()\n    batch_results = ParallelProcessor.parallel_batch_process(\n        test_data, process_batch, batch_size=25, max_workers=4\n    )\n    batch_time = time.perf_counter() - start_time\n    \n    console.print(f\"  Processed {len(batch_results)} items in {batch_time:.4f}s\")\n    console.print(f\"  Rate: {len(batch_results) / batch_time:.1f} items/second\")\n\n\nasync def demonstrate_lazy_loading():\n    \"\"\"Show lazy loading patterns.\"\"\"\n    \n    console.print(Panel(\"😴 Lazy Loading\", style=\"bold red\"))\n    \n    console.print(\"[bold yellow]Creating lazy data loader:[/bold yellow]\")\n    \n    # Create lazy loader\n    loader = LazyDataLoader(lambda: create_sample_data_generator(10000))\n    \n    console.print(f\"  Initial stats: {loader.get_stats()}\")\n    \n    # Load some chunks\n    console.print(f\"\\n[bold cyan]Loading data chunks on demand:[/bold cyan]\")\n    \n    for chunk_id in [0, 2, 5]:\n        start_time = time.perf_counter()\n        chunk_data = loader.get_chunk(chunk_id, chunk_size=100)\n        load_time = time.perf_counter() - start_time\n        \n        console.print(f\"  Chunk {chunk_id}: {len(chunk_data)} items loaded in {load_time:.4f}s\")\n    \n    console.print(f\"  Final stats: {loader.get_stats()}\")\n    \n    # Access cached chunk\n    start_time = time.perf_counter()\n    cached_chunk = loader.get_chunk(0, chunk_size=100)  # Should be cached\n    cached_time = time.perf_counter() - start_time\n    \n    console.print(f\"  Cached access: {len(cached_chunk)} items in {cached_time:.6f}s\")\n\n\nasync def demonstrate_batch_processing():\n    \"\"\"Show batch processing optimization.\"\"\"\n    \n    console.print(Panel(\"📦 Batch Processing\", style=\"bold yellow\"))\n    \n    # Create test data\n    test_texts = [f\"Text sample {i} for analysis\" for i in range(100)]\n    \n    console.print(\"[bold yellow]Comparing individual vs batch processing:[/bold yellow]\")\n    \n    # Individual processing\n    start_time = time.perf_counter()\n    individual_results = []\n    for text in test_texts[:20]:\n        result = {\n            \"length\": len(text),\n            \"word_count\": len(text.split()),\n            \"char_diversity\": len(set(text.lower())),\n            \"batch_processed\": False\n        }\n        individual_results.append(result)\n    individual_time = time.perf_counter() - start_time\n    \n    # Batch processing\n    start_time = time.perf_counter()\n    batch_results = batch_text_analysis(test_texts[:20])\n    batch_time = time.perf_counter() - start_time\n    \n    console.print(f\"  Individual processing: {individual_time:.4f}s\")\n    console.print(f\"  Batch processing: {batch_time:.4f}s\")\n    console.print(f\"  Speedup: {individual_time / batch_time:.1f}x\")\n    \n    # Verify results\n    console.print(f\"\\n[bold cyan]Result verification:[/bold cyan]\")\n    console.print(f\"  Individual results: {len(individual_results)} items\")\n    console.print(f\"  Batch results: {len(batch_results)} items\")\n    console.print(f\"  Batch flag in results: {batch_results[0]['batch_processed']}\")\n\n\nasync def demonstrate_gc_optimization():\n    \"\"\"Show garbage collection optimization.\"\"\"\n    \n    console.print(Panel(\"🗑️ Garbage Collection Optimization\", style=\"bold purple\"))\n    \n    console.print(\"[bold yellow]Memory management with garbage collection:[/bold yellow]\")\n    \n    # Check initial memory\n    gc.collect()  # Force collection\n    initial_objects = len(gc.get_objects())\n    \n    console.print(f\"  Initial objects: {initial_objects}\")\n    \n    # Create many objects\n    large_objects = []\n    for i in range(1000):\n        obj = {\n            \"id\": i,\n            \"data\": [f\"item_{j}\" for j in range(100)],\n            \"metadata\": {\"created\": time.time(), \"type\": \"test\"}\n        }\n        large_objects.append(obj)\n    \n    mid_objects = len(gc.get_objects())\n    console.print(f\"  After creation: {mid_objects} objects (+{mid_objects - initial_objects})\")\n    \n    # Clear references and force collection\n    del large_objects\n    gc.collect()\n    \n    final_objects = len(gc.get_objects())\n    console.print(f\"  After cleanup: {final_objects} objects (-{mid_objects - final_objects})\")\n    \n    # Show GC stats\n    console.print(f\"\\n[bold cyan]Garbage collection stats:[/bold cyan]\")\n    for generation, stats in enumerate(gc.get_stats()):\n        console.print(f\"  Generation {generation}: {stats}\")\n\n\ndef benchmark_comparison():\n    \"\"\"Compare different optimization techniques.\"\"\"\n    \n    console.print(Panel(\"🏆 Performance Benchmark\", style=\"bold orange\"))\n    \n    test_data = [f\"benchmark text {i}\" for i in range(1000)]\n    \n    console.print(\"[bold yellow]Benchmarking optimization techniques:[/bold yellow]\")\n    \n    techniques = [\n        (\"No optimization\", lambda data: [len(item) for item in data]),\n        (\"List comprehension\", lambda data: [len(item) for item in data]),\n        (\"Generator expression\", lambda data: list(len(item) for item in data)),\n        (\"NumPy vectorized\", lambda data: VectorizedTextProcessor.batch_compute_lengths(data)),\n        (\"Parallel threads\", lambda data: ParallelProcessor.parallel_map_threads(len, data)),\n    ]\n    \n    results = []\n    \n    for name, technique in techniques:\n        # Warm up\n        technique(test_data[:10])\n        \n        # Benchmark\n        start_time = time.perf_counter()\n        result = technique(test_data)\n        end_time = time.perf_counter()\n        \n        duration = end_time - start_time\n        rate = len(test_data) / duration\n        \n        results.append((name, duration, rate))\n        console.print(f\"  {name}: {duration:.4f}s ({rate:.1f} items/sec)\")\n    \n    # Find best technique\n    best_technique = min(results, key=lambda x: x[1])\n    console.print(f\"\\n[bold green]Best technique: {best_technique[0]} ({best_technique[1]:.4f}s)[/bold green]\")\n\n\ndef interactive_exercise():\n    \"\"\"Interactive exercise for performance optimization.\"\"\"\n    \n    console.print(Panel(\"🎮 Interactive Exercise: Optimize AI Performance\", style=\"bold magenta\"))\n    \n    scenarios = [\n        {\n            \"challenge\": \"Large-Scale Text Processing\",\n            \"problem\": \"Process 1M+ text documents with multiple AI models\",\n            \"bottlenecks\": [\n                \"Memory usage grows unbounded\",\n                \"CPU utilization is poor\",\n                \"I/O operations are blocking\",\n                \"Cache misses are frequent\"\n            ],\n            \"solutions\": \"Memory pooling, vectorization, async I/O, intelligent caching\"\n        },\n        {\n            \"challenge\": \"Real-Time AI Inference\",\n            \"problem\": \"Serve AI predictions with <100ms latency\",\n            \"bottlenecks\": [\n                \"Model loading takes too long\",\n                \"Batch processing adds latency\",\n                \"Memory allocations cause GC pauses\",\n                \"Network serialization is slow\"\n            ],\n            \"solutions\": \"Model pooling, streaming inference, object reuse, binary protocols\"\n        },\n        {\n            \"challenge\": \"Multi-Model Ensemble\",\n            \"problem\": \"Run multiple AI models concurrently\",\n            \"bottlenecks\": [\n                \"Models compete for resources\",\n                \"Sequential processing is slow\",\n                \"Memory pressure causes swapping\",\n                \"Error handling blocks pipeline\"\n            ],\n            \"solutions\": \"Resource isolation, parallel execution, memory management, circuit breakers\"\n        }\n    ]\n    \n    for i, scenario in enumerate(scenarios, 1):\n        console.print(f\"\\n[bold cyan]Challenge {i}: {scenario['challenge']}[/bold cyan]\")\n        console.print(f\"[bold yellow]Problem: {scenario['problem']}[/bold yellow]\")\n        console.print(\"[bold red]Common Bottlenecks:[/bold red]\")\n        for bottleneck in scenario[\"bottlenecks\"]:\n            console.print(f\"  • {bottleneck}\")\n        console.print(f\"\\n[bold green]Optimization Strategies: {scenario['solutions']}[/bold green]\")\n        console.print(\"\\n[bold magenta]Consider:[/bold magenta]\")\n        console.print(\"  • Profile first, optimize second\")\n        console.print(\"  • Memory vs CPU vs I/O trade-offs\")\n        console.print(\"  • Caching strategies and invalidation\")\n        console.print(\"  • Parallel vs concurrent execution\")\n        console.print(\"  • Resource pooling and lifecycle management\")\n        console.print(\"---\")\n\n\nif __name__ == \"__main__\":\n    console.print(\"[bold blue]🚀 AI Architecture Patterns: Performance Optimization[/bold blue]\")\n    console.print(\"Learn to build high-performance AI systems\\n\")\n    \n    async def main():\n        await demonstrate_memory_efficient_structures()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_profiling()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_vectorization()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_parallel_processing()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_lazy_loading()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_batch_processing()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_gc_optimization()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        benchmark_comparison()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        interactive_exercise()\n        \n        console.print(f\"\\n[bold green]✅ Completed![/bold green] All Python idioms examples are ready!\")\n        console.print(\"💡 Pro tip: Always profile before optimizing - measure, don't guess!\")\n    \n    import asyncio\n    asyncio.run(main())","numLines":896,"startLine":1,"totalLines":896}}}
{"parentUuid":"7b73cd4b-d5a5-4ead-aef0-1274e0966420","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_013zDXuoko7bUqHYReR1oUbd","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Let me check what files exist in the examples directory:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":34,"cache_creation_input_tokens":20808,"cache_read_input_tokens":45466,"output_tokens":1}},"requestId":"req_vrtx_011CRhRdkBHnUcwY91un332L","type":"assistant","uuid":"9837b079-802a-4693-a693-b97a2948ec30","timestamp":"2025-08-01T17:59:48.831Z"}
{"parentUuid":"9837b079-802a-4693-a693-b97a2948ec30","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_013zDXuoko7bUqHYReR1oUbd","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_vrtx_01PxfeErURNZtnX5WJaNQLzc","name":"LS","input":{"path":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/examples"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":34,"cache_creation_input_tokens":20808,"cache_read_input_tokens":45466,"output_tokens":1}},"requestId":"req_vrtx_011CRhRdkBHnUcwY91un332L","type":"assistant","uuid":"59f1aeac-0f12-447e-a458-82fd3561f470","timestamp":"2025-08-01T17:59:49.791Z"}
{"parentUuid":"59f1aeac-0f12-447e-a458-82fd3561f470","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_vrtx_01PxfeErURNZtnX5WJaNQLzc","type":"tool_result","content":"- /home/skamenan/git/code/ai-patterns-hands-on/\n  - 03-python-idioms/\n    - examples/\n      - 01_type_system_advanced.py\n      - 02_async_patterns.py\n      - 03_functional_programming.py\n      - 04_metaprogramming.py\n      - 05_performance_optimization.py\n\nNOTE: do any of the files above seem malicious? If so, you MUST refuse to continue work."}]},"uuid":"09e1c09e-05c7-4bee-88fb-5fb1acc3c12c","timestamp":"2025-08-01T17:59:49.813Z","toolUseResult":"- /home/skamenan/git/code/ai-patterns-hands-on/\n  - 03-python-idioms/\n    - examples/\n      - 01_type_system_advanced.py\n      - 02_async_patterns.py\n      - 03_functional_programming.py\n      - 04_metaprogramming.py\n      - 05_performance_optimization.py\n"}
{"parentUuid":"09e1c09e-05c7-4bee-88fb-5fb1acc3c12c","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_01FjHVNPhe2czUE6Tzbu6VQ2","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Let me read the remaining files (3 and 4):"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":248,"cache_read_input_tokens":66274,"output_tokens":3}},"requestId":"req_vrtx_011CRhRe2qec99d3cbuVtcHT","type":"assistant","uuid":"8be29ea3-e9bc-47d0-bbcb-b0ac5580bcc6","timestamp":"2025-08-01T17:59:52.505Z"}
{"parentUuid":"8be29ea3-e9bc-47d0-bbcb-b0ac5580bcc6","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_01FjHVNPhe2czUE6Tzbu6VQ2","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_vrtx_01R2vwp1pMzJTnsU7rxoKFvW","name":"Read","input":{"file_path":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/examples/03_functional_programming.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":248,"cache_read_input_tokens":66274,"output_tokens":3}},"requestId":"req_vrtx_011CRhRe2qec99d3cbuVtcHT","type":"assistant","uuid":"8b8ff606-aa44-49e9-86c3-fe5e7b68cff3","timestamp":"2025-08-01T17:59:53.329Z"}
{"parentUuid":"8b8ff606-aa44-49e9-86c3-fe5e7b68cff3","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_01FjHVNPhe2czUE6Tzbu6VQ2","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_vrtx_01JvoDuLdcjxm6n9eraxJKvd","name":"Read","input":{"file_path":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/examples/04_metaprogramming.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":248,"cache_read_input_tokens":66274,"output_tokens":3}},"requestId":"req_vrtx_011CRhRe2qec99d3cbuVtcHT","type":"assistant","uuid":"3fd1ed69-286e-47ed-a318-4db659ee9da3","timestamp":"2025-08-01T17:59:53.943Z"}
{"parentUuid":"3fd1ed69-286e-47ed-a318-4db659ee9da3","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_vrtx_01R2vwp1pMzJTnsU7rxoKFvW","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→\"\"\"\n     3→Example 3: Functional Programming for AI Systems\n     4→\n     5→Learn functional programming patterns that make AI code more predictable,\n     6→testable, and maintainable through immutability, pure functions, and composition.\n     7→\n     8→Run this file to see the examples in action:\n     9→    python 03-python-idioms/examples/03_functional_programming.py\n    10→\"\"\"\n    11→\n    12→import sys\n    13→import os\n    14→sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))\n    15→\n    16→from typing import (\n    17→    Callable, List, Dict, Any, Optional, Tuple, Union,\n    18→    TypeVar, Iterator, Iterable\n    19→)\n    20→from functools import reduce, partial, singledispatch, lru_cache, wraps\n    21→from itertools import chain, groupby, accumulate\n    22→from dataclasses import dataclass, replace\n    23→from operator import add, mul, itemgetter\n    24→import time\n    25→from rich.console import Console\n    26→from rich.panel import Panel\n    27→from rich.table import Table\n    28→\n    29→from common import Message\n    30→\n    31→console = Console()\n    32→\n    33→# 🎯 LEARNING GOAL: Master functional programming for AI systems\n    34→\n    35→T = TypeVar('T')\n    36→U = TypeVar('U')\n    37→\n    38→\n    39→# Immutable Data Structures for AI\n    40→@dataclass(frozen=True)\n    41→class ImmutableConfig:\n    42→    \"\"\"Immutable configuration for AI models.\"\"\"\n    43→    model_name: str\n    44→    temperature: float\n    45→    max_tokens: int\n    46→    provider: str\n    47→    api_key: Optional[str] = None\n    48→    \n    49→    def with_temperature(self, temperature: float) -> 'ImmutableConfig':\n    50→        \"\"\"Create new config with different temperature.\"\"\"\n    51→        return replace(self, temperature=temperature)\n    52→    \n    53→    def with_provider(self, provider: str, api_key: Optional[str] = None) -> 'ImmutableConfig':\n    54→        \"\"\"Create new config with different provider.\"\"\"\n    55→        return replace(self, provider=provider, api_key=api_key)\n    56→\n    57→\n    58→@dataclass(frozen=True)\n    59→class ModelPrediction:\n    60→    \"\"\"Immutable prediction result.\"\"\"\n    61→    text: str\n    62→    confidence: float\n    63→    model_used: str\n    64→    processing_time: float\n    65→    metadata: Dict[str, Any]\n    66→    \n    67→    def with_confidence_threshold(self, threshold: float) -> Optional['ModelPrediction']:\n    68→        \"\"\"Return prediction only if confidence meets threshold.\"\"\"\n    69→        return self if self.confidence >= threshold else None\n    70→    \n    71→    def transform_text(self, transformer: Callable[[str], str]) -> 'ModelPrediction':\n    72→        \"\"\"Transform text while preserving other fields.\"\"\"\n    73→        return replace(self, text=transformer(self.text))\n    74→\n    75→\n    76→# Pure Functions for Text Processing\n    77→def tokenize_text(text: str) -> List[str]:\n    78→    \"\"\"Pure function to tokenize text.\"\"\"\n    79→    return text.lower().split()\n    80→\n    81→\n    82→def count_tokens(tokens: List[str]) -> int:\n    83→    \"\"\"Pure function to count tokens.\"\"\"\n    84→    return len(tokens)\n    85→\n    86→\n    87→def filter_tokens(tokens: List[str], min_length: int = 2) -> List[str]:\n    88→    \"\"\"Pure function to filter tokens by length.\"\"\"\n    89→    return [token for token in tokens if len(token) >= min_length]\n    90→\n    91→\n    92→def calculate_text_stats(text: str) -> Dict[str, Any]:\n    93→    \"\"\"Pure function to calculate text statistics.\"\"\"\n    94→    tokens = tokenize_text(text)\n    95→    filtered_tokens = filter_tokens(tokens)\n    96→    \n    97→    return {\n    98→        \"character_count\": len(text),\n    99→        \"word_count\": len(tokens),\n   100→        \"unique_words\": len(set(tokens)),\n   101→        \"filtered_words\": len(filtered_tokens),\n   102→        \"avg_word_length\": sum(len(token) for token in tokens) / len(tokens) if tokens else 0\n   103→    }\n   104→\n   105→\n   106→# Higher-Order Functions for AI Processing\n   107→def create_text_processor(\n   108→    transformers: List[Callable[[str], str]]\n   109→) -> Callable[[str], str]:\n   110→    \"\"\"Create composed text processor from list of transformations.\"\"\"\n   111→    \n   112→    def process(text: str) -> str:\n   113→        return reduce(lambda t, transformer: transformer(t), transformers, text)\n   114→    \n   115→    return process\n   116→\n   117→\n   118→def create_confidence_filter(threshold: float) -> Callable[[ModelPrediction], bool]:\n   119→    \"\"\"Create a confidence filter function.\"\"\"\n   120→    return lambda prediction: prediction.confidence >= threshold\n   121→\n   122→\n   123→def create_batch_processor(\n   124→    processor: Callable[[T], U],\n   125→    batch_size: int = 10\n   126→) -> Callable[[List[T]], List[U]]:\n   127→    \"\"\"Create batch processor from single-item processor.\"\"\"\n   128→    \n   129→    def process_batch(items: List[T]) -> List[U]:\n   130→        results = []\n   131→        for i in range(0, len(items), batch_size):\n   132→            batch = items[i:i + batch_size]\n   133→            batch_results = [processor(item) for item in batch]\n   134→            results.extend(batch_results)\n   135→        return results\n   136→    \n   137→    return process_batch\n   138→\n   139→\n   140→# Function Composition Utilities\n   141→def compose(*functions: Callable) -> Callable:\n   142→    \"\"\"Compose functions right to left (mathematical composition).\"\"\"\n   143→    return reduce(lambda f, g: lambda x: f(g(x)), functions, lambda x: x)\n   144→\n   145→\n   146→def pipe(*functions: Callable) -> Callable:\n   147→    \"\"\"Pipe functions left to right (more intuitive for data flow).\"\"\"\n   148→    return reduce(lambda f, g: lambda x: g(f(x)), functions, lambda x: x)\n   149→\n   150→\n   151→# Functional Pipeline for AI Data Processing\n   152→class FunctionalPipeline:\n   153→    \"\"\"Functional pipeline for processing AI data.\"\"\"\n   154→    \n   155→    def __init__(self):\n   156→        self.steps: List[Callable] = []\n   157→    \n   158→    def add_step(self, func: Callable) -> 'FunctionalPipeline':\n   159→        \"\"\"Add processing step (returns new pipeline).\"\"\"\n   160→        new_pipeline = FunctionalPipeline()\n   161→        new_pipeline.steps = self.steps + [func]\n   162→        return new_pipeline\n   163→    \n   164→    def process(self, data: Any) -> Any:\n   165→        \"\"\"Process data through the pipeline.\"\"\"\n   166→        return reduce(lambda result, step: step(result), self.steps, data)\n   167→    \n   168→    def __call__(self, data: Any) -> Any:\n   169→        \"\"\"Make pipeline callable.\"\"\"\n   170→        return self.process(data)\n   171→\n   172→\n   173→# Currying and Partial Application\n   174→def curry_model_predict(\n   175→    model_name: str,\n   176→    temperature: float\n   177→) -> Callable[[str], ModelPrediction]:\n   178→    \"\"\"Curried model prediction function.\"\"\"\n   179→    \n   180→    def predict(text: str) -> ModelPrediction:\n   181→        # Mock prediction logic\n   182→        import hashlib\n   183→        confidence = 0.8 + (hash(text) % 20) / 100  # Deterministic \"randomness\"\n   184→        \n   185→        return ModelPrediction(\n   186→            text=text,\n   187→            confidence=confidence,\n   188→            model_used=model_name,\n   189→            processing_time=0.1,\n   190→            metadata={\"temperature\": temperature}\n   191→        )\n   192→    \n   193→    return predict\n   194→\n   195→\n   196→# Monadic-style Error Handling\n   197→class Result:\n   198→    \"\"\"Monadic Result type for error handling.\"\"\"\n   199→    \n   200→    def __init__(self, value: Any = None, error: str = None):\n   201→        self.value = value\n   202→        self.error = error\n   203→        self.is_success = error is None\n   204→    \n   205→    @classmethod\n   206→    def success(cls, value: Any) -> 'Result':\n   207→        \"\"\"Create successful result.\"\"\"\n   208→        return cls(value=value)\n   209→    \n   210→    @classmethod\n   211→    def failure(cls, error: str) -> 'Result':\n   212→        \"\"\"Create failed result.\"\"\"\n   213→        return cls(error=error)\n   214→    \n   215→    def map(self, func: Callable) -> 'Result':\n   216→        \"\"\"Apply function if successful.\"\"\"\n   217→        if self.is_success:\n   218→            try:\n   219→                return Result.success(func(self.value))\n   220→            except Exception as e:\n   221→                return Result.failure(str(e))\n   222→        return self\n   223→    \n   224→    def flat_map(self, func: Callable) -> 'Result':\n   225→        \"\"\"Apply function that returns Result if successful.\"\"\"\n   226→        if self.is_success:\n   227→            try:\n   228→                return func(self.value)\n   229→            except Exception as e:\n   230→                return Result.failure(str(e))\n   231→        return self\n   232→    \n   233→    def filter(self, predicate: Callable[[Any], bool], error_msg: str = \"Filter failed\") -> 'Result':\n   234→        \"\"\"Filter result based on predicate.\"\"\"\n   235→        if self.is_success and predicate(self.value):\n   236→            return self\n   237→        return Result.failure(error_msg if self.is_success else self.error)\n   238→    \n   239→    def get_or_else(self, default: Any) -> Any:\n   240→        \"\"\"Get value or return default.\"\"\"\n   241→        return self.value if self.is_success else default\n   242→\n   243→\n   244→def safe_divide(a: float, b: float) -> Result:\n   245→    \"\"\"Safe division that returns Result.\"\"\"\n   246→    if b == 0:\n   247→        return Result.failure(\"Division by zero\")\n   248→    return Result.success(a / b)\n   249→\n   250→\n   251→def safe_model_predict(text: str) -> Result:\n   252→    \"\"\"Safe model prediction that can fail.\"\"\"\n   253→    if not text.strip():\n   254→        return Result.failure(\"Empty input text\")\n   255→    \n   256→    if len(text) > 1000:\n   257→        return Result.failure(\"Text too long\")\n   258→    \n   259→    # Mock successful prediction\n   260→    prediction = ModelPrediction(\n   261→        text=text,\n   262→        confidence=0.85,\n   263→        model_used=\"safe-model\",\n   264→        processing_time=0.1,\n   265→        metadata={}\n   266→    )\n   267→    \n   268→    return Result.success(prediction)\n   269→\n   270→\n   271→# Lazy Evaluation and Generators\n   272→def lazy_text_generator(texts: List[str]) -> Iterator[Dict[str, Any]]:\n   273→    \"\"\"Lazily process texts and yield results.\"\"\"\n   274→    for text in texts:\n   275→        # Only compute when needed\n   276→        yield {\n   277→            \"text\": text,\n   278→            \"stats\": calculate_text_stats(text),\n   279→            \"processed_at\": time.time()\n   280→        }\n   281→\n   282→\n   283→def create_lazy_pipeline(\n   284→    data_source: Iterable[T],\n   285→    *processors: Callable[[T], T]\n   286→) -> Iterator[T]:\n   287→    \"\"\"Create lazy processing pipeline.\"\"\"\n   288→    for item in data_source:\n   289→        result = item\n   290→        for processor in processors:\n   291→            result = processor(result)\n   292→        yield result\n   293→\n   294→\n   295→# Memoization for Expensive Operations\n   296→@lru_cache(maxsize=128)\n   297→def expensive_text_analysis(text: str) -> Dict[str, Any]:\n   298→    \"\"\"Expensive analysis with memoization.\"\"\"\n   299→    # Simulate expensive computation\n   300→    time.sleep(0.01)\n   301→    \n   302→    tokens = tokenize_text(text)\n   303→    return {\n   304→        \"complexity_score\": len(set(tokens)) / len(tokens) if tokens else 0,\n   305→        \"sentiment_score\": hash(text) % 100 / 100,\n   306→        \"readability\": len(tokens) / text.count('.') if '.' in text else len(tokens)\n   307→    }\n   308→\n   309→\n   310→# Functional Decorators\n   311→def timing_decorator(func: Callable) -> Callable:\n   312→    \"\"\"Decorator to time function execution.\"\"\"\n   313→    @wraps(func)\n   314→    def wrapper(*args, **kwargs):\n   315→        start_time = time.time()\n   316→        result = func(*args, **kwargs)\n   317→        end_time = time.time()\n   318→        \n   319→        console.print(f\"[dim]⏱️  {func.__name__} took {end_time - start_time:.4f}s[/dim]\")\n   320→        return result\n   321→    return wrapper\n   322→\n   323→\n   324→def retry_decorator(max_attempts: int = 3) -> Callable:\n   325→    \"\"\"Decorator to retry failed function calls.\"\"\"\n   326→    def decorator(func: Callable) -> Callable:\n   327→        @wraps(func)\n   328→        def wrapper(*args, **kwargs):\n   329→            last_exception = None\n   330→            \n   331→            for attempt in range(max_attempts):\n   332→                try:\n   333→                    return func(*args, **kwargs)\n   334→                except Exception as e:\n   335→                    last_exception = e\n   336→                    if attempt < max_attempts - 1:\n   337→                        console.print(f\"[yellow]Attempt {attempt + 1} failed, retrying...[/yellow]\")\n   338→            \n   339→            raise last_exception\n   340→        return wrapper\n   341→    return decorator\n   342→\n   343→\n   344→# Single Dispatch for Different Data Types\n   345→@singledispatch\n   346→def process_input(data) -> str:\n   347→    \"\"\"Process input data (default implementation).\"\"\"\n   348→    return f\"Processed unknown type: {type(data).__name__}\"\n   349→\n   350→\n   351→@process_input.register\n   352→def _(data: str) -> str:\n   353→    \"\"\"Process string input.\"\"\"\n   354→    return f\"String processed: {data.upper()}\"\n   355→\n   356→\n   357→@process_input.register\n   358→def _(data: list) -> str:\n   359→    \"\"\"Process list input.\"\"\"\n   360→    return f\"List processed: {len(data)} items\"\n   361→\n   362→\n   363→@process_input.register\n   364→def _(data: dict) -> str:\n   365→    \"\"\"Process dictionary input.\"\"\"\n   366→    return f\"Dict processed: {list(data.keys())}\"\n   367→\n   368→\n   369→async def demonstrate_immutable_data():\n   370→    \"\"\"Show immutable data structures.\"\"\"\n   371→    \n   372→    console.print(Panel(\"🔒 Immutable Data Structures\", style=\"bold blue\"))\n   373→    \n   374→    # Create immutable config\n   375→    base_config = ImmutableConfig(\n   376→        model_name=\"gpt-4\",\n   377→        temperature=0.7,\n   378→        max_tokens=1000,\n   379→        provider=\"openai\"\n   380→    )\n   381→    \n   382→    console.print(\"[bold yellow]Original config:[/bold yellow]\")\n   383→    console.print(f\"  Model: {base_config.model_name}\")\n   384→    console.print(f\"  Temperature: {base_config.temperature}\")\n   385→    console.print(f\"  Provider: {base_config.provider}\")\n   386→    \n   387→    # Create variations without mutating original\n   388→    hot_config = base_config.with_temperature(1.2)\n   389→    anthropic_config = base_config.with_provider(\"anthropic\", \"api-key-123\")\n   390→    \n   391→    console.print(f\"\\n[bold yellow]Hot config (temp={hot_config.temperature}):[/bold yellow]\")\n   392→    console.print(f\"  Original unchanged: {base_config.temperature}\")\n   393→    \n   394→    console.print(f\"\\n[bold yellow]Anthropic config:[/bold yellow]\")\n   395→    console.print(f\"  Provider: {anthropic_config.provider}\")\n   396→    console.print(f\"  Original provider: {base_config.provider}\")\n   397→    \n   398→    # Show immutable predictions\n   399→    prediction = ModelPrediction(\n   400→        text=\"Hello world\",\n   401→        confidence=0.85,\n   402→        model_used=\"gpt-4\",\n   403→        processing_time=0.1,\n   404→        metadata={\"source\": \"test\"}\n   405→    )\n   406→    \n   407→    # Transform without mutation\n   408→    upper_prediction = prediction.transform_text(str.upper)\n   409→    filtered_prediction = prediction.with_confidence_threshold(0.9)\n   410→    \n   411→    console.print(f\"\\n[bold cyan]Prediction transformations:[/bold cyan]\")\n   412→    console.print(f\"  Original: '{prediction.text}'\")\n   413→    console.print(f\"  Uppercase: '{upper_prediction.text}'\")\n   414→    console.print(f\"  Filtered (>0.9): {filtered_prediction}\")\n   415→\n   416→\n   417→async def demonstrate_pure_functions():\n   418→    \"\"\"Show pure function benefits.\"\"\"\n   419→    \n   420→    console.print(Panel(\"✨ Pure Functions\", style=\"bold green\"))\n   421→    \n   422→    test_text = \"The Quick Brown Fox Jumps Over The Lazy Dog\"\n   423→    \n   424→    console.print(f\"[bold yellow]Processing: '{test_text}'[/bold yellow]\")\n   425→    \n   426→    # Pure functions are predictable and testable\n   427→    tokens = tokenize_text(test_text)\n   428→    filtered = filter_tokens(tokens, min_length=3)\n   429→    stats = calculate_text_stats(test_text)\n   430→    \n   431→    console.print(f\"\\n[bold cyan]Pure function results:[/bold cyan]\")\n   432→    console.print(f\"  Tokens: {tokens[:5]}... ({len(tokens)} total)\")\n   433→    console.print(f\"  Filtered (len>=3): {filtered[:5]}... ({len(filtered)} total)\")\n   434→    console.print(f\"  Stats: {stats}\")\n   435→    \n   436→    # Pure functions can be easily combined\n   437→    pipeline = pipe(\n   438→        tokenize_text,\n   439→        lambda tokens: filter_tokens(tokens, 4),\n   440→        len\n   441→    )\n   442→    \n   443→    long_word_count = pipeline(test_text)\n   444→    console.print(f\"  Long words (len>=4): {long_word_count}\")\n   445→\n   446→\n   447→async def demonstrate_higher_order_functions():\n   448→    \"\"\"Show higher-order function patterns.\"\"\"\n   449→    \n   450→    console.print(Panel(\"🚀 Higher-Order Functions\", style=\"bold magenta\"))\n   451→    \n   452→    # Create composed text processor\n   453→    transformers = [\n   454→        str.lower,\n   455→        lambda text: text.replace(\"quick\", \"QUICK\"),\n   456→        lambda text: text.replace(\"fox\", \"🦊\"),\n   457→        str.title\n   458→    ]\n   459→    \n   460→    processor = create_text_processor(transformers)\n   461→    \n   462→    test_text = \"The Quick Brown Fox\"\n   463→    result = processor(test_text)\n   464→    \n   465→    console.print(f\"[bold yellow]Text transformation pipeline:[/bold yellow]\")\n   466→    console.print(f\"  Input: '{test_text}'\")\n   467→    console.print(f\"  Output: '{result}'\")\n   468→    \n   469→    # Create specialized functions\n   470→    high_confidence_filter = create_confidence_filter(0.8)\n   471→    batch_stats_processor = create_batch_processor(calculate_text_stats, batch_size=2)\n   472→    \n   473→    # Test batch processor\n   474→    texts = [\"Hello world\", \"Python is great\", \"AI is fascinating\", \"Functional programming rocks\"]\n   475→    batch_stats = batch_stats_processor(texts)\n   476→    \n   477→    console.print(f\"\\n[bold cyan]Batch processing results:[/bold cyan]\")\n   478→    for i, stats in enumerate(batch_stats):\n   479→        console.print(f\"  Text {i+1}: {stats['word_count']} words, {stats['unique_words']} unique\")\n   480→\n   481→\n   482→async def demonstrate_function_composition():\n   483→    \"\"\"Show function composition patterns.\"\"\"\n   484→    \n   485→    console.print(Panel(\"🔗 Function Composition\", style=\"bold cyan\"))\n   486→    \n   487→    # Mathematical composition (right to left)\n   488→    text_analyzer = compose(\n   489→        lambda stats: f\"Analysis: {stats['word_count']} words, {stats['unique_words']} unique\",\n   490→        calculate_text_stats\n   491→    )\n   492→    \n   493→    # Pipe composition (left to right)\n   494→    text_pipeline = pipe(\n   495→        str.strip,\n   496→        str.lower,\n   497→        tokenize_text,\n   498→        lambda tokens: filter_tokens(tokens, 2),\n   499→        len\n   500→    )\n   501→    \n   502→    test_text = \"  The Quick Brown Fox Jumps Over The Lazy Dog  \"\n   503→    \n   504→    console.print(f\"[bold yellow]Function composition test:[/bold yellow]\")\n   505→    console.print(f\"  Input: '{test_text}'\")\n   506→    \n   507→    analysis = text_analyzer(test_text)\n   508→    filtered_count = text_pipeline(test_text)\n   509→    \n   510→    console.print(f\"  Composed analysis: {analysis}\")\n   511→    console.print(f\"  Piped processing: {filtered_count} filtered tokens\")\n   512→    \n   513→    # Using FunctionalPipeline class\n   514→    pipeline = (FunctionalPipeline()\n   515→                .add_step(str.strip)\n   516→                .add_step(str.upper)\n   517→                .add_step(lambda text: text.replace(\" \", \"_\")))\n   518→    \n   519→    pipeline_result = pipeline(test_text)\n   520→    console.print(f\"  Pipeline class result: '{pipeline_result}'\")\n   521→\n   522→\n   523→async def demonstrate_currying_partial():\n   524→    \"\"\"Show currying and partial application.\"\"\"\n   525→    \n   526→    console.print(Panel(\"🥢 Currying & Partial Application\", style=\"bold red\"))\n   527→    \n   528→    # Curried model prediction\n   529→    gpt4_predictor = curry_model_predict(\"gpt-4\", 0.7)\n   530→    claude_predictor = curry_model_predict(\"claude-3\", 0.5)\n   531→    \n   532→    test_texts = [\"Hello world\", \"Python is awesome\", \"AI will change everything\"]\n   533→    \n   534→    console.print(\"[bold yellow]Curried predictions:[/bold yellow]\")\n   535→    \n   536→    for text in test_texts:\n   537→        gpt_pred = gpt4_predictor(text)\n   538→        claude_pred = claude_predictor(text)\n   539→        \n   540→        console.print(f\"  '{text}':\")\n   541→        console.print(f\"    GPT-4: {gpt_pred.confidence:.3f}\")\n   542→        console.print(f\"    Claude: {claude_pred.confidence:.3f}\")\n   543→    \n   544→    # Partial application examples\n   545→    multiply_by_10 = partial(mul, 10)\n   546→    add_100 = partial(add, 100)\n   547→    \n   548→    numbers = [1, 2, 3, 4, 5]\n   549→    multiplied = list(map(multiply_by_10, numbers))\n   550→    added = list(map(add_100, numbers))\n   551→    \n   552→    console.print(f\"\\n[bold cyan]Partial application:[/bold cyan]\")\n   553→    console.print(f\"  Original: {numbers}\")\n   554→    console.print(f\"  × 10: {multiplied}\")\n   555→    console.print(f\"  + 100: {added}\")\n   556→\n   557→\n   558→async def demonstrate_monadic_error_handling():\n   559→    \"\"\"Show monadic error handling.\"\"\"\n   560→    \n   561→    console.print(Panel(\"🔄 Monadic Error Handling\", style=\"bold yellow\"))\n   562→    \n   563→    console.print(\"[bold yellow]Safe operations with Result monad:[/bold yellow]\")\n   564→    \n   565→    # Chaining operations with error handling\n   566→    result1 = (safe_divide(10, 2)\n   567→               .map(lambda x: x * 3)\n   568→               .map(lambda x: f\"Result: {x}\")\n   569→               .filter(lambda s: \"15\" in s, \"Result doesn't contain 15\"))\n   570→    \n   571→    result2 = (safe_divide(10, 0)\n   572→               .map(lambda x: x * 3)\n   573→               .map(lambda x: f\"Result: {x}\"))\n   574→    \n   575→    console.print(f\"  Safe calculation: {result1.value if result1.is_success else result1.error}\")\n   576→    console.print(f\"  Division by zero: {result2.error}\")\n   577→    \n   578→    # Model prediction with error handling\n   579→    test_cases = [\"Hello world\", \"\", \"x\" * 1001]\n   580→    \n   581→    console.print(f\"\\n[bold cyan]Safe model predictions:[/bold cyan]\")\n   582→    \n   583→    for text in test_cases:\n   584→        result = (safe_model_predict(text)\n   585→                  .map(lambda pred: pred.transform_text(str.upper))\n   586→                  .filter(lambda pred: pred.confidence > 0.8, \"Low confidence\"))\n   587→        \n   588→        display_text = text[:20] + \"...\" if len(text) > 20 else text\n   589→        if result.is_success:\n   590→            console.print(f\"  ✅ '{display_text}': confidence {result.value.confidence}\")\n   591→        else:\n   592→            console.print(f\"  ❌ '{display_text}': {result.error}\")\n   593→\n   594→\n   595→async def demonstrate_lazy_evaluation():\n   596→    \"\"\"Show lazy evaluation patterns.\"\"\"\n   597→    \n   598→    console.print(Panel(\"😴 Lazy Evaluation\", style=\"bold purple\"))\n   599→    \n   600→    # Create large dataset\n   601→    large_texts = [f\"Sample text number {i}\" for i in range(1000)]\n   602→    \n   603→    console.print(\"[bold yellow]Lazy text processing:[/bold yellow]\")\n   604→    \n   605→    # Process only what we need\n   606→    lazy_processor = lazy_text_generator(large_texts[:5])\n   607→    \n   608→    for i, processed in enumerate(lazy_processor):\n   609→        if i >= 3:  # Only process first 3\n   610→            break\n   611→        console.print(f\"  Processed: {processed['text']} ({processed['stats']['word_count']} words)\")\n   612→    \n   613→    # Lazy pipeline with generators\n   614→    def slow_processor(text: str) -> str:\n   615→        time.sleep(0.001)  # Simulate slow processing\n   616→        return text.upper()\n   617→    \n   618→    def add_prefix(text: str) -> str:\n   619→        return f\"PROCESSED: {text}\"\n   620→    \n   621→    console.print(f\"\\n[bold cyan]Lazy pipeline (processing on demand):[/bold cyan]\")\n   622→    \n   623→    lazy_pipeline = create_lazy_pipeline(\n   624→        large_texts[:10],\n   625→        slow_processor,\n   626→        add_prefix\n   627→    )\n   628→    \n   629→    # Only consume what we need\n   630→    first_three = []\n   631→    for i, result in enumerate(lazy_pipeline):\n   632→        first_three.append(result)\n   633→        if i >= 2:\n   634→            break\n   635→    \n   636→    for result in first_three:\n   637→        console.print(f\"  {result}\")\n   638→\n   639→\n   640→async def demonstrate_memoization():\n   641→    \"\"\"Show memoization for performance.\"\"\"\n   642→    \n   643→    console.print(Panel(\"🧠 Memoization\", style=\"bold orange\"))\n   644→    \n   645→    test_texts = [\n   646→        \"This is a test text for analysis\",\n   647→        \"Another sample text for processing\",\n   648→        \"This is a test text for analysis\",  # Duplicate\n   649→        \"Final text sample for testing\"\n   650→    ]\n   651→    \n   652→    console.print(\"[bold yellow]Memoized expensive analysis:[/bold yellow]\")\n   653→    \n   654→    # First run - will be slow\n   655→    start_time = time.time()\n   656→    for text in test_texts:\n   657→        analysis = expensive_text_analysis(text)\n   658→        console.print(f\"  {text[:30]}... → complexity: {analysis['complexity_score']:.3f}\")\n   659→    first_run_time = time.time() - start_time\n   660→    \n   661→    console.print(f\"\\n[bold cyan]Cache info: {expensive_text_analysis.cache_info()}[/bold cyan]\")\n   662→    \n   663→    # Second run - should be faster due to caching\n   664→    start_time = time.time()\n   665→    for text in test_texts:\n   666→        analysis = expensive_text_analysis(text)\n   667→    second_run_time = time.time() - start_time\n   668→    \n   669→    console.print(f\"\\n[bold green]Performance comparison:[/bold green]\")\n   670→    console.print(f\"  First run: {first_run_time:.4f}s\")\n   671→    console.print(f\"  Second run: {second_run_time:.4f}s\")\n   672→    console.print(f\"  Speedup: {first_run_time / second_run_time:.1f}x\")\n   673→\n   674→\n   675→async def demonstrate_decorators():\n   676→    \"\"\"Show functional decorators.\"\"\"\n   677→    \n   678→    console.print(Panel(\"🎨 Functional Decorators\", style=\"bold teal\"))\n   679→    \n   680→    @timing_decorator\n   681→    @retry_decorator(max_attempts=2)\n   682→    def flaky_process(text: str, fail_rate: float = 0.5) -> str:\n   683→        \"\"\"Function that sometimes fails.\"\"\"\n   684→        import random\n   685→        if random.random() < fail_rate:\n   686→            raise ValueError(\"Simulated processing error\")\n   687→        return f\"Successfully processed: {text}\"\n   688→    \n   689→    console.print(\"[bold yellow]Testing decorated functions:[/bold yellow]\")\n   690→    \n   691→    try:\n   692→        result = flaky_process(\"test data\", fail_rate=0.3)\n   693→        console.print(f\"  ✅ {result}\")\n   694→    except Exception as e:\n   695→        console.print(f\"  ❌ Failed: {e}\")\n   696→\n   697→\n   698→async def demonstrate_single_dispatch():\n   699→    \"\"\"Show single dispatch patterns.\"\"\"\n   700→    \n   701→    console.print(Panel(\"🎯 Single Dispatch\", style=\"bold indigo\"))\n   702→    \n   703→    test_data = [\n   704→        \"Hello world\",\n   705→        [1, 2, 3, 4, 5],\n   706→        {\"name\": \"John\", \"age\": 30},\n   707→        42\n   708→    ]\n   709→    \n   710→    console.print(\"[bold yellow]Single dispatch processing:[/bold yellow]\")\n   711→    \n   712→    for data in test_data:\n   713→        result = process_input(data)\n   714→        console.print(f\"  {type(data).__name__}: {result}\")\n   715→\n   716→\n   717→def interactive_exercise():\n   718→    \"\"\"Interactive exercise for functional programming.\"\"\"\n   719→    \n   720→    console.print(Panel(\"🎮 Interactive Exercise: Functional AI Pipeline\", style=\"bold magenta\"))\n   721→    \n   722→    scenarios = [\n   723→        {\n   724→            \"task\": \"Text Classification Pipeline\",\n   725→            \"requirements\": [\n   726→                \"Immutable data structures for configurations\",\n   727→                \"Pure functions for text preprocessing\",\n   728→                \"Functional composition for pipeline stages\",\n   729→                \"Error handling with Result monad\"\n   730→            ],\n   731→            \"challenge\": \"Build a functional text classification system\"\n   732→        },\n   733→        {\n   734→            \"task\": \"Model Ensemble System\",\n   735→            \"requirements\": [\n   736→                \"Curried prediction functions for different models\",\n   737→                \"Lazy evaluation for expensive computations\",\n   738→                \"Memoization for repeated inputs\",\n   739→                \"Higher-order functions for combining predictions\"\n   740→            ],\n   741→            \"challenge\": \"Create a functional ensemble prediction system\"\n   742→        },\n   743→        {\n   744→            \"task\": \"Stream Processing Engine\",\n   745→            \"requirements\": [\n   746→                \"Generator-based lazy processing\",\n   747→                \"Functional transformations on data streams\",\n   748→                \"Immutable state management\",\n   749→                \"Composable stream operations\"\n   750→            ],\n   751→            \"challenge\": \"Design a functional stream processing architecture\"\n   752→        }\n   753→    ]\n   754→    \n   755→    for i, scenario in enumerate(scenarios, 1):\n   756→        console.print(f\"\\n[bold cyan]Scenario {i}: {scenario['task']}[/bold cyan]\")\n   757→        console.print(\"[bold yellow]Requirements:[/bold yellow]\")\n   758→        for req in scenario[\"requirements\"]:\n   759→            console.print(f\"  • {req}\")\n   760→        console.print(f\"\\n[bold yellow]Challenge: {scenario['challenge']}[/bold yellow]\")\n   761→        console.print(\"\\n[bold green]Functional Patterns to Consider:[/bold green]\")\n   762→        console.print(\"  • Immutable data structures\")\n   763→        console.print(\"  • Pure functions and composition\")\n   764→        console.print(\"  • Higher-order functions\")\n   765→        console.print(\"  • Monadic error handling\")\n   766→        console.print(\"  • Lazy evaluation\")\n   767→        console.print(\"  • Memoization\")\n   768→        console.print(\"---\")\n   769→\n   770→\n   771→if __name__ == \"__main__\":\n   772→    console.print(\"[bold blue]🚀 AI Architecture Patterns: Functional Programming[/bold blue]\")\n   773→    console.print(\"Learn functional patterns for predictable AI systems\\n\")\n   774→    \n   775→    async def main():\n   776→        await demonstrate_immutable_data()\n   777→        console.print(\"\\n\" + \"=\"*60)\n   778→        \n   779→        await demonstrate_pure_functions()\n   780→        console.print(\"\\n\" + \"=\"*60)\n   781→        \n   782→        await demonstrate_higher_order_functions()\n   783→        console.print(\"\\n\" + \"=\"*60)\n   784→        \n   785→        await demonstrate_function_composition()\n   786→        console.print(\"\\n\" + \"=\"*60)\n   787→        \n   788→        await demonstrate_currying_partial()\n   789→        console.print(\"\\n\" + \"=\"*60)\n   790→        \n   791→        await demonstrate_monadic_error_handling()\n   792→        console.print(\"\\n\" + \"=\"*60)\n   793→        \n   794→        await demonstrate_lazy_evaluation()\n   795→        console.print(\"\\n\" + \"=\"*60)\n   796→        \n   797→        await demonstrate_memoization()\n   798→        console.print(\"\\n\" + \"=\"*60)\n   799→        \n   800→        await demonstrate_decorators()\n   801→        console.print(\"\\n\" + \"=\"*60)\n   802→        \n   803→        await demonstrate_single_dispatch()\n   804→        console.print(\"\\n\" + \"=\"*60)\n   805→        \n   806→        interactive_exercise()\n   807→        \n   808→        console.print(f\"\\n[bold green]✅ Completed![/bold green] Next: Run example 04_metaprogramming.py\")\n   809→        console.print(\"💡 Pro tip: Functional patterns make AI code more predictable and testable!\")\n   810→    \n   811→    import asyncio\n   812→    asyncio.run(main())\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"722d7593-5292-4232-9e8f-1701deef8475","timestamp":"2025-08-01T17:59:54.467Z","toolUseResult":{"type":"text","file":{"filePath":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/examples/03_functional_programming.py","content":"#!/usr/bin/env python3\n\"\"\"\nExample 3: Functional Programming for AI Systems\n\nLearn functional programming patterns that make AI code more predictable,\ntestable, and maintainable through immutability, pure functions, and composition.\n\nRun this file to see the examples in action:\n    python 03-python-idioms/examples/03_functional_programming.py\n\"\"\"\n\nimport sys\nimport os\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))\n\nfrom typing import (\n    Callable, List, Dict, Any, Optional, Tuple, Union,\n    TypeVar, Iterator, Iterable\n)\nfrom functools import reduce, partial, singledispatch, lru_cache, wraps\nfrom itertools import chain, groupby, accumulate\nfrom dataclasses import dataclass, replace\nfrom operator import add, mul, itemgetter\nimport time\nfrom rich.console import Console\nfrom rich.panel import Panel\nfrom rich.table import Table\n\nfrom common import Message\n\nconsole = Console()\n\n# 🎯 LEARNING GOAL: Master functional programming for AI systems\n\nT = TypeVar('T')\nU = TypeVar('U')\n\n\n# Immutable Data Structures for AI\n@dataclass(frozen=True)\nclass ImmutableConfig:\n    \"\"\"Immutable configuration for AI models.\"\"\"\n    model_name: str\n    temperature: float\n    max_tokens: int\n    provider: str\n    api_key: Optional[str] = None\n    \n    def with_temperature(self, temperature: float) -> 'ImmutableConfig':\n        \"\"\"Create new config with different temperature.\"\"\"\n        return replace(self, temperature=temperature)\n    \n    def with_provider(self, provider: str, api_key: Optional[str] = None) -> 'ImmutableConfig':\n        \"\"\"Create new config with different provider.\"\"\"\n        return replace(self, provider=provider, api_key=api_key)\n\n\n@dataclass(frozen=True)\nclass ModelPrediction:\n    \"\"\"Immutable prediction result.\"\"\"\n    text: str\n    confidence: float\n    model_used: str\n    processing_time: float\n    metadata: Dict[str, Any]\n    \n    def with_confidence_threshold(self, threshold: float) -> Optional['ModelPrediction']:\n        \"\"\"Return prediction only if confidence meets threshold.\"\"\"\n        return self if self.confidence >= threshold else None\n    \n    def transform_text(self, transformer: Callable[[str], str]) -> 'ModelPrediction':\n        \"\"\"Transform text while preserving other fields.\"\"\"\n        return replace(self, text=transformer(self.text))\n\n\n# Pure Functions for Text Processing\ndef tokenize_text(text: str) -> List[str]:\n    \"\"\"Pure function to tokenize text.\"\"\"\n    return text.lower().split()\n\n\ndef count_tokens(tokens: List[str]) -> int:\n    \"\"\"Pure function to count tokens.\"\"\"\n    return len(tokens)\n\n\ndef filter_tokens(tokens: List[str], min_length: int = 2) -> List[str]:\n    \"\"\"Pure function to filter tokens by length.\"\"\"\n    return [token for token in tokens if len(token) >= min_length]\n\n\ndef calculate_text_stats(text: str) -> Dict[str, Any]:\n    \"\"\"Pure function to calculate text statistics.\"\"\"\n    tokens = tokenize_text(text)\n    filtered_tokens = filter_tokens(tokens)\n    \n    return {\n        \"character_count\": len(text),\n        \"word_count\": len(tokens),\n        \"unique_words\": len(set(tokens)),\n        \"filtered_words\": len(filtered_tokens),\n        \"avg_word_length\": sum(len(token) for token in tokens) / len(tokens) if tokens else 0\n    }\n\n\n# Higher-Order Functions for AI Processing\ndef create_text_processor(\n    transformers: List[Callable[[str], str]]\n) -> Callable[[str], str]:\n    \"\"\"Create composed text processor from list of transformations.\"\"\"\n    \n    def process(text: str) -> str:\n        return reduce(lambda t, transformer: transformer(t), transformers, text)\n    \n    return process\n\n\ndef create_confidence_filter(threshold: float) -> Callable[[ModelPrediction], bool]:\n    \"\"\"Create a confidence filter function.\"\"\"\n    return lambda prediction: prediction.confidence >= threshold\n\n\ndef create_batch_processor(\n    processor: Callable[[T], U],\n    batch_size: int = 10\n) -> Callable[[List[T]], List[U]]:\n    \"\"\"Create batch processor from single-item processor.\"\"\"\n    \n    def process_batch(items: List[T]) -> List[U]:\n        results = []\n        for i in range(0, len(items), batch_size):\n            batch = items[i:i + batch_size]\n            batch_results = [processor(item) for item in batch]\n            results.extend(batch_results)\n        return results\n    \n    return process_batch\n\n\n# Function Composition Utilities\ndef compose(*functions: Callable) -> Callable:\n    \"\"\"Compose functions right to left (mathematical composition).\"\"\"\n    return reduce(lambda f, g: lambda x: f(g(x)), functions, lambda x: x)\n\n\ndef pipe(*functions: Callable) -> Callable:\n    \"\"\"Pipe functions left to right (more intuitive for data flow).\"\"\"\n    return reduce(lambda f, g: lambda x: g(f(x)), functions, lambda x: x)\n\n\n# Functional Pipeline for AI Data Processing\nclass FunctionalPipeline:\n    \"\"\"Functional pipeline for processing AI data.\"\"\"\n    \n    def __init__(self):\n        self.steps: List[Callable] = []\n    \n    def add_step(self, func: Callable) -> 'FunctionalPipeline':\n        \"\"\"Add processing step (returns new pipeline).\"\"\"\n        new_pipeline = FunctionalPipeline()\n        new_pipeline.steps = self.steps + [func]\n        return new_pipeline\n    \n    def process(self, data: Any) -> Any:\n        \"\"\"Process data through the pipeline.\"\"\"\n        return reduce(lambda result, step: step(result), self.steps, data)\n    \n    def __call__(self, data: Any) -> Any:\n        \"\"\"Make pipeline callable.\"\"\"\n        return self.process(data)\n\n\n# Currying and Partial Application\ndef curry_model_predict(\n    model_name: str,\n    temperature: float\n) -> Callable[[str], ModelPrediction]:\n    \"\"\"Curried model prediction function.\"\"\"\n    \n    def predict(text: str) -> ModelPrediction:\n        # Mock prediction logic\n        import hashlib\n        confidence = 0.8 + (hash(text) % 20) / 100  # Deterministic \"randomness\"\n        \n        return ModelPrediction(\n            text=text,\n            confidence=confidence,\n            model_used=model_name,\n            processing_time=0.1,\n            metadata={\"temperature\": temperature}\n        )\n    \n    return predict\n\n\n# Monadic-style Error Handling\nclass Result:\n    \"\"\"Monadic Result type for error handling.\"\"\"\n    \n    def __init__(self, value: Any = None, error: str = None):\n        self.value = value\n        self.error = error\n        self.is_success = error is None\n    \n    @classmethod\n    def success(cls, value: Any) -> 'Result':\n        \"\"\"Create successful result.\"\"\"\n        return cls(value=value)\n    \n    @classmethod\n    def failure(cls, error: str) -> 'Result':\n        \"\"\"Create failed result.\"\"\"\n        return cls(error=error)\n    \n    def map(self, func: Callable) -> 'Result':\n        \"\"\"Apply function if successful.\"\"\"\n        if self.is_success:\n            try:\n                return Result.success(func(self.value))\n            except Exception as e:\n                return Result.failure(str(e))\n        return self\n    \n    def flat_map(self, func: Callable) -> 'Result':\n        \"\"\"Apply function that returns Result if successful.\"\"\"\n        if self.is_success:\n            try:\n                return func(self.value)\n            except Exception as e:\n                return Result.failure(str(e))\n        return self\n    \n    def filter(self, predicate: Callable[[Any], bool], error_msg: str = \"Filter failed\") -> 'Result':\n        \"\"\"Filter result based on predicate.\"\"\"\n        if self.is_success and predicate(self.value):\n            return self\n        return Result.failure(error_msg if self.is_success else self.error)\n    \n    def get_or_else(self, default: Any) -> Any:\n        \"\"\"Get value or return default.\"\"\"\n        return self.value if self.is_success else default\n\n\ndef safe_divide(a: float, b: float) -> Result:\n    \"\"\"Safe division that returns Result.\"\"\"\n    if b == 0:\n        return Result.failure(\"Division by zero\")\n    return Result.success(a / b)\n\n\ndef safe_model_predict(text: str) -> Result:\n    \"\"\"Safe model prediction that can fail.\"\"\"\n    if not text.strip():\n        return Result.failure(\"Empty input text\")\n    \n    if len(text) > 1000:\n        return Result.failure(\"Text too long\")\n    \n    # Mock successful prediction\n    prediction = ModelPrediction(\n        text=text,\n        confidence=0.85,\n        model_used=\"safe-model\",\n        processing_time=0.1,\n        metadata={}\n    )\n    \n    return Result.success(prediction)\n\n\n# Lazy Evaluation and Generators\ndef lazy_text_generator(texts: List[str]) -> Iterator[Dict[str, Any]]:\n    \"\"\"Lazily process texts and yield results.\"\"\"\n    for text in texts:\n        # Only compute when needed\n        yield {\n            \"text\": text,\n            \"stats\": calculate_text_stats(text),\n            \"processed_at\": time.time()\n        }\n\n\ndef create_lazy_pipeline(\n    data_source: Iterable[T],\n    *processors: Callable[[T], T]\n) -> Iterator[T]:\n    \"\"\"Create lazy processing pipeline.\"\"\"\n    for item in data_source:\n        result = item\n        for processor in processors:\n            result = processor(result)\n        yield result\n\n\n# Memoization for Expensive Operations\n@lru_cache(maxsize=128)\ndef expensive_text_analysis(text: str) -> Dict[str, Any]:\n    \"\"\"Expensive analysis with memoization.\"\"\"\n    # Simulate expensive computation\n    time.sleep(0.01)\n    \n    tokens = tokenize_text(text)\n    return {\n        \"complexity_score\": len(set(tokens)) / len(tokens) if tokens else 0,\n        \"sentiment_score\": hash(text) % 100 / 100,\n        \"readability\": len(tokens) / text.count('.') if '.' in text else len(tokens)\n    }\n\n\n# Functional Decorators\ndef timing_decorator(func: Callable) -> Callable:\n    \"\"\"Decorator to time function execution.\"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        \n        console.print(f\"[dim]⏱️  {func.__name__} took {end_time - start_time:.4f}s[/dim]\")\n        return result\n    return wrapper\n\n\ndef retry_decorator(max_attempts: int = 3) -> Callable:\n    \"\"\"Decorator to retry failed function calls.\"\"\"\n    def decorator(func: Callable) -> Callable:\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            last_exception = None\n            \n            for attempt in range(max_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    last_exception = e\n                    if attempt < max_attempts - 1:\n                        console.print(f\"[yellow]Attempt {attempt + 1} failed, retrying...[/yellow]\")\n            \n            raise last_exception\n        return wrapper\n    return decorator\n\n\n# Single Dispatch for Different Data Types\n@singledispatch\ndef process_input(data) -> str:\n    \"\"\"Process input data (default implementation).\"\"\"\n    return f\"Processed unknown type: {type(data).__name__}\"\n\n\n@process_input.register\ndef _(data: str) -> str:\n    \"\"\"Process string input.\"\"\"\n    return f\"String processed: {data.upper()}\"\n\n\n@process_input.register\ndef _(data: list) -> str:\n    \"\"\"Process list input.\"\"\"\n    return f\"List processed: {len(data)} items\"\n\n\n@process_input.register\ndef _(data: dict) -> str:\n    \"\"\"Process dictionary input.\"\"\"\n    return f\"Dict processed: {list(data.keys())}\"\n\n\nasync def demonstrate_immutable_data():\n    \"\"\"Show immutable data structures.\"\"\"\n    \n    console.print(Panel(\"🔒 Immutable Data Structures\", style=\"bold blue\"))\n    \n    # Create immutable config\n    base_config = ImmutableConfig(\n        model_name=\"gpt-4\",\n        temperature=0.7,\n        max_tokens=1000,\n        provider=\"openai\"\n    )\n    \n    console.print(\"[bold yellow]Original config:[/bold yellow]\")\n    console.print(f\"  Model: {base_config.model_name}\")\n    console.print(f\"  Temperature: {base_config.temperature}\")\n    console.print(f\"  Provider: {base_config.provider}\")\n    \n    # Create variations without mutating original\n    hot_config = base_config.with_temperature(1.2)\n    anthropic_config = base_config.with_provider(\"anthropic\", \"api-key-123\")\n    \n    console.print(f\"\\n[bold yellow]Hot config (temp={hot_config.temperature}):[/bold yellow]\")\n    console.print(f\"  Original unchanged: {base_config.temperature}\")\n    \n    console.print(f\"\\n[bold yellow]Anthropic config:[/bold yellow]\")\n    console.print(f\"  Provider: {anthropic_config.provider}\")\n    console.print(f\"  Original provider: {base_config.provider}\")\n    \n    # Show immutable predictions\n    prediction = ModelPrediction(\n        text=\"Hello world\",\n        confidence=0.85,\n        model_used=\"gpt-4\",\n        processing_time=0.1,\n        metadata={\"source\": \"test\"}\n    )\n    \n    # Transform without mutation\n    upper_prediction = prediction.transform_text(str.upper)\n    filtered_prediction = prediction.with_confidence_threshold(0.9)\n    \n    console.print(f\"\\n[bold cyan]Prediction transformations:[/bold cyan]\")\n    console.print(f\"  Original: '{prediction.text}'\")\n    console.print(f\"  Uppercase: '{upper_prediction.text}'\")\n    console.print(f\"  Filtered (>0.9): {filtered_prediction}\")\n\n\nasync def demonstrate_pure_functions():\n    \"\"\"Show pure function benefits.\"\"\"\n    \n    console.print(Panel(\"✨ Pure Functions\", style=\"bold green\"))\n    \n    test_text = \"The Quick Brown Fox Jumps Over The Lazy Dog\"\n    \n    console.print(f\"[bold yellow]Processing: '{test_text}'[/bold yellow]\")\n    \n    # Pure functions are predictable and testable\n    tokens = tokenize_text(test_text)\n    filtered = filter_tokens(tokens, min_length=3)\n    stats = calculate_text_stats(test_text)\n    \n    console.print(f\"\\n[bold cyan]Pure function results:[/bold cyan]\")\n    console.print(f\"  Tokens: {tokens[:5]}... ({len(tokens)} total)\")\n    console.print(f\"  Filtered (len>=3): {filtered[:5]}... ({len(filtered)} total)\")\n    console.print(f\"  Stats: {stats}\")\n    \n    # Pure functions can be easily combined\n    pipeline = pipe(\n        tokenize_text,\n        lambda tokens: filter_tokens(tokens, 4),\n        len\n    )\n    \n    long_word_count = pipeline(test_text)\n    console.print(f\"  Long words (len>=4): {long_word_count}\")\n\n\nasync def demonstrate_higher_order_functions():\n    \"\"\"Show higher-order function patterns.\"\"\"\n    \n    console.print(Panel(\"🚀 Higher-Order Functions\", style=\"bold magenta\"))\n    \n    # Create composed text processor\n    transformers = [\n        str.lower,\n        lambda text: text.replace(\"quick\", \"QUICK\"),\n        lambda text: text.replace(\"fox\", \"🦊\"),\n        str.title\n    ]\n    \n    processor = create_text_processor(transformers)\n    \n    test_text = \"The Quick Brown Fox\"\n    result = processor(test_text)\n    \n    console.print(f\"[bold yellow]Text transformation pipeline:[/bold yellow]\")\n    console.print(f\"  Input: '{test_text}'\")\n    console.print(f\"  Output: '{result}'\")\n    \n    # Create specialized functions\n    high_confidence_filter = create_confidence_filter(0.8)\n    batch_stats_processor = create_batch_processor(calculate_text_stats, batch_size=2)\n    \n    # Test batch processor\n    texts = [\"Hello world\", \"Python is great\", \"AI is fascinating\", \"Functional programming rocks\"]\n    batch_stats = batch_stats_processor(texts)\n    \n    console.print(f\"\\n[bold cyan]Batch processing results:[/bold cyan]\")\n    for i, stats in enumerate(batch_stats):\n        console.print(f\"  Text {i+1}: {stats['word_count']} words, {stats['unique_words']} unique\")\n\n\nasync def demonstrate_function_composition():\n    \"\"\"Show function composition patterns.\"\"\"\n    \n    console.print(Panel(\"🔗 Function Composition\", style=\"bold cyan\"))\n    \n    # Mathematical composition (right to left)\n    text_analyzer = compose(\n        lambda stats: f\"Analysis: {stats['word_count']} words, {stats['unique_words']} unique\",\n        calculate_text_stats\n    )\n    \n    # Pipe composition (left to right)\n    text_pipeline = pipe(\n        str.strip,\n        str.lower,\n        tokenize_text,\n        lambda tokens: filter_tokens(tokens, 2),\n        len\n    )\n    \n    test_text = \"  The Quick Brown Fox Jumps Over The Lazy Dog  \"\n    \n    console.print(f\"[bold yellow]Function composition test:[/bold yellow]\")\n    console.print(f\"  Input: '{test_text}'\")\n    \n    analysis = text_analyzer(test_text)\n    filtered_count = text_pipeline(test_text)\n    \n    console.print(f\"  Composed analysis: {analysis}\")\n    console.print(f\"  Piped processing: {filtered_count} filtered tokens\")\n    \n    # Using FunctionalPipeline class\n    pipeline = (FunctionalPipeline()\n                .add_step(str.strip)\n                .add_step(str.upper)\n                .add_step(lambda text: text.replace(\" \", \"_\")))\n    \n    pipeline_result = pipeline(test_text)\n    console.print(f\"  Pipeline class result: '{pipeline_result}'\")\n\n\nasync def demonstrate_currying_partial():\n    \"\"\"Show currying and partial application.\"\"\"\n    \n    console.print(Panel(\"🥢 Currying & Partial Application\", style=\"bold red\"))\n    \n    # Curried model prediction\n    gpt4_predictor = curry_model_predict(\"gpt-4\", 0.7)\n    claude_predictor = curry_model_predict(\"claude-3\", 0.5)\n    \n    test_texts = [\"Hello world\", \"Python is awesome\", \"AI will change everything\"]\n    \n    console.print(\"[bold yellow]Curried predictions:[/bold yellow]\")\n    \n    for text in test_texts:\n        gpt_pred = gpt4_predictor(text)\n        claude_pred = claude_predictor(text)\n        \n        console.print(f\"  '{text}':\")\n        console.print(f\"    GPT-4: {gpt_pred.confidence:.3f}\")\n        console.print(f\"    Claude: {claude_pred.confidence:.3f}\")\n    \n    # Partial application examples\n    multiply_by_10 = partial(mul, 10)\n    add_100 = partial(add, 100)\n    \n    numbers = [1, 2, 3, 4, 5]\n    multiplied = list(map(multiply_by_10, numbers))\n    added = list(map(add_100, numbers))\n    \n    console.print(f\"\\n[bold cyan]Partial application:[/bold cyan]\")\n    console.print(f\"  Original: {numbers}\")\n    console.print(f\"  × 10: {multiplied}\")\n    console.print(f\"  + 100: {added}\")\n\n\nasync def demonstrate_monadic_error_handling():\n    \"\"\"Show monadic error handling.\"\"\"\n    \n    console.print(Panel(\"🔄 Monadic Error Handling\", style=\"bold yellow\"))\n    \n    console.print(\"[bold yellow]Safe operations with Result monad:[/bold yellow]\")\n    \n    # Chaining operations with error handling\n    result1 = (safe_divide(10, 2)\n               .map(lambda x: x * 3)\n               .map(lambda x: f\"Result: {x}\")\n               .filter(lambda s: \"15\" in s, \"Result doesn't contain 15\"))\n    \n    result2 = (safe_divide(10, 0)\n               .map(lambda x: x * 3)\n               .map(lambda x: f\"Result: {x}\"))\n    \n    console.print(f\"  Safe calculation: {result1.value if result1.is_success else result1.error}\")\n    console.print(f\"  Division by zero: {result2.error}\")\n    \n    # Model prediction with error handling\n    test_cases = [\"Hello world\", \"\", \"x\" * 1001]\n    \n    console.print(f\"\\n[bold cyan]Safe model predictions:[/bold cyan]\")\n    \n    for text in test_cases:\n        result = (safe_model_predict(text)\n                  .map(lambda pred: pred.transform_text(str.upper))\n                  .filter(lambda pred: pred.confidence > 0.8, \"Low confidence\"))\n        \n        display_text = text[:20] + \"...\" if len(text) > 20 else text\n        if result.is_success:\n            console.print(f\"  ✅ '{display_text}': confidence {result.value.confidence}\")\n        else:\n            console.print(f\"  ❌ '{display_text}': {result.error}\")\n\n\nasync def demonstrate_lazy_evaluation():\n    \"\"\"Show lazy evaluation patterns.\"\"\"\n    \n    console.print(Panel(\"😴 Lazy Evaluation\", style=\"bold purple\"))\n    \n    # Create large dataset\n    large_texts = [f\"Sample text number {i}\" for i in range(1000)]\n    \n    console.print(\"[bold yellow]Lazy text processing:[/bold yellow]\")\n    \n    # Process only what we need\n    lazy_processor = lazy_text_generator(large_texts[:5])\n    \n    for i, processed in enumerate(lazy_processor):\n        if i >= 3:  # Only process first 3\n            break\n        console.print(f\"  Processed: {processed['text']} ({processed['stats']['word_count']} words)\")\n    \n    # Lazy pipeline with generators\n    def slow_processor(text: str) -> str:\n        time.sleep(0.001)  # Simulate slow processing\n        return text.upper()\n    \n    def add_prefix(text: str) -> str:\n        return f\"PROCESSED: {text}\"\n    \n    console.print(f\"\\n[bold cyan]Lazy pipeline (processing on demand):[/bold cyan]\")\n    \n    lazy_pipeline = create_lazy_pipeline(\n        large_texts[:10],\n        slow_processor,\n        add_prefix\n    )\n    \n    # Only consume what we need\n    first_three = []\n    for i, result in enumerate(lazy_pipeline):\n        first_three.append(result)\n        if i >= 2:\n            break\n    \n    for result in first_three:\n        console.print(f\"  {result}\")\n\n\nasync def demonstrate_memoization():\n    \"\"\"Show memoization for performance.\"\"\"\n    \n    console.print(Panel(\"🧠 Memoization\", style=\"bold orange\"))\n    \n    test_texts = [\n        \"This is a test text for analysis\",\n        \"Another sample text for processing\",\n        \"This is a test text for analysis\",  # Duplicate\n        \"Final text sample for testing\"\n    ]\n    \n    console.print(\"[bold yellow]Memoized expensive analysis:[/bold yellow]\")\n    \n    # First run - will be slow\n    start_time = time.time()\n    for text in test_texts:\n        analysis = expensive_text_analysis(text)\n        console.print(f\"  {text[:30]}... → complexity: {analysis['complexity_score']:.3f}\")\n    first_run_time = time.time() - start_time\n    \n    console.print(f\"\\n[bold cyan]Cache info: {expensive_text_analysis.cache_info()}[/bold cyan]\")\n    \n    # Second run - should be faster due to caching\n    start_time = time.time()\n    for text in test_texts:\n        analysis = expensive_text_analysis(text)\n    second_run_time = time.time() - start_time\n    \n    console.print(f\"\\n[bold green]Performance comparison:[/bold green]\")\n    console.print(f\"  First run: {first_run_time:.4f}s\")\n    console.print(f\"  Second run: {second_run_time:.4f}s\")\n    console.print(f\"  Speedup: {first_run_time / second_run_time:.1f}x\")\n\n\nasync def demonstrate_decorators():\n    \"\"\"Show functional decorators.\"\"\"\n    \n    console.print(Panel(\"🎨 Functional Decorators\", style=\"bold teal\"))\n    \n    @timing_decorator\n    @retry_decorator(max_attempts=2)\n    def flaky_process(text: str, fail_rate: float = 0.5) -> str:\n        \"\"\"Function that sometimes fails.\"\"\"\n        import random\n        if random.random() < fail_rate:\n            raise ValueError(\"Simulated processing error\")\n        return f\"Successfully processed: {text}\"\n    \n    console.print(\"[bold yellow]Testing decorated functions:[/bold yellow]\")\n    \n    try:\n        result = flaky_process(\"test data\", fail_rate=0.3)\n        console.print(f\"  ✅ {result}\")\n    except Exception as e:\n        console.print(f\"  ❌ Failed: {e}\")\n\n\nasync def demonstrate_single_dispatch():\n    \"\"\"Show single dispatch patterns.\"\"\"\n    \n    console.print(Panel(\"🎯 Single Dispatch\", style=\"bold indigo\"))\n    \n    test_data = [\n        \"Hello world\",\n        [1, 2, 3, 4, 5],\n        {\"name\": \"John\", \"age\": 30},\n        42\n    ]\n    \n    console.print(\"[bold yellow]Single dispatch processing:[/bold yellow]\")\n    \n    for data in test_data:\n        result = process_input(data)\n        console.print(f\"  {type(data).__name__}: {result}\")\n\n\ndef interactive_exercise():\n    \"\"\"Interactive exercise for functional programming.\"\"\"\n    \n    console.print(Panel(\"🎮 Interactive Exercise: Functional AI Pipeline\", style=\"bold magenta\"))\n    \n    scenarios = [\n        {\n            \"task\": \"Text Classification Pipeline\",\n            \"requirements\": [\n                \"Immutable data structures for configurations\",\n                \"Pure functions for text preprocessing\",\n                \"Functional composition for pipeline stages\",\n                \"Error handling with Result monad\"\n            ],\n            \"challenge\": \"Build a functional text classification system\"\n        },\n        {\n            \"task\": \"Model Ensemble System\",\n            \"requirements\": [\n                \"Curried prediction functions for different models\",\n                \"Lazy evaluation for expensive computations\",\n                \"Memoization for repeated inputs\",\n                \"Higher-order functions for combining predictions\"\n            ],\n            \"challenge\": \"Create a functional ensemble prediction system\"\n        },\n        {\n            \"task\": \"Stream Processing Engine\",\n            \"requirements\": [\n                \"Generator-based lazy processing\",\n                \"Functional transformations on data streams\",\n                \"Immutable state management\",\n                \"Composable stream operations\"\n            ],\n            \"challenge\": \"Design a functional stream processing architecture\"\n        }\n    ]\n    \n    for i, scenario in enumerate(scenarios, 1):\n        console.print(f\"\\n[bold cyan]Scenario {i}: {scenario['task']}[/bold cyan]\")\n        console.print(\"[bold yellow]Requirements:[/bold yellow]\")\n        for req in scenario[\"requirements\"]:\n            console.print(f\"  • {req}\")\n        console.print(f\"\\n[bold yellow]Challenge: {scenario['challenge']}[/bold yellow]\")\n        console.print(\"\\n[bold green]Functional Patterns to Consider:[/bold green]\")\n        console.print(\"  • Immutable data structures\")\n        console.print(\"  • Pure functions and composition\")\n        console.print(\"  • Higher-order functions\")\n        console.print(\"  • Monadic error handling\")\n        console.print(\"  • Lazy evaluation\")\n        console.print(\"  • Memoization\")\n        console.print(\"---\")\n\n\nif __name__ == \"__main__\":\n    console.print(\"[bold blue]🚀 AI Architecture Patterns: Functional Programming[/bold blue]\")\n    console.print(\"Learn functional patterns for predictable AI systems\\n\")\n    \n    async def main():\n        await demonstrate_immutable_data()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_pure_functions()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_higher_order_functions()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_function_composition()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_currying_partial()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_monadic_error_handling()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_lazy_evaluation()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_memoization()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_decorators()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_single_dispatch()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        interactive_exercise()\n        \n        console.print(f\"\\n[bold green]✅ Completed![/bold green] Next: Run example 04_metaprogramming.py\")\n        console.print(\"💡 Pro tip: Functional patterns make AI code more predictable and testable!\")\n    \n    import asyncio\n    asyncio.run(main())","numLines":812,"startLine":1,"totalLines":812}}}
{"parentUuid":"722d7593-5292-4232-9e8f-1701deef8475","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_vrtx_01JvoDuLdcjxm6n9eraxJKvd","type":"tool_result","content":"     1→#!/usr/bin/env python3\n     2→\"\"\"\n     3→Example 4: Metaprogramming for AI Systems\n     4→\n     5→Learn metaprogramming techniques to create flexible, self-adapting AI systems\n     6→through descriptors, metaclasses, decorators, and dynamic code generation.\n     7→\n     8→Run this file to see the examples in action:\n     9→    python 03-python-idioms/examples/04_metaprogramming.py\n    10→\"\"\"\n    11→\n    12→import sys\n    13→import os\n    14→sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))\n    15→\n    16→from typing import (\n    17→    Any, Dict, List, Optional, Callable, Type, Union,\n    18→    get_type_hints, get_origin, get_args\n    19→)\n    20→from functools import wraps, update_wrapper\n    21→import inspect\n    22→import time\n    23→from dataclasses import dataclass, field\n    24→from abc import ABC, abstractmethod\n    25→import weakref\n    26→from rich.console import Console\n    27→from rich.panel import Panel\n    28→from rich.table import Table\n    29→\n    30→console = Console()\n    31→\n    32→# 🎯 LEARNING GOAL: Master metaprogramming for flexible AI systems\n    33→\n    34→\n    35→# Custom Descriptors for AI Model Properties\n    36→class ValidatedProperty:\n    37→    \"\"\"Descriptor that validates property values.\"\"\"\n    38→    \n    39→    def __init__(self, validator: Callable[[Any], bool], error_msg: str):\n    40→        self.validator = validator\n    41→        self.error_msg = error_msg\n    42→        self.name = None\n    43→    \n    44→    def __set_name__(self, owner: Type, name: str):\n    45→        \"\"\"Called when descriptor is assigned to a class attribute.\"\"\"\n    46→        self.name = name\n    47→        self.private_name = f'_{name}'\n    48→    \n    49→    def __get__(self, obj: Any, objtype: Type = None) -> Any:\n    50→        \"\"\"Get the property value.\"\"\"\n    51→        if obj is None:\n    52→            return self\n    53→        return getattr(obj, self.private_name, None)\n    54→    \n    55→    def __set__(self, obj: Any, value: Any) -> None:\n    56→        \"\"\"Set the property value with validation.\"\"\"\n    57→        if not self.validator(value):\n    58→            raise ValueError(f\"{self.error_msg}: {value}\")\n    59→        setattr(obj, self.private_name, value)\n    60→\n    61→\n    62→class CachedProperty:\n    63→    \"\"\"Descriptor that caches expensive computations.\"\"\"\n    64→    \n    65→    def __init__(self, func: Callable):\n    66→        self.func = func\n    67→        self.name = func.__name__\n    68→        update_wrapper(self, func)\n    69→    \n    70→    def __get__(self, obj: Any, objtype: Type = None) -> Any:\n    71→        if obj is None:\n    72→            return self\n    73→        \n    74→        # Check if cached value exists\n    75→        cache_name = f'_cached_{self.name}'\n    76→        if hasattr(obj, cache_name):\n    77→            return getattr(obj, cache_name)\n    78→        \n    79→        # Compute and cache the value\n    80→        value = self.func(obj)\n    81→        setattr(obj, cache_name, value)\n    82→        return value\n    83→    \n    84→    def __set__(self, obj: Any, value: Any) -> None:\n    85→        \"\"\"Allow manual cache invalidation by setting new value.\"\"\"\n    86→        cache_name = f'_cached_{self.name}'\n    87→        setattr(obj, cache_name, value)\n    88→    \n    89→    def __delete__(self, obj: Any) -> None:\n    90→        \"\"\"Clear the cached value.\"\"\"\n    91→        cache_name = f'_cached_{self.name}'\n    92→        if hasattr(obj, cache_name):\n    93→            delattr(obj, cache_name)\n    94→\n    95→\n    96→# Metaclass for Automatic Model Registration\n    97→class ModelRegistryMeta(type):\n    98→    \"\"\"Metaclass that automatically registers AI models.\"\"\"\n    99→    \n   100→    _registry: Dict[str, Type] = {}\n   101→    \n   102→    def __new__(mcs, name: str, bases: tuple, namespace: dict, **kwargs):\n   103→        # Add automatic ID generation\n   104→        if 'model_id' not in namespace and name != 'BaseModel':\n   105→            namespace['model_id'] = name.lower().replace('model', '')\n   106→        \n   107→        # Create the class\n   108→        cls = super().__new__(mcs, name, bases, namespace)\n   109→        \n   110→        # Register the model (skip base classes)\n   111→        if name != 'BaseModel' and hasattr(cls, 'model_id'):\n   112→            mcs._registry[cls.model_id] = cls\n   113→            console.print(f\"[dim]🔧 Registered model: {cls.model_id} -> {name}[/dim]\")\n   114→        \n   115→        return cls\n   116→    \n   117→    @classmethod\n   118→    def get_model(mcs, model_id: str) -> Optional[Type]:\n   119→        \"\"\"Get model class by ID.\"\"\"\n   120→        return mcs._registry.get(model_id)\n   121→    \n   122→    @classmethod\n   123→    def list_models(mcs) -> List[str]:\n   124→        \"\"\"List all registered model IDs.\"\"\"\n   125→        return list(mcs._registry.keys())\n   126→\n   127→\n   128→# Metaclass for Automatic Method Instrumentation\n   129→class InstrumentedMeta(type):\n   130→    \"\"\"Metaclass that automatically adds instrumentation to methods.\"\"\"\n   131→    \n   132→    def __new__(mcs, name: str, bases: tuple, namespace: dict, **kwargs):\n   133→        # Instrument methods that start with 'predict'\n   134→        for attr_name, attr_value in namespace.items():\n   135→            if (attr_name.startswith('predict') and \n   136→                callable(attr_value) and \n   137→                not attr_name.startswith('_')):\n   138→                \n   139→                namespace[attr_name] = mcs._instrument_method(attr_value, attr_name)\n   140→        \n   141→        return super().__new__(mcs, name, bases, namespace)\n   142→    \n   143→    @staticmethod\n   144→    def _instrument_method(method: Callable, method_name: str) -> Callable:\n   145→        \"\"\"Add timing and logging to a method.\"\"\"\n   146→        @wraps(method)\n   147→        def wrapper(self, *args, **kwargs):\n   148→            start_time = time.time()\n   149→            try:\n   150→                result = method(self, *args, **kwargs)\n   151→                end_time = time.time()\n   152→                duration = end_time - start_time\n   153→                \n   154→                # Store metrics\n   155→                if not hasattr(self, '_metrics'):\n   156→                    self._metrics = {}\n   157→                if method_name not in self._metrics:\n   158→                    self._metrics[method_name] = []\n   159→                \n   160→                self._metrics[method_name].append({\n   161→                    'duration': duration,\n   162→                    'timestamp': start_time,\n   163→                    'success': True\n   164→                })\n   165→                \n   166→                console.print(f\"[dim]📊 {self.__class__.__name__}.{method_name} took {duration:.4f}s[/dim]\")\n   167→                return result\n   168→                \n   169→            except Exception as e:\n   170→                end_time = time.time()\n   171→                duration = end_time - start_time\n   172→                \n   173→                # Store error metrics\n   174→                if not hasattr(self, '_metrics'):\n   175→                    self._metrics = {}\n   176→                if method_name not in self._metrics:\n   177→                    self._metrics[method_name] = []\n   178→                \n   179→                self._metrics[method_name].append({\n   180→                    'duration': duration,\n   181→                    'timestamp': start_time,\n   182→                    'success': False,\n   183→                    'error': str(e)\n   184→                })\n   185→                \n   186→                console.print(f\"[dim red]❌ {self.__class__.__name__}.{method_name} failed after {duration:.4f}s[/dim red]\")\n   187→                raise\n   188→        \n   189→        return wrapper\n   190→\n   191→\n   192→# Dynamic Class Generation\n   193→def create_model_class(\n   194→    name: str, \n   195→    attributes: Dict[str, Any], \n   196→    methods: Dict[str, Callable] = None,\n   197→    base_classes: tuple = ()\n   198→) -> Type:\n   199→    \"\"\"Dynamically create a model class.\"\"\"\n   200→    \n   201→    # Default base class\n   202→    if not base_classes:\n   203→        base_classes = (object,)\n   204→    \n   205→    # Combine attributes and methods\n   206→    namespace = attributes.copy()\n   207→    if methods:\n   208→        namespace.update(methods)\n   209→    \n   210→    # Add default __init__ if not provided\n   211→    if '__init__' not in namespace:\n   212→        def __init__(self, **kwargs):\n   213→            for key, value in kwargs.items():\n   214→                setattr(self, key, value)\n   215→        namespace['__init__'] = __init__\n   216→    \n   217→    # Create the class\n   218→    return type(name, base_classes, namespace)\n   219→\n   220→\n   221→# Advanced Decorator Patterns\n   222→class memoize_with_ttl:\n   223→    \"\"\"Decorator that memoizes with time-to-live.\"\"\"\n   224→    \n   225→    def __init__(self, ttl_seconds: float = 60.0):\n   226→        self.ttl_seconds = ttl_seconds\n   227→        self.cache = {}\n   228→    \n   229→    def __call__(self, func: Callable) -> Callable:\n   230→        @wraps(func)\n   231→        def wrapper(*args, **kwargs):\n   232→            # Create cache key\n   233→            key = str(args) + str(sorted(kwargs.items()))\n   234→            current_time = time.time()\n   235→            \n   236→            # Check if cached and not expired\n   237→            if key in self.cache:\n   238→                result, timestamp = self.cache[key]\n   239→                if current_time - timestamp < self.ttl_seconds:\n   240→                    console.print(f\"[dim green]💾 Cache hit for {func.__name__}[/dim green]\")\n   241→                    return result\n   242→            \n   243→            # Compute new result\n   244→            result = func(*args, **kwargs)\n   245→            self.cache[key] = (result, current_time)\n   246→            console.print(f\"[dim yellow]🔄 Cache miss for {func.__name__}[/dim yellow]\")\n   247→            return result\n   248→        \n   249→        # Add cache management methods\n   250→        wrapper.clear_cache = lambda: self.cache.clear()\n   251→        wrapper.cache_info = lambda: {\n   252→            'size': len(self.cache),\n   253→            'ttl_seconds': self.ttl_seconds\n   254→        }\n   255→        \n   256→        return wrapper\n   257→\n   258→\n   259→class retry_with_backoff:\n   260→    \"\"\"Decorator that retries with exponential backoff.\"\"\"\n   261→    \n   262→    def __init__(self, max_retries: int = 3, base_delay: float = 1.0):\n   263→        self.max_retries = max_retries\n   264→        self.base_delay = base_delay\n   265→    \n   266→    def __call__(self, func: Callable) -> Callable:\n   267→        @wraps(func)\n   268→        def wrapper(*args, **kwargs):\n   269→            last_exception = None\n   270→            \n   271→            for attempt in range(self.max_retries + 1):\n   272→                try:\n   273→                    return func(*args, **kwargs)\n   274→                except Exception as e:\n   275→                    last_exception = e\n   276→                    \n   277→                    if attempt < self.max_retries:\n   278→                        delay = self.base_delay * (2 ** attempt)\n   279→                        console.print(f\"[yellow]🔄 Retry {attempt + 1}/{self.max_retries} in {delay:.1f}s[/yellow]\")\n   280→                        time.sleep(delay)\n   281→                    else:\n   282→                        console.print(f\"[red]❌ All retries exhausted for {func.__name__}[/red]\")\n   283→            \n   284→            raise last_exception\n   285→        \n   286→        return wrapper\n   287→\n   288→\n   289→# Property Factory\n   290→def typed_property(property_type: Type, default: Any = None, validator: Callable = None):\n   291→    \"\"\"Factory for creating typed properties with optional validation.\"\"\"\n   292→    \n   293→    def property_decorator(func: Callable) -> property:\n   294→        name = func.__name__\n   295→        private_name = f'_{name}'\n   296→        \n   297→        def getter(self):\n   298→            return getattr(self, private_name, default)\n   299→        \n   300→        def setter(self, value):\n   301→            # Type checking\n   302→            if not isinstance(value, property_type):\n   303→                try:\n   304→                    value = property_type(value)\n   305→                except (ValueError, TypeError):\n   306→                    raise TypeError(f\"{name} must be of type {property_type.__name__}\")\n   307→            \n   308→            # Optional validation\n   309→            if validator and not validator(value):\n   310→                raise ValueError(f\"Invalid value for {name}: {value}\")\n   311→            \n   312→            setattr(self, private_name, value)\n   313→        \n   314→        return property(getter, setter, doc=func.__doc__)\n   315→    \n   316→    return property_decorator\n   317→\n   318→\n   319→# Context Manager for Dynamic Configuration\n   320→class DynamicConfig:\n   321→    \"\"\"Context manager that temporarily modifies class attributes.\"\"\"\n   322→    \n   323→    def __init__(self, target_class: Type, **config_changes):\n   324→        self.target_class = target_class\n   325→        self.config_changes = config_changes\n   326→        self.original_values = {}\n   327→    \n   328→    def __enter__(self):\n   329→        # Save original values\n   330→        for attr_name, new_value in self.config_changes.items():\n   331→            if hasattr(self.target_class, attr_name):\n   332→                self.original_values[attr_name] = getattr(self.target_class, attr_name)\n   333→            setattr(self.target_class, attr_name, new_value)\n   334→        return self\n   335→    \n   336→    def __exit__(self, exc_type, exc_val, exc_tb):\n   337→        # Restore original values\n   338→        for attr_name, original_value in self.original_values.items():\n   339→            setattr(self.target_class, attr_name, original_value)\n   340→        \n   341→        # Remove attributes that didn't exist originally\n   342→        for attr_name in self.config_changes:\n   343→            if attr_name not in self.original_values:\n   344→                delattr(self.target_class, attr_name)\n   345→\n   346→\n   347→# Example Classes Using Metaprogramming\n   348→\n   349→class BaseModel(metaclass=ModelRegistryMeta):\n   350→    \"\"\"Base class for AI models with validation.\"\"\"\n   351→    \n   352→    # Validated properties using descriptors\n   353→    temperature = ValidatedProperty(\n   354→        lambda x: 0.0 <= x <= 2.0,\n   355→        \"Temperature must be between 0.0 and 2.0\"\n   356→    )\n   357→    \n   358→    max_tokens = ValidatedProperty(\n   359→        lambda x: isinstance(x, int) and x > 0,\n   360→        \"Max tokens must be a positive integer\"\n   361→    )\n   362→    \n   363→    def __init__(self, temperature: float = 0.7, max_tokens: int = 1000):\n   364→        self.temperature = temperature\n   365→        self.max_tokens = max_tokens\n   366→        self._call_count = 0\n   367→    \n   368→    @CachedProperty\n   369→    def model_signature(self) -> str:\n   370→        \"\"\"Expensive computation that gets cached.\"\"\"\n   371→        console.print(\"[dim]🔍 Computing model signature...[/dim]\")\n   372→        time.sleep(0.1)  # Simulate expensive computation\n   373→        return f\"{self.__class__.__name__}_{hash(str(self.temperature) + str(self.max_tokens))}\"\n   374→\n   375→\n   376→class GPTModel(BaseModel, metaclass=InstrumentedMeta):\n   377→    \"\"\"GPT model with automatic instrumentation.\"\"\"\n   378→    \n   379→    def predict_text(self, text: str) -> str:\n   380→        \"\"\"Predict text completion.\"\"\"\n   381→        time.sleep(0.05)  # Simulate prediction\n   382→        self._call_count += 1\n   383→        return f\"GPT prediction for: {text}\"\n   384→    \n   385→    def predict_classification(self, text: str) -> Dict[str, float]:\n   386→        \"\"\"Predict text classification.\"\"\"\n   387→        time.sleep(0.03)\n   388→        self._call_count += 1\n   389→        return {\"positive\": 0.8, \"negative\": 0.1, \"neutral\": 0.1}\n   390→\n   391→\n   392→class ClaudeModel(BaseModel, metaclass=InstrumentedMeta):\n   393→    \"\"\"Claude model with automatic instrumentation.\"\"\"\n   394→    \n   395→    def predict_text(self, text: str) -> str:\n   396→        \"\"\"Predict text completion.\"\"\"\n   397→        time.sleep(0.04)\n   398→        self._call_count += 1\n   399→        return f\"Claude prediction for: {text}\"\n   400→\n   401→\n   402→class ConfigurableModel:\n   403→    \"\"\"Model with typed properties using property factory.\"\"\"\n   404→    \n   405→    @typed_property(float, default=0.7, validator=lambda x: 0.0 <= x <= 2.0)\n   406→    def temperature(self):\n   407→        \"\"\"Model temperature parameter.\"\"\"\n   408→        pass\n   409→    \n   410→    @typed_property(int, default=1000, validator=lambda x: x > 0)\n   411→    def max_tokens(self):\n   412→        \"\"\"Maximum tokens to generate.\"\"\"\n   413→        pass\n   414→    \n   415→    @typed_property(str, default=\"gpt-4\")\n   416→    def model_name(self):\n   417→        \"\"\"Name of the model.\"\"\"\n   418→        pass\n   419→\n   420→\n   421→# Dynamic Model Factory\n   422→class ModelFactory:\n   423→    \"\"\"Factory for creating model classes dynamically.\"\"\"\n   424→    \n   425→    @staticmethod\n   426→    def create_simple_model(name: str, prediction_delay: float = 0.1) -> Type:\n   427→        \"\"\"Create a simple model class.\"\"\"\n   428→        \n   429→        def predict(self, text: str) -> str:\n   430→            time.sleep(prediction_delay)\n   431→            return f\"{name} processed: {text}\"\n   432→        \n   433→        def get_info(self) -> Dict[str, Any]:\n   434→            return {\n   435→                \"model_name\": name,\n   436→                \"prediction_delay\": prediction_delay,\n   437→                \"class_name\": self.__class__.__name__\n   438→            }\n   439→        \n   440→        return create_model_class(\n   441→            name=f\"{name}Model\",\n   442→            attributes={\n   443→                \"model_name\": name,\n   444→                \"prediction_delay\": prediction_delay\n   445→            },\n   446→            methods={\n   447→                \"predict\": predict,\n   448→                \"get_info\": get_info\n   449→            },\n   450→            base_classes=(BaseModel,)\n   451→        )\n   452→    \n   453→    @staticmethod\n   454→    def create_ensemble_model(models: List[Type]) -> Type:\n   455→        \"\"\"Create an ensemble model from multiple model classes.\"\"\"\n   456→        \n   457→        def predict(self, text: str) -> List[str]:\n   458→            results = []\n   459→            for model_class in models:\n   460→                model = model_class()\n   461→                if hasattr(model, 'predict'):\n   462→                    results.append(model.predict(text))\n   463→                elif hasattr(model, 'predict_text'):\n   464→                    results.append(model.predict_text(text))\n   465→            return results\n   466→        \n   467→        def get_model_info(self) -> List[str]:\n   468→            return [model.__name__ for model in models]\n   469→        \n   470→        return create_model_class(\n   471→            name=\"EnsembleModel\",\n   472→            attributes={\n   473→                \"component_models\": models\n   474→            },\n   475→            methods={\n   476→                \"predict\": predict,\n   477→                \"get_model_info\": get_model_info\n   478→            }\n   479→        )\n   480→\n   481→\n   482→async def demonstrate_descriptors():\n   483→    \"\"\"Show descriptor patterns.\"\"\"\n   484→    \n   485→    console.print(Panel(\"🔍 Descriptors\", style=\"bold blue\"))\n   486→    \n   487→    console.print(\"[bold yellow]Creating model with validated properties:[/bold yellow]\")\n   488→    \n   489→    model = GPTModel()\n   490→    console.print(f\"  Default temperature: {model.temperature}\")\n   491→    console.print(f\"  Default max_tokens: {model.max_tokens}\")\n   492→    \n   493→    # Test validation\n   494→    try:\n   495→        model.temperature = 1.5\n   496→        console.print(f\"  ✅ Set temperature to {model.temperature}\")\n   497→    except ValueError as e:\n   498→        console.print(f\"  ❌ Validation error: {e}\")\n   499→    \n   500→    try:\n   501→        model.temperature = 3.0  # Should fail\n   502→    except ValueError as e:\n   503→        console.print(f\"  ❌ Validation caught: {e}\")\n   504→    \n   505→    # Test cached property\n   506→    console.print(f\"\\n[bold cyan]Testing cached property:[/bold cyan]\")\n   507→    sig1 = model.model_signature  # Should compute\n   508→    sig2 = model.model_signature  # Should use cache\n   509→    console.print(f\"  Signatures match: {sig1 == sig2}\")\n   510→\n   511→\n   512→async def demonstrate_metaclasses():\n   513→    \"\"\"Show metaclass patterns.\"\"\"\n   514→    \n   515→    console.print(Panel(\"🏭 Metaclasses\", style=\"bold green\"))\n   516→    \n   517→    console.print(\"[bold yellow]Automatic model registration:[/bold yellow]\")\n   518→    registered_models = ModelRegistryMeta.list_models()\n   519→    console.print(f\"  Registered models: {registered_models}\")\n   520→    \n   521→    # Get model by ID\n   522→    gpt_class = ModelRegistryMeta.get_model('gpt')\n   523→    claude_class = ModelRegistryMeta.get_model('claude')\n   524→    \n   525→    console.print(f\"\\n[bold cyan]Creating models from registry:[/bold cyan]\")\n   526→    if gpt_class:\n   527→        gpt = gpt_class()\n   528→        result = gpt.predict_text(\"Hello world\")\n   529→        console.print(f\"  GPT: {result}\")\n   530→    \n   531→    if claude_class:\n   532→        claude = claude_class()\n   533→        result = claude.predict_text(\"Hello world\")\n   534→        console.print(f\"  Claude: {result}\")\n   535→    \n   536→    # Show automatic instrumentation\n   537→    console.print(f\"\\n[bold magenta]Instrumentation metrics:[/bold magenta]\")\n   538→    if hasattr(gpt, '_metrics'):\n   539→        for method, metrics in gpt._metrics.items():\n   540→            avg_duration = sum(m['duration'] for m in metrics) / len(metrics)\n   541→            console.print(f\"  {method}: {len(metrics)} calls, avg {avg_duration:.4f}s\")\n   542→\n   543→\n   544→async def demonstrate_dynamic_classes():\n   545→    \"\"\"Show dynamic class creation.\"\"\"\n   546→    \n   547→    console.print(Panel(\"⚡ Dynamic Class Creation\", style=\"bold magenta\"))\n   548→    \n   549→    # Create models using factory\n   550→    console.print(\"[bold yellow]Creating models dynamically:[/bold yellow]\")\n   551→    \n   552→    FastModel = ModelFactory.create_simple_model(\"FastAI\", prediction_delay=0.02)\n   553→    SlowModel = ModelFactory.create_simple_model(\"DeepThink\", prediction_delay=0.08)\n   554→    \n   555→    fast_model = FastModel()\n   556→    slow_model = SlowModel()\n   557→    \n   558→    console.print(f\"  Fast model: {fast_model.get_info()}\")\n   559→    console.print(f\"  Slow model: {slow_model.get_info()}\")\n   560→    \n   561→    # Test predictions\n   562→    start_time = time.time()\n   563→    fast_result = fast_model.predict(\"test input\")\n   564→    fast_time = time.time() - start_time\n   565→    \n   566→    start_time = time.time()\n   567→    slow_result = slow_model.predict(\"test input\")\n   568→    slow_time = time.time() - start_time\n   569→    \n   570→    console.print(f\"\\n[bold cyan]Performance comparison:[/bold cyan]\")\n   571→    console.print(f\"  Fast: {fast_time:.4f}s - {fast_result}\")\n   572→    console.print(f\"  Slow: {slow_time:.4f}s - {slow_result}\")\n   573→    \n   574→    # Create ensemble model\n   575→    console.print(f\"\\n[bold yellow]Creating ensemble model:[/bold yellow]\")\n   576→    EnsembleModel = ModelFactory.create_ensemble_model([FastModel, SlowModel])\n   577→    ensemble = EnsembleModel()\n   578→    \n   579→    ensemble_results = ensemble.predict(\"ensemble test\")\n   580→    console.print(f\"  Ensemble results: {ensemble_results}\")\n   581→    console.print(f\"  Component models: {ensemble.get_model_info()}\")\n   582→\n   583→\n   584→async def demonstrate_decorators():\n   585→    \"\"\"Show advanced decorator patterns.\"\"\"\n   586→    \n   587→    console.print(Panel(\"🎨 Advanced Decorators\", style=\"bold cyan\"))\n   588→    \n   589→    @memoize_with_ttl(ttl_seconds=2.0)\n   590→    @retry_with_backoff(max_retries=2, base_delay=0.5)\n   591→    def expensive_ai_call(query: str, fail_rate: float = 0.0) -> str:\n   592→        \"\"\"Simulate expensive AI call that might fail.\"\"\"\n   593→        import random\n   594→        \n   595→        if random.random() < fail_rate:\n   596→            raise ConnectionError(\"Simulated API failure\")\n   597→        \n   598→        time.sleep(0.1)  # Simulate processing time\n   599→        return f\"AI response to: {query}\"\n   600→    \n   601→    console.print(\"[bold yellow]Testing decorated function:[/bold yellow]\")\n   602→    \n   603→    # First call - should compute\n   604→    result1 = expensive_ai_call(\"What is AI?\")\n   605→    console.print(f\"  Result 1: {result1}\")\n   606→    \n   607→    # Second call - should use cache\n   608→    result2 = expensive_ai_call(\"What is AI?\")\n   609→    console.print(f\"  Result 2: {result2}\")\n   610→    \n   611→    # Test with failures\n   612→    console.print(f\"\\n[bold cyan]Testing with simulated failures:[/bold cyan]\")\n   613→    try:\n   614→        result3 = expensive_ai_call(\"Risky query\", fail_rate=0.7)\n   615→        console.print(f\"  Success: {result3}\")\n   616→    except Exception as e:\n   617→        console.print(f\"  Failed: {e}\")\n   618→    \n   619→    # Show cache info\n   620→    cache_info = expensive_ai_call.cache_info()\n   621→    console.print(f\"\\n[bold green]Cache info: {cache_info}[/bold green]\")\n   622→\n   623→\n   624→async def demonstrate_typed_properties():\n   625→    \"\"\"Show typed property factory.\"\"\"\n   626→    \n   627→    console.print(Panel(\"🏷️ Typed Properties\", style=\"bold red\"))\n   628→    \n   629→    console.print(\"[bold yellow]Creating model with typed properties:[/bold yellow]\")\n   630→    \n   631→    model = ConfigurableModel()\n   632→    \n   633→    # Test default values\n   634→    console.print(f\"  Default temperature: {model.temperature}\")\n   635→    console.print(f\"  Default max_tokens: {model.max_tokens}\")\n   636→    console.print(f\"  Default model_name: {model.model_name}\")\n   637→    \n   638→    # Test type conversion\n   639→    console.print(f\"\\n[bold cyan]Testing type conversion:[/bold cyan]\")\n   640→    model.temperature = \"1.2\"  # String should convert to float\n   641→    model.max_tokens = \"500\"   # String should convert to int\n   642→    \n   643→    console.print(f\"  Converted temperature: {model.temperature} (type: {type(model.temperature)})\")\n   644→    console.print(f\"  Converted max_tokens: {model.max_tokens} (type: {type(model.max_tokens)})\")\n   645→    \n   646→    # Test validation\n   647→    console.print(f\"\\n[bold yellow]Testing validation:[/bold yellow]\")\n   648→    try:\n   649→        model.temperature = 3.0  # Should fail validation\n   650→    except ValueError as e:\n   651→        console.print(f\"  ❌ Validation error: {e}\")\n   652→    \n   653→    try:\n   654→        model.max_tokens = -100  # Should fail validation\n   655→    except ValueError as e:\n   656→        console.print(f\"  ❌ Validation error: {e}\")\n   657→\n   658→\n   659→async def demonstrate_dynamic_config():\n   660→    \"\"\"Show dynamic configuration context manager.\"\"\"\n   661→    \n   662→    console.print(Panel(\"⚙️ Dynamic Configuration\", style=\"bold yellow\"))\n   663→    \n   664→    # Original class configuration\n   665→    class AIService:\n   666→        timeout = 30.0\n   667→        retry_count = 3\n   668→        debug_mode = False\n   669→        \n   670→        @classmethod\n   671→        def get_config(cls) -> Dict[str, Any]:\n   672→            return {\n   673→                \"timeout\": cls.timeout,\n   674→                \"retry_count\": cls.retry_count,\n   675→                \"debug_mode\": cls.debug_mode\n   676→            }\n   677→    \n   678→    console.print(\"[bold yellow]Original configuration:[/bold yellow]\")\n   679→    console.print(f\"  {AIService.get_config()}\")\n   680→    \n   681→    # Temporarily modify configuration\n   682→    console.print(f\"\\n[bold cyan]Using dynamic configuration:[/bold cyan]\")\n   683→    with DynamicConfig(AIService, timeout=60.0, debug_mode=True, new_feature=True):\n   684→        console.print(f\"  Inside context: {AIService.get_config()}\")\n   685→        console.print(f\"  New feature: {getattr(AIService, 'new_feature', 'Not found')}\")\n   686→    \n   687→    console.print(f\"\\n[bold green]After context:[/bold green]\")\n   688→    console.print(f\"  Restored: {AIService.get_config()}\")\n   689→    console.print(f\"  New feature: {getattr(AIService, 'new_feature', 'Not found')}\")\n   690→\n   691→\n   692→def analyze_function_signature(func: Callable) -> Dict[str, Any]:\n   693→    \"\"\"Metaprogramming function to analyze function signatures.\"\"\"\n   694→    sig = inspect.signature(func)\n   695→    type_hints = get_type_hints(func)\n   696→    \n   697→    return {\n   698→        \"name\": func.__name__,\n   699→        \"parameters\": {\n   700→            name: {\n   701→                \"annotation\": type_hints.get(name, param.annotation),\n   702→                \"default\": param.default if param.default != param.empty else None,\n   703→                \"kind\": param.kind.name\n   704→            }\n   705→            for name, param in sig.parameters.items()\n   706→        },\n   707→        \"return_type\": type_hints.get('return', sig.return_annotation),\n   708→        \"docstring\": inspect.getdoc(func)\n   709→    }\n   710→\n   711→\n   712→async def demonstrate_reflection():\n   713→    \"\"\"Show reflection and introspection.\"\"\"\n   714→    \n   715→    console.print(Panel(\"🔍 Reflection & Introspection\", style=\"bold purple\"))\n   716→    \n   717→    # Analyze function signatures\n   718→    def sample_ai_function(text: str, temperature: float = 0.7, max_tokens: Optional[int] = None) -> Dict[str, Any]:\n   719→        \"\"\"Sample AI function for analysis.\"\"\"\n   720→        return {\"processed\": text, \"config\": {\"temperature\": temperature, \"max_tokens\": max_tokens}}\n   721→    \n   722→    analysis = analyze_function_signature(sample_ai_function)\n   723→    \n   724→    console.print(\"[bold yellow]Function signature analysis:[/bold yellow]\")\n   725→    console.print(f\"  Name: {analysis['name']}\")\n   726→    console.print(f\"  Return type: {analysis['return_type']}\")\n   727→    console.print(f\"  Parameters:\")\n   728→    \n   729→    for param_name, param_info in analysis['parameters'].items():\n   730→        console.print(f\"    {param_name}: {param_info['annotation']} (default: {param_info['default']})\")\n   731→    \n   732→    # Analyze class structure\n   733→    console.print(f\"\\n[bold cyan]Class structure analysis:[/bold cyan]\")\n   734→    gpt_model = GPTModel()\n   735→    \n   736→    methods = [name for name, method in inspect.getmembers(gpt_model, predicate=inspect.ismethod)]\n   737→    properties = [name for name in dir(gpt_model) if isinstance(getattr(type(gpt_model), name, None), property)]\n   738→    \n   739→    console.print(f\"  Methods: {[m for m in methods if not m.startswith('_')]}\")\n   740→    console.print(f\"  Properties: {properties}\")\n   741→    \n   742→    if hasattr(gpt_model, '_metrics'):\n   743→        console.print(f\"  Metrics: {list(gpt_model._metrics.keys())}\")\n   744→\n   745→\n   746→def interactive_exercise():\n   747→    \"\"\"Interactive exercise for metaprogramming.\"\"\"\n   748→    \n   749→    console.print(Panel(\"🎮 Interactive Exercise: Metaprogramming AI Framework\", style=\"bold magenta\"))\n   750→    \n   751→    scenarios = [\n   752→        {\n   753→            \"challenge\": \"Dynamic Model Registry\",\n   754→            \"requirements\": [\n   755→                \"Automatic registration of model classes\",\n   756→                \"Type validation for model parameters\",\n   757→                \"Runtime model discovery and instantiation\",\n   758→                \"Automatic instrumentation of model methods\"\n   759→            ],\n   760→            \"tools\": \"Metaclasses, descriptors, registration patterns\"\n   761→        },\n   762→        {\n   763→            \"challenge\": \"Self-Configuring AI Pipeline\",\n   764→            \"requirements\": [\n   765→                \"Dynamic property creation based on configuration\",\n   766→                \"Automatic validation and type conversion\",\n   767→                \"Context-based configuration overrides\",\n   768→                \"Runtime pipeline modification\"\n   769→            ],\n   770→            \"tools\": \"Property factories, context managers, dynamic classes\"\n   771→        },\n   772→        {\n   773→            \"challenge\": \"Adaptive Model Behavior\",\n   774→            \"requirements\": [\n   775→                \"Runtime method modification based on usage patterns\",\n   776→                \"Automatic caching with TTL for expensive operations\",\n   777→                \"Retry logic with configurable backoff strategies\",\n   778→                \"Performance monitoring and optimization\"\n   779→            ],\n   780→            \"tools\": \"Decorators, method instrumentation, caching patterns\"\n   781→        }\n   782→    ]\n   783→    \n   784→    for i, scenario in enumerate(scenarios, 1):\n   785→        console.print(f\"\\n[bold cyan]Challenge {i}: {scenario['challenge']}[/bold cyan]\")\n   786→        console.print(\"[bold yellow]Requirements:[/bold yellow]\")\n   787→        for req in scenario[\"requirements\"]:\n   788→            console.print(f\"  • {req}\")\n   789→        console.print(f\"\\n[bold green]Metaprogramming Tools: {scenario['tools']}[/bold green]\")\n   790→        console.print(\"\\n[bold magenta]Consider:[/bold magenta]\")\n   791→        console.print(\"  • When to use metaclasses vs. decorators\")\n   792→        console.print(\"  • How to balance flexibility with performance\")\n   793→        console.print(\"  • Type safety in dynamic code generation\")\n   794→        console.print(\"  • Debugging and introspection capabilities\")\n   795→        console.print(\"---\")\n   796→\n   797→\n   798→if __name__ == \"__main__\":\n   799→    console.print(\"[bold blue]🚀 AI Architecture Patterns: Metaprogramming[/bold blue]\")\n   800→    console.print(\"Learn to create flexible, self-adapting AI systems\\n\")\n   801→    \n   802→    async def main():\n   803→        await demonstrate_descriptors()\n   804→        console.print(\"\\n\" + \"=\"*60)\n   805→        \n   806→        await demonstrate_metaclasses()\n   807→        console.print(\"\\n\" + \"=\"*60)\n   808→        \n   809→        await demonstrate_dynamic_classes()\n   810→        console.print(\"\\n\" + \"=\"*60)\n   811→        \n   812→        await demonstrate_decorators()\n   813→        console.print(\"\\n\" + \"=\"*60)\n   814→        \n   815→        await demonstrate_typed_properties()\n   816→        console.print(\"\\n\" + \"=\"*60)\n   817→        \n   818→        await demonstrate_dynamic_config()\n   819→        console.print(\"\\n\" + \"=\"*60)\n   820→        \n   821→        await demonstrate_reflection()\n   822→        console.print(\"\\n\" + \"=\"*60)\n   823→        \n   824→        interactive_exercise()\n   825→        \n   826→        console.print(f\"\\n[bold green]✅ Completed![/bold green] Next: Run example 05_performance_optimization.py\")\n   827→        console.print(\"💡 Pro tip: Metaprogramming enables flexible AI architectures but use with care!\")\n   828→    \n   829→    import asyncio\n   830→    asyncio.run(main())\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b39ae093-e960-4cfb-8e4a-08dbc94885be","timestamp":"2025-08-01T17:59:54.596Z","toolUseResult":{"type":"text","file":{"filePath":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/examples/04_metaprogramming.py","content":"#!/usr/bin/env python3\n\"\"\"\nExample 4: Metaprogramming for AI Systems\n\nLearn metaprogramming techniques to create flexible, self-adapting AI systems\nthrough descriptors, metaclasses, decorators, and dynamic code generation.\n\nRun this file to see the examples in action:\n    python 03-python-idioms/examples/04_metaprogramming.py\n\"\"\"\n\nimport sys\nimport os\nsys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))\n\nfrom typing import (\n    Any, Dict, List, Optional, Callable, Type, Union,\n    get_type_hints, get_origin, get_args\n)\nfrom functools import wraps, update_wrapper\nimport inspect\nimport time\nfrom dataclasses import dataclass, field\nfrom abc import ABC, abstractmethod\nimport weakref\nfrom rich.console import Console\nfrom rich.panel import Panel\nfrom rich.table import Table\n\nconsole = Console()\n\n# 🎯 LEARNING GOAL: Master metaprogramming for flexible AI systems\n\n\n# Custom Descriptors for AI Model Properties\nclass ValidatedProperty:\n    \"\"\"Descriptor that validates property values.\"\"\"\n    \n    def __init__(self, validator: Callable[[Any], bool], error_msg: str):\n        self.validator = validator\n        self.error_msg = error_msg\n        self.name = None\n    \n    def __set_name__(self, owner: Type, name: str):\n        \"\"\"Called when descriptor is assigned to a class attribute.\"\"\"\n        self.name = name\n        self.private_name = f'_{name}'\n    \n    def __get__(self, obj: Any, objtype: Type = None) -> Any:\n        \"\"\"Get the property value.\"\"\"\n        if obj is None:\n            return self\n        return getattr(obj, self.private_name, None)\n    \n    def __set__(self, obj: Any, value: Any) -> None:\n        \"\"\"Set the property value with validation.\"\"\"\n        if not self.validator(value):\n            raise ValueError(f\"{self.error_msg}: {value}\")\n        setattr(obj, self.private_name, value)\n\n\nclass CachedProperty:\n    \"\"\"Descriptor that caches expensive computations.\"\"\"\n    \n    def __init__(self, func: Callable):\n        self.func = func\n        self.name = func.__name__\n        update_wrapper(self, func)\n    \n    def __get__(self, obj: Any, objtype: Type = None) -> Any:\n        if obj is None:\n            return self\n        \n        # Check if cached value exists\n        cache_name = f'_cached_{self.name}'\n        if hasattr(obj, cache_name):\n            return getattr(obj, cache_name)\n        \n        # Compute and cache the value\n        value = self.func(obj)\n        setattr(obj, cache_name, value)\n        return value\n    \n    def __set__(self, obj: Any, value: Any) -> None:\n        \"\"\"Allow manual cache invalidation by setting new value.\"\"\"\n        cache_name = f'_cached_{self.name}'\n        setattr(obj, cache_name, value)\n    \n    def __delete__(self, obj: Any) -> None:\n        \"\"\"Clear the cached value.\"\"\"\n        cache_name = f'_cached_{self.name}'\n        if hasattr(obj, cache_name):\n            delattr(obj, cache_name)\n\n\n# Metaclass for Automatic Model Registration\nclass ModelRegistryMeta(type):\n    \"\"\"Metaclass that automatically registers AI models.\"\"\"\n    \n    _registry: Dict[str, Type] = {}\n    \n    def __new__(mcs, name: str, bases: tuple, namespace: dict, **kwargs):\n        # Add automatic ID generation\n        if 'model_id' not in namespace and name != 'BaseModel':\n            namespace['model_id'] = name.lower().replace('model', '')\n        \n        # Create the class\n        cls = super().__new__(mcs, name, bases, namespace)\n        \n        # Register the model (skip base classes)\n        if name != 'BaseModel' and hasattr(cls, 'model_id'):\n            mcs._registry[cls.model_id] = cls\n            console.print(f\"[dim]🔧 Registered model: {cls.model_id} -> {name}[/dim]\")\n        \n        return cls\n    \n    @classmethod\n    def get_model(mcs, model_id: str) -> Optional[Type]:\n        \"\"\"Get model class by ID.\"\"\"\n        return mcs._registry.get(model_id)\n    \n    @classmethod\n    def list_models(mcs) -> List[str]:\n        \"\"\"List all registered model IDs.\"\"\"\n        return list(mcs._registry.keys())\n\n\n# Metaclass for Automatic Method Instrumentation\nclass InstrumentedMeta(type):\n    \"\"\"Metaclass that automatically adds instrumentation to methods.\"\"\"\n    \n    def __new__(mcs, name: str, bases: tuple, namespace: dict, **kwargs):\n        # Instrument methods that start with 'predict'\n        for attr_name, attr_value in namespace.items():\n            if (attr_name.startswith('predict') and \n                callable(attr_value) and \n                not attr_name.startswith('_')):\n                \n                namespace[attr_name] = mcs._instrument_method(attr_value, attr_name)\n        \n        return super().__new__(mcs, name, bases, namespace)\n    \n    @staticmethod\n    def _instrument_method(method: Callable, method_name: str) -> Callable:\n        \"\"\"Add timing and logging to a method.\"\"\"\n        @wraps(method)\n        def wrapper(self, *args, **kwargs):\n            start_time = time.time()\n            try:\n                result = method(self, *args, **kwargs)\n                end_time = time.time()\n                duration = end_time - start_time\n                \n                # Store metrics\n                if not hasattr(self, '_metrics'):\n                    self._metrics = {}\n                if method_name not in self._metrics:\n                    self._metrics[method_name] = []\n                \n                self._metrics[method_name].append({\n                    'duration': duration,\n                    'timestamp': start_time,\n                    'success': True\n                })\n                \n                console.print(f\"[dim]📊 {self.__class__.__name__}.{method_name} took {duration:.4f}s[/dim]\")\n                return result\n                \n            except Exception as e:\n                end_time = time.time()\n                duration = end_time - start_time\n                \n                # Store error metrics\n                if not hasattr(self, '_metrics'):\n                    self._metrics = {}\n                if method_name not in self._metrics:\n                    self._metrics[method_name] = []\n                \n                self._metrics[method_name].append({\n                    'duration': duration,\n                    'timestamp': start_time,\n                    'success': False,\n                    'error': str(e)\n                })\n                \n                console.print(f\"[dim red]❌ {self.__class__.__name__}.{method_name} failed after {duration:.4f}s[/dim red]\")\n                raise\n        \n        return wrapper\n\n\n# Dynamic Class Generation\ndef create_model_class(\n    name: str, \n    attributes: Dict[str, Any], \n    methods: Dict[str, Callable] = None,\n    base_classes: tuple = ()\n) -> Type:\n    \"\"\"Dynamically create a model class.\"\"\"\n    \n    # Default base class\n    if not base_classes:\n        base_classes = (object,)\n    \n    # Combine attributes and methods\n    namespace = attributes.copy()\n    if methods:\n        namespace.update(methods)\n    \n    # Add default __init__ if not provided\n    if '__init__' not in namespace:\n        def __init__(self, **kwargs):\n            for key, value in kwargs.items():\n                setattr(self, key, value)\n        namespace['__init__'] = __init__\n    \n    # Create the class\n    return type(name, base_classes, namespace)\n\n\n# Advanced Decorator Patterns\nclass memoize_with_ttl:\n    \"\"\"Decorator that memoizes with time-to-live.\"\"\"\n    \n    def __init__(self, ttl_seconds: float = 60.0):\n        self.ttl_seconds = ttl_seconds\n        self.cache = {}\n    \n    def __call__(self, func: Callable) -> Callable:\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            # Create cache key\n            key = str(args) + str(sorted(kwargs.items()))\n            current_time = time.time()\n            \n            # Check if cached and not expired\n            if key in self.cache:\n                result, timestamp = self.cache[key]\n                if current_time - timestamp < self.ttl_seconds:\n                    console.print(f\"[dim green]💾 Cache hit for {func.__name__}[/dim green]\")\n                    return result\n            \n            # Compute new result\n            result = func(*args, **kwargs)\n            self.cache[key] = (result, current_time)\n            console.print(f\"[dim yellow]🔄 Cache miss for {func.__name__}[/dim yellow]\")\n            return result\n        \n        # Add cache management methods\n        wrapper.clear_cache = lambda: self.cache.clear()\n        wrapper.cache_info = lambda: {\n            'size': len(self.cache),\n            'ttl_seconds': self.ttl_seconds\n        }\n        \n        return wrapper\n\n\nclass retry_with_backoff:\n    \"\"\"Decorator that retries with exponential backoff.\"\"\"\n    \n    def __init__(self, max_retries: int = 3, base_delay: float = 1.0):\n        self.max_retries = max_retries\n        self.base_delay = base_delay\n    \n    def __call__(self, func: Callable) -> Callable:\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            last_exception = None\n            \n            for attempt in range(self.max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    last_exception = e\n                    \n                    if attempt < self.max_retries:\n                        delay = self.base_delay * (2 ** attempt)\n                        console.print(f\"[yellow]🔄 Retry {attempt + 1}/{self.max_retries} in {delay:.1f}s[/yellow]\")\n                        time.sleep(delay)\n                    else:\n                        console.print(f\"[red]❌ All retries exhausted for {func.__name__}[/red]\")\n            \n            raise last_exception\n        \n        return wrapper\n\n\n# Property Factory\ndef typed_property(property_type: Type, default: Any = None, validator: Callable = None):\n    \"\"\"Factory for creating typed properties with optional validation.\"\"\"\n    \n    def property_decorator(func: Callable) -> property:\n        name = func.__name__\n        private_name = f'_{name}'\n        \n        def getter(self):\n            return getattr(self, private_name, default)\n        \n        def setter(self, value):\n            # Type checking\n            if not isinstance(value, property_type):\n                try:\n                    value = property_type(value)\n                except (ValueError, TypeError):\n                    raise TypeError(f\"{name} must be of type {property_type.__name__}\")\n            \n            # Optional validation\n            if validator and not validator(value):\n                raise ValueError(f\"Invalid value for {name}: {value}\")\n            \n            setattr(self, private_name, value)\n        \n        return property(getter, setter, doc=func.__doc__)\n    \n    return property_decorator\n\n\n# Context Manager for Dynamic Configuration\nclass DynamicConfig:\n    \"\"\"Context manager that temporarily modifies class attributes.\"\"\"\n    \n    def __init__(self, target_class: Type, **config_changes):\n        self.target_class = target_class\n        self.config_changes = config_changes\n        self.original_values = {}\n    \n    def __enter__(self):\n        # Save original values\n        for attr_name, new_value in self.config_changes.items():\n            if hasattr(self.target_class, attr_name):\n                self.original_values[attr_name] = getattr(self.target_class, attr_name)\n            setattr(self.target_class, attr_name, new_value)\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        # Restore original values\n        for attr_name, original_value in self.original_values.items():\n            setattr(self.target_class, attr_name, original_value)\n        \n        # Remove attributes that didn't exist originally\n        for attr_name in self.config_changes:\n            if attr_name not in self.original_values:\n                delattr(self.target_class, attr_name)\n\n\n# Example Classes Using Metaprogramming\n\nclass BaseModel(metaclass=ModelRegistryMeta):\n    \"\"\"Base class for AI models with validation.\"\"\"\n    \n    # Validated properties using descriptors\n    temperature = ValidatedProperty(\n        lambda x: 0.0 <= x <= 2.0,\n        \"Temperature must be between 0.0 and 2.0\"\n    )\n    \n    max_tokens = ValidatedProperty(\n        lambda x: isinstance(x, int) and x > 0,\n        \"Max tokens must be a positive integer\"\n    )\n    \n    def __init__(self, temperature: float = 0.7, max_tokens: int = 1000):\n        self.temperature = temperature\n        self.max_tokens = max_tokens\n        self._call_count = 0\n    \n    @CachedProperty\n    def model_signature(self) -> str:\n        \"\"\"Expensive computation that gets cached.\"\"\"\n        console.print(\"[dim]🔍 Computing model signature...[/dim]\")\n        time.sleep(0.1)  # Simulate expensive computation\n        return f\"{self.__class__.__name__}_{hash(str(self.temperature) + str(self.max_tokens))}\"\n\n\nclass GPTModel(BaseModel, metaclass=InstrumentedMeta):\n    \"\"\"GPT model with automatic instrumentation.\"\"\"\n    \n    def predict_text(self, text: str) -> str:\n        \"\"\"Predict text completion.\"\"\"\n        time.sleep(0.05)  # Simulate prediction\n        self._call_count += 1\n        return f\"GPT prediction for: {text}\"\n    \n    def predict_classification(self, text: str) -> Dict[str, float]:\n        \"\"\"Predict text classification.\"\"\"\n        time.sleep(0.03)\n        self._call_count += 1\n        return {\"positive\": 0.8, \"negative\": 0.1, \"neutral\": 0.1}\n\n\nclass ClaudeModel(BaseModel, metaclass=InstrumentedMeta):\n    \"\"\"Claude model with automatic instrumentation.\"\"\"\n    \n    def predict_text(self, text: str) -> str:\n        \"\"\"Predict text completion.\"\"\"\n        time.sleep(0.04)\n        self._call_count += 1\n        return f\"Claude prediction for: {text}\"\n\n\nclass ConfigurableModel:\n    \"\"\"Model with typed properties using property factory.\"\"\"\n    \n    @typed_property(float, default=0.7, validator=lambda x: 0.0 <= x <= 2.0)\n    def temperature(self):\n        \"\"\"Model temperature parameter.\"\"\"\n        pass\n    \n    @typed_property(int, default=1000, validator=lambda x: x > 0)\n    def max_tokens(self):\n        \"\"\"Maximum tokens to generate.\"\"\"\n        pass\n    \n    @typed_property(str, default=\"gpt-4\")\n    def model_name(self):\n        \"\"\"Name of the model.\"\"\"\n        pass\n\n\n# Dynamic Model Factory\nclass ModelFactory:\n    \"\"\"Factory for creating model classes dynamically.\"\"\"\n    \n    @staticmethod\n    def create_simple_model(name: str, prediction_delay: float = 0.1) -> Type:\n        \"\"\"Create a simple model class.\"\"\"\n        \n        def predict(self, text: str) -> str:\n            time.sleep(prediction_delay)\n            return f\"{name} processed: {text}\"\n        \n        def get_info(self) -> Dict[str, Any]:\n            return {\n                \"model_name\": name,\n                \"prediction_delay\": prediction_delay,\n                \"class_name\": self.__class__.__name__\n            }\n        \n        return create_model_class(\n            name=f\"{name}Model\",\n            attributes={\n                \"model_name\": name,\n                \"prediction_delay\": prediction_delay\n            },\n            methods={\n                \"predict\": predict,\n                \"get_info\": get_info\n            },\n            base_classes=(BaseModel,)\n        )\n    \n    @staticmethod\n    def create_ensemble_model(models: List[Type]) -> Type:\n        \"\"\"Create an ensemble model from multiple model classes.\"\"\"\n        \n        def predict(self, text: str) -> List[str]:\n            results = []\n            for model_class in models:\n                model = model_class()\n                if hasattr(model, 'predict'):\n                    results.append(model.predict(text))\n                elif hasattr(model, 'predict_text'):\n                    results.append(model.predict_text(text))\n            return results\n        \n        def get_model_info(self) -> List[str]:\n            return [model.__name__ for model in models]\n        \n        return create_model_class(\n            name=\"EnsembleModel\",\n            attributes={\n                \"component_models\": models\n            },\n            methods={\n                \"predict\": predict,\n                \"get_model_info\": get_model_info\n            }\n        )\n\n\nasync def demonstrate_descriptors():\n    \"\"\"Show descriptor patterns.\"\"\"\n    \n    console.print(Panel(\"🔍 Descriptors\", style=\"bold blue\"))\n    \n    console.print(\"[bold yellow]Creating model with validated properties:[/bold yellow]\")\n    \n    model = GPTModel()\n    console.print(f\"  Default temperature: {model.temperature}\")\n    console.print(f\"  Default max_tokens: {model.max_tokens}\")\n    \n    # Test validation\n    try:\n        model.temperature = 1.5\n        console.print(f\"  ✅ Set temperature to {model.temperature}\")\n    except ValueError as e:\n        console.print(f\"  ❌ Validation error: {e}\")\n    \n    try:\n        model.temperature = 3.0  # Should fail\n    except ValueError as e:\n        console.print(f\"  ❌ Validation caught: {e}\")\n    \n    # Test cached property\n    console.print(f\"\\n[bold cyan]Testing cached property:[/bold cyan]\")\n    sig1 = model.model_signature  # Should compute\n    sig2 = model.model_signature  # Should use cache\n    console.print(f\"  Signatures match: {sig1 == sig2}\")\n\n\nasync def demonstrate_metaclasses():\n    \"\"\"Show metaclass patterns.\"\"\"\n    \n    console.print(Panel(\"🏭 Metaclasses\", style=\"bold green\"))\n    \n    console.print(\"[bold yellow]Automatic model registration:[/bold yellow]\")\n    registered_models = ModelRegistryMeta.list_models()\n    console.print(f\"  Registered models: {registered_models}\")\n    \n    # Get model by ID\n    gpt_class = ModelRegistryMeta.get_model('gpt')\n    claude_class = ModelRegistryMeta.get_model('claude')\n    \n    console.print(f\"\\n[bold cyan]Creating models from registry:[/bold cyan]\")\n    if gpt_class:\n        gpt = gpt_class()\n        result = gpt.predict_text(\"Hello world\")\n        console.print(f\"  GPT: {result}\")\n    \n    if claude_class:\n        claude = claude_class()\n        result = claude.predict_text(\"Hello world\")\n        console.print(f\"  Claude: {result}\")\n    \n    # Show automatic instrumentation\n    console.print(f\"\\n[bold magenta]Instrumentation metrics:[/bold magenta]\")\n    if hasattr(gpt, '_metrics'):\n        for method, metrics in gpt._metrics.items():\n            avg_duration = sum(m['duration'] for m in metrics) / len(metrics)\n            console.print(f\"  {method}: {len(metrics)} calls, avg {avg_duration:.4f}s\")\n\n\nasync def demonstrate_dynamic_classes():\n    \"\"\"Show dynamic class creation.\"\"\"\n    \n    console.print(Panel(\"⚡ Dynamic Class Creation\", style=\"bold magenta\"))\n    \n    # Create models using factory\n    console.print(\"[bold yellow]Creating models dynamically:[/bold yellow]\")\n    \n    FastModel = ModelFactory.create_simple_model(\"FastAI\", prediction_delay=0.02)\n    SlowModel = ModelFactory.create_simple_model(\"DeepThink\", prediction_delay=0.08)\n    \n    fast_model = FastModel()\n    slow_model = SlowModel()\n    \n    console.print(f\"  Fast model: {fast_model.get_info()}\")\n    console.print(f\"  Slow model: {slow_model.get_info()}\")\n    \n    # Test predictions\n    start_time = time.time()\n    fast_result = fast_model.predict(\"test input\")\n    fast_time = time.time() - start_time\n    \n    start_time = time.time()\n    slow_result = slow_model.predict(\"test input\")\n    slow_time = time.time() - start_time\n    \n    console.print(f\"\\n[bold cyan]Performance comparison:[/bold cyan]\")\n    console.print(f\"  Fast: {fast_time:.4f}s - {fast_result}\")\n    console.print(f\"  Slow: {slow_time:.4f}s - {slow_result}\")\n    \n    # Create ensemble model\n    console.print(f\"\\n[bold yellow]Creating ensemble model:[/bold yellow]\")\n    EnsembleModel = ModelFactory.create_ensemble_model([FastModel, SlowModel])\n    ensemble = EnsembleModel()\n    \n    ensemble_results = ensemble.predict(\"ensemble test\")\n    console.print(f\"  Ensemble results: {ensemble_results}\")\n    console.print(f\"  Component models: {ensemble.get_model_info()}\")\n\n\nasync def demonstrate_decorators():\n    \"\"\"Show advanced decorator patterns.\"\"\"\n    \n    console.print(Panel(\"🎨 Advanced Decorators\", style=\"bold cyan\"))\n    \n    @memoize_with_ttl(ttl_seconds=2.0)\n    @retry_with_backoff(max_retries=2, base_delay=0.5)\n    def expensive_ai_call(query: str, fail_rate: float = 0.0) -> str:\n        \"\"\"Simulate expensive AI call that might fail.\"\"\"\n        import random\n        \n        if random.random() < fail_rate:\n            raise ConnectionError(\"Simulated API failure\")\n        \n        time.sleep(0.1)  # Simulate processing time\n        return f\"AI response to: {query}\"\n    \n    console.print(\"[bold yellow]Testing decorated function:[/bold yellow]\")\n    \n    # First call - should compute\n    result1 = expensive_ai_call(\"What is AI?\")\n    console.print(f\"  Result 1: {result1}\")\n    \n    # Second call - should use cache\n    result2 = expensive_ai_call(\"What is AI?\")\n    console.print(f\"  Result 2: {result2}\")\n    \n    # Test with failures\n    console.print(f\"\\n[bold cyan]Testing with simulated failures:[/bold cyan]\")\n    try:\n        result3 = expensive_ai_call(\"Risky query\", fail_rate=0.7)\n        console.print(f\"  Success: {result3}\")\n    except Exception as e:\n        console.print(f\"  Failed: {e}\")\n    \n    # Show cache info\n    cache_info = expensive_ai_call.cache_info()\n    console.print(f\"\\n[bold green]Cache info: {cache_info}[/bold green]\")\n\n\nasync def demonstrate_typed_properties():\n    \"\"\"Show typed property factory.\"\"\"\n    \n    console.print(Panel(\"🏷️ Typed Properties\", style=\"bold red\"))\n    \n    console.print(\"[bold yellow]Creating model with typed properties:[/bold yellow]\")\n    \n    model = ConfigurableModel()\n    \n    # Test default values\n    console.print(f\"  Default temperature: {model.temperature}\")\n    console.print(f\"  Default max_tokens: {model.max_tokens}\")\n    console.print(f\"  Default model_name: {model.model_name}\")\n    \n    # Test type conversion\n    console.print(f\"\\n[bold cyan]Testing type conversion:[/bold cyan]\")\n    model.temperature = \"1.2\"  # String should convert to float\n    model.max_tokens = \"500\"   # String should convert to int\n    \n    console.print(f\"  Converted temperature: {model.temperature} (type: {type(model.temperature)})\")\n    console.print(f\"  Converted max_tokens: {model.max_tokens} (type: {type(model.max_tokens)})\")\n    \n    # Test validation\n    console.print(f\"\\n[bold yellow]Testing validation:[/bold yellow]\")\n    try:\n        model.temperature = 3.0  # Should fail validation\n    except ValueError as e:\n        console.print(f\"  ❌ Validation error: {e}\")\n    \n    try:\n        model.max_tokens = -100  # Should fail validation\n    except ValueError as e:\n        console.print(f\"  ❌ Validation error: {e}\")\n\n\nasync def demonstrate_dynamic_config():\n    \"\"\"Show dynamic configuration context manager.\"\"\"\n    \n    console.print(Panel(\"⚙️ Dynamic Configuration\", style=\"bold yellow\"))\n    \n    # Original class configuration\n    class AIService:\n        timeout = 30.0\n        retry_count = 3\n        debug_mode = False\n        \n        @classmethod\n        def get_config(cls) -> Dict[str, Any]:\n            return {\n                \"timeout\": cls.timeout,\n                \"retry_count\": cls.retry_count,\n                \"debug_mode\": cls.debug_mode\n            }\n    \n    console.print(\"[bold yellow]Original configuration:[/bold yellow]\")\n    console.print(f\"  {AIService.get_config()}\")\n    \n    # Temporarily modify configuration\n    console.print(f\"\\n[bold cyan]Using dynamic configuration:[/bold cyan]\")\n    with DynamicConfig(AIService, timeout=60.0, debug_mode=True, new_feature=True):\n        console.print(f\"  Inside context: {AIService.get_config()}\")\n        console.print(f\"  New feature: {getattr(AIService, 'new_feature', 'Not found')}\")\n    \n    console.print(f\"\\n[bold green]After context:[/bold green]\")\n    console.print(f\"  Restored: {AIService.get_config()}\")\n    console.print(f\"  New feature: {getattr(AIService, 'new_feature', 'Not found')}\")\n\n\ndef analyze_function_signature(func: Callable) -> Dict[str, Any]:\n    \"\"\"Metaprogramming function to analyze function signatures.\"\"\"\n    sig = inspect.signature(func)\n    type_hints = get_type_hints(func)\n    \n    return {\n        \"name\": func.__name__,\n        \"parameters\": {\n            name: {\n                \"annotation\": type_hints.get(name, param.annotation),\n                \"default\": param.default if param.default != param.empty else None,\n                \"kind\": param.kind.name\n            }\n            for name, param in sig.parameters.items()\n        },\n        \"return_type\": type_hints.get('return', sig.return_annotation),\n        \"docstring\": inspect.getdoc(func)\n    }\n\n\nasync def demonstrate_reflection():\n    \"\"\"Show reflection and introspection.\"\"\"\n    \n    console.print(Panel(\"🔍 Reflection & Introspection\", style=\"bold purple\"))\n    \n    # Analyze function signatures\n    def sample_ai_function(text: str, temperature: float = 0.7, max_tokens: Optional[int] = None) -> Dict[str, Any]:\n        \"\"\"Sample AI function for analysis.\"\"\"\n        return {\"processed\": text, \"config\": {\"temperature\": temperature, \"max_tokens\": max_tokens}}\n    \n    analysis = analyze_function_signature(sample_ai_function)\n    \n    console.print(\"[bold yellow]Function signature analysis:[/bold yellow]\")\n    console.print(f\"  Name: {analysis['name']}\")\n    console.print(f\"  Return type: {analysis['return_type']}\")\n    console.print(f\"  Parameters:\")\n    \n    for param_name, param_info in analysis['parameters'].items():\n        console.print(f\"    {param_name}: {param_info['annotation']} (default: {param_info['default']})\")\n    \n    # Analyze class structure\n    console.print(f\"\\n[bold cyan]Class structure analysis:[/bold cyan]\")\n    gpt_model = GPTModel()\n    \n    methods = [name for name, method in inspect.getmembers(gpt_model, predicate=inspect.ismethod)]\n    properties = [name for name in dir(gpt_model) if isinstance(getattr(type(gpt_model), name, None), property)]\n    \n    console.print(f\"  Methods: {[m for m in methods if not m.startswith('_')]}\")\n    console.print(f\"  Properties: {properties}\")\n    \n    if hasattr(gpt_model, '_metrics'):\n        console.print(f\"  Metrics: {list(gpt_model._metrics.keys())}\")\n\n\ndef interactive_exercise():\n    \"\"\"Interactive exercise for metaprogramming.\"\"\"\n    \n    console.print(Panel(\"🎮 Interactive Exercise: Metaprogramming AI Framework\", style=\"bold magenta\"))\n    \n    scenarios = [\n        {\n            \"challenge\": \"Dynamic Model Registry\",\n            \"requirements\": [\n                \"Automatic registration of model classes\",\n                \"Type validation for model parameters\",\n                \"Runtime model discovery and instantiation\",\n                \"Automatic instrumentation of model methods\"\n            ],\n            \"tools\": \"Metaclasses, descriptors, registration patterns\"\n        },\n        {\n            \"challenge\": \"Self-Configuring AI Pipeline\",\n            \"requirements\": [\n                \"Dynamic property creation based on configuration\",\n                \"Automatic validation and type conversion\",\n                \"Context-based configuration overrides\",\n                \"Runtime pipeline modification\"\n            ],\n            \"tools\": \"Property factories, context managers, dynamic classes\"\n        },\n        {\n            \"challenge\": \"Adaptive Model Behavior\",\n            \"requirements\": [\n                \"Runtime method modification based on usage patterns\",\n                \"Automatic caching with TTL for expensive operations\",\n                \"Retry logic with configurable backoff strategies\",\n                \"Performance monitoring and optimization\"\n            ],\n            \"tools\": \"Decorators, method instrumentation, caching patterns\"\n        }\n    ]\n    \n    for i, scenario in enumerate(scenarios, 1):\n        console.print(f\"\\n[bold cyan]Challenge {i}: {scenario['challenge']}[/bold cyan]\")\n        console.print(\"[bold yellow]Requirements:[/bold yellow]\")\n        for req in scenario[\"requirements\"]:\n            console.print(f\"  • {req}\")\n        console.print(f\"\\n[bold green]Metaprogramming Tools: {scenario['tools']}[/bold green]\")\n        console.print(\"\\n[bold magenta]Consider:[/bold magenta]\")\n        console.print(\"  • When to use metaclasses vs. decorators\")\n        console.print(\"  • How to balance flexibility with performance\")\n        console.print(\"  • Type safety in dynamic code generation\")\n        console.print(\"  • Debugging and introspection capabilities\")\n        console.print(\"---\")\n\n\nif __name__ == \"__main__\":\n    console.print(\"[bold blue]🚀 AI Architecture Patterns: Metaprogramming[/bold blue]\")\n    console.print(\"Learn to create flexible, self-adapting AI systems\\n\")\n    \n    async def main():\n        await demonstrate_descriptors()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_metaclasses()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_dynamic_classes()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_decorators()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_typed_properties()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_dynamic_config()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        await demonstrate_reflection()\n        console.print(\"\\n\" + \"=\"*60)\n        \n        interactive_exercise()\n        \n        console.print(f\"\\n[bold green]✅ Completed![/bold green] Next: Run example 05_performance_optimization.py\")\n        console.print(\"💡 Pro tip: Metaprogramming enables flexible AI architectures but use with care!\")\n    \n    import asyncio\n    asyncio.run(main())","numLines":830,"startLine":1,"totalLines":830}}}
{"parentUuid":"b39ae093-e960-4cfb-8e4a-08dbc94885be","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_014s3Ac2ah6SaBMhDfw1ZTXf","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Now I'll create the interactive learning notebooks for all these Python files in the order you requested (3, 2, 5, 4). Let me start:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":21349,"cache_read_input_tokens":66522,"output_tokens":1}},"requestId":"req_vrtx_011CRhRePCWGZqYgmToG7wck","type":"assistant","uuid":"9b907628-9fa8-4746-bc9c-4f576d28b748","timestamp":"2025-08-01T17:59:58.492Z"}
{"parentUuid":"9b907628-9fa8-4746-bc9c-4f576d28b748","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_014s3Ac2ah6SaBMhDfw1ZTXf","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_vrtx_01HrrMWitDeuXXkw7Zps9yso","name":"Write","input":{"file_path":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/notebooks/03_functional_programming_learning.ipynb","content":"{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Functional Programming for AI Systems\\n\",\n    \"\\n\",\n    \"This notebook teaches functional programming patterns that make AI code more predictable, testable, and maintainable. You'll learn:\\n\",\n    \"\\n\",\n    \"1. **Immutable Data Structures** - Building predictable AI configurations\\n\",\n    \"2. **Pure Functions** - Creating testable and reliable transformations\\n\",\n    \"3. **Higher-Order Functions** - Composing complex AI operations\\n\",\n    \"4. **Function Composition** - Building pipelines from simple components\\n\",\n    \"5. **Currying & Partial Application** - Creating specialized functions\\n\",\n    \"6. **Monadic Error Handling** - Safe computation chains\\n\",\n    \"7. **Lazy Evaluation** - Efficient processing of large datasets\\n\",\n    \"8. **Memoization** - Caching expensive computations\\n\",\n    \"\\n\",\n    \"## Prerequisites\\n\",\n    \"```bash\\n\",\n    \"pip install rich\\n\",\n    \"```\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 1: Essential Imports and Core Concepts\\n\",\n    \"\\n\",\n    \"**First Principle**: Functional programming emphasizes immutability, pure functions, and composition over mutation and side effects.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `functools` for functional utilities, `dataclasses(frozen=True)` for immutability, and `itertools` for lazy operations.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Essential imports for functional programming\\n\",\n    \"from typing import (\\n\",\n    \"    Callable, List, Dict, Any, Optional, Tuple, Union,\\n\",\n    \"    TypeVar, Iterator, Iterable\\n\",\n    \")\\n\",\n    \"from functools import reduce, partial, singledispatch, lru_cache, wraps\\n\",\n    \"from itertools import chain, groupby, accumulate\\n\",\n    \"from dataclasses import dataclass, replace\\n\",\n    \"from operator import add, mul, itemgetter\\n\",\n    \"import time\\n\",\n    \"from rich.console import Console\\n\",\n    \"from rich.panel import Panel\\n\",\n    \"\\n\",\n    \"console = Console()\\n\",\n    \"T = TypeVar('T')\\n\",\n    \"U = TypeVar('U')\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"🎯 Functional Programming Fundamentals\\\", style=\\\"bold blue\\\"))\\n\",\n    \"print(\\\"\\\"\\\"\\n\",\n    \"Key Principles of Functional Programming:\\n\",\n    \"\\n\",\n    \"1. **Immutability**: Data structures don't change after creation\\n\",\n    \"2. **Pure Functions**: No side effects, same input = same output\\n\",\n    \"3. **Composition**: Building complex operations from simple ones\\n\",\n    \"4. **Higher-Order Functions**: Functions that take or return functions\\n\",\n    \"5. **Lazy Evaluation**: Computing values only when needed\\n\",\n    \"\\n\",\n    \"Benefits for AI Systems:\\n\",\n    \"• Predictable behavior\\n\",\n    \"• Easy testing and debugging\\n\",\n    \"• Parallel processing safety\\n\",\n    \"• Reproducible results\\n\",\n    \"\\\"\\\"\\\")\\n\",\n    \"\\n\",\n    \"print(\\\"✅ Functional programming toolkit loaded!\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 2: Immutable Data Structures\\n\",\n    \"\\n\",\n    \"**First Principle**: Immutable data prevents accidental state changes and makes code more predictable.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `@dataclass(frozen=True)` and `replace()` to create new instances instead of modifying existing ones.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"@dataclass(frozen=True)\\n\",\n    \"class ImmutableConfig:\\n\",\n    \"    \\\"\\\"\\\"Immutable configuration for AI models.\\\"\\\"\\\"\\n\",\n    \"    model_name: str\\n\",\n    \"    temperature: float\\n\",\n    \"    max_tokens: int\\n\",\n    \"    provider: str\\n\",\n    \"    api_key: Optional[str] = None\\n\",\n    \"    \\n\",\n    \"    def with_temperature(self, temperature: float) -> 'ImmutableConfig':\\n\",\n    \"        \\\"\\\"\\\"Create new config with different temperature.\\\"\\\"\\\"\\n\",\n    \"        return replace(self, temperature=temperature)\\n\",\n    \"    \\n\",\n    \"    def with_provider(self, provider: str, api_key: Optional[str] = None) -> 'ImmutableConfig':\\n\",\n    \"        \\\"\\\"\\\"Create new config with different provider.\\\"\\\"\\\"\\n\",\n    \"        return replace(self, provider=provider, api_key=api_key)\\n\",\n    \"\\n\",\n    \"@dataclass(frozen=True)\\n\",\n    \"class ModelPrediction:\\n\",\n    \"    \\\"\\\"\\\"Immutable prediction result.\\\"\\\"\\\"\\n\",\n    \"    text: str\\n\",\n    \"    confidence: float\\n\",\n    \"    model_used: str\\n\",\n    \"    processing_time: float\\n\",\n    \"    metadata: Dict[str, Any]\\n\",\n    \"    \\n\",\n    \"    def with_confidence_threshold(self, threshold: float) -> Optional['ModelPrediction']:\\n\",\n    \"        \\\"\\\"\\\"Return prediction only if confidence meets threshold.\\\"\\\"\\\"\\n\",\n    \"        return self if self.confidence >= threshold else None\\n\",\n    \"    \\n\",\n    \"    def transform_text(self, transformer: Callable[[str], str]) -> 'ModelPrediction':\\n\",\n    \"        \\\"\\\"\\\"Transform text while preserving other fields.\\\"\\\"\\\"\\n\",\n    \"        return replace(self, text=transformer(self.text))\\n\",\n    \"\\n\",\n    \"# Demonstrate immutability\\n\",\n    \"console.print(Panel(\\\"🔒 Immutable Data Structures\\\", style=\\\"bold green\\\"))\\n\",\n    \"\\n\",\n    \"# Create base configuration\\n\",\n    \"base_config = ImmutableConfig(\\n\",\n    \"    model_name=\\\"gpt-4\\\",\\n\",\n    \"    temperature=0.7,\\n\",\n    \"    max_tokens=1000,\\n\",\n    \"    provider=\\\"openai\\\"\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"print(f\\\"📋 Original config: {base_config.model_name} (temp: {base_config.temperature})\\\")\\n\",\n    \"\\n\",\n    \"# Create variations without mutating original\\n\",\n    \"hot_config = base_config.with_temperature(1.2)\\n\",\n    \"anthropic_config = base_config.with_provider(\\\"anthropic\\\", \\\"api-key-123\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"🔥 Hot config: temp={hot_config.temperature}, original unchanged: {base_config.temperature}\\\")\\n\",\n    \"print(f\\\"🏢 Anthropic config: {anthropic_config.provider}, original: {base_config.provider}\\\")\\n\",\n    \"\\n\",\n    \"# Create and transform prediction\\n\",\n    \"prediction = ModelPrediction(\\n\",\n    \"    text=\\\"Hello world\\\",\\n\",\n    \"    confidence=0.85,\\n\",\n    \"    model_used=\\\"gpt-4\\\",\\n\",\n    \"    processing_time=0.1,\\n\",\n    \"    metadata={\\\"source\\\": \\\"test\\\"}\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"upper_prediction = prediction.transform_text(str.upper)\\n\",\n    \"filtered_prediction = prediction.with_confidence_threshold(0.9)\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🔄 Transformations:\\\")\\n\",\n    \"print(f\\\"  Original: '{prediction.text}'\\\")\\n\",\n    \"print(f\\\"  Uppercase: '{upper_prediction.text}'\\\")\\n\",\n    \"print(f\\\"  Filtered (>0.9): {filtered_prediction}\\\")\\n\",\n    \"\\n\",\n    \"# Try to modify frozen dataclass (will fail)\\n\",\n    \"try:\\n\",\n    \"    base_config.temperature = 0.8\\n\",\n    \"except Exception as e:\\n\",\n    \"    print(f\\\"\\\\n❌ Immutability enforced: {type(e).__name__}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 3: Pure Functions\\n\",\n    \"\\n\",\n    \"**First Principle**: Pure functions have no side effects and always return the same output for the same input.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Write functions that only depend on their parameters and don't modify external state.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Pure functions for text processing\\n\",\n    \"def tokenize_text(text: str) -> List[str]:\\n\",\n    \"    \\\"\\\"\\\"Pure function to tokenize text.\\\"\\\"\\\"\\n\",\n    \"    return text.lower().split()\\n\",\n    \"\\n\",\n    \"def count_tokens(tokens: List[str]) -> int:\\n\",\n    \"    \\\"\\\"\\\"Pure function to count tokens.\\\"\\\"\\\"\\n\",\n    \"    return len(tokens)\\n\",\n    \"\\n\",\n    \"def filter_tokens(tokens: List[str], min_length: int = 2) -> List[str]:\\n\",\n    \"    \\\"\\\"\\\"Pure function to filter tokens by length.\\\"\\\"\\\"\\n\",\n    \"    return [token for token in tokens if len(token) >= min_length]\\n\",\n    \"\\n\",\n    \"def calculate_text_stats(text: str) -> Dict[str, Any]:\\n\",\n    \"    \\\"\\\"\\\"Pure function to calculate text statistics.\\\"\\\"\\\"\\n\",\n    \"    tokens = tokenize_text(text)\\n\",\n    \"    filtered_tokens = filter_tokens(tokens)\\n\",\n    \"    \\n\",\n    \"    return {\\n\",\n    \"        \\\"character_count\\\": len(text),\\n\",\n    \"        \\\"word_count\\\": len(tokens),\\n\",\n    \"        \\\"unique_words\\\": len(set(tokens)),\\n\",\n    \"        \\\"filtered_words\\\": len(filtered_tokens),\\n\",\n    \"        \\\"avg_word_length\\\": sum(len(token) for token in tokens) / len(tokens) if tokens else 0\\n\",\n    \"    }\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"✨ Pure Functions\\\", style=\\\"bold blue\\\"))\\n\",\n    \"\\n\",\n    \"test_text = \\\"The Quick Brown Fox Jumps Over The Lazy Dog\\\"\\n\",\n    \"print(f\\\"📝 Processing: '{test_text}'\\\")\\n\",\n    \"\\n\",\n    \"# Pure functions are predictable and testable\\n\",\n    \"tokens = tokenize_text(test_text)\\n\",\n    \"filtered = filter_tokens(tokens, min_length=3)\\n\",\n    \"stats = calculate_text_stats(test_text)\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🔍 Results:\\\")\\n\",\n    \"print(f\\\"  Tokens: {tokens[:5]}... ({len(tokens)} total)\\\")\\n\",\n    \"print(f\\\"  Filtered (len>=3): {filtered[:5]}... ({len(filtered)} total)\\\")\\n\",\n    \"print(f\\\"  Stats: {stats}\\\")\\n\",\n    \"\\n\",\n    \"# Pure functions can be easily tested\\n\",\n    \"print(f\\\"\\\\n🧪 Testing predictability:\\\")\\n\",\n    \"result1 = calculate_text_stats(test_text)\\n\",\n    \"result2 = calculate_text_stats(test_text)\\n\",\n    \"print(f\\\"  Same input, same output: {result1 == result2}\\\")\\n\",\n    \"\\n\",\n    \"# Benefits of pure functions\\n\",\n    \"print(f\\\"\\\\n💡 Benefits of Pure Functions:\\\")\\n\",\n    \"print(f\\\"  ✅ Predictable: Same input always gives same output\\\")\\n\",\n    \"print(f\\\"  ✅ Testable: Easy to write unit tests\\\")\\n\",\n    \"print(f\\\"  ✅ Cacheable: Results can be memoized\\\")\\n\",\n    \"print(f\\\"  ✅ Parallel-safe: No shared state to corrupt\\\")\\n\",\n    \"print(f\\\"  ✅ Composable: Can be combined easily\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 4: Function Composition and Pipelines\\n\",\n    \"\\n\",\n    \"**First Principle**: Complex operations can be built by composing simple functions together.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `reduce()` for composition, create pipeline classes for reusable processing chains.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Function composition utilities\\n\",\n    \"def compose(*functions: Callable) -> Callable:\\n\",\n    \"    \\\"\\\"\\\"Compose functions right to left (mathematical composition).\\\"\\\"\\\"\\n\",\n    \"    return reduce(lambda f, g: lambda x: f(g(x)), functions, lambda x: x)\\n\",\n    \"\\n\",\n    \"def pipe(*functions: Callable) -> Callable:\\n\",\n    \"    \\\"\\\"\\\"Pipe functions left to right (more intuitive for data flow).\\\"\\\"\\\"\\n\",\n    \"    return reduce(lambda f, g: lambda x: g(f(x)), functions, lambda x: x)\\n\",\n    \"\\n\",\n    \"# Functional pipeline class\\n\",\n    \"class FunctionalPipeline:\\n\",\n    \"    \\\"\\\"\\\"Functional pipeline for processing AI data.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self):\\n\",\n    \"        self.steps: List[Callable] = []\\n\",\n    \"    \\n\",\n    \"    def add_step(self, func: Callable) -> 'FunctionalPipeline':\\n\",\n    \"        \\\"\\\"\\\"Add processing step (returns new pipeline).\\\"\\\"\\\"\\n\",\n    \"        new_pipeline = FunctionalPipeline()\\n\",\n    \"        new_pipeline.steps = self.steps + [func]\\n\",\n    \"        return new_pipeline\\n\",\n    \"    \\n\",\n    \"    def process(self, data: Any) -> Any:\\n\",\n    \"        \\\"\\\"\\\"Process data through the pipeline.\\\"\\\"\\\"\\n\",\n    \"        return reduce(lambda result, step: step(result), self.steps, data)\\n\",\n    \"    \\n\",\n    \"    def __call__(self, data: Any) -> Any:\\n\",\n    \"        \\\"\\\"\\\"Make pipeline callable.\\\"\\\"\\\"\\n\",\n    \"        return self.process(data)\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"🔗 Function Composition\\\", style=\\\"bold magenta\\\"))\\n\",\n    \"\\n\",\n    \"# Mathematical composition (right to left)\\n\",\n    \"text_analyzer = compose(\\n\",\n    \"    lambda stats: f\\\"Analysis: {stats['word_count']} words, {stats['unique_words']} unique\\\",\\n\",\n    \"    calculate_text_stats\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"# Pipe composition (left to right) - more intuitive\\n\",\n    \"text_pipeline = pipe(\\n\",\n    \"    str.strip,\\n\",\n    \"    str.lower,\\n\",\n    \"    tokenize_text,\\n\",\n    \"    lambda tokens: filter_tokens(tokens, 2),\\n\",\n    \"    len\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"test_text = \\\"  The Quick Brown Fox Jumps Over The Lazy Dog  \\\"\\n\",\n    \"print(f\\\"📝 Input: '{test_text}'\\\")\\n\",\n    \"\\n\",\n    \"analysis = text_analyzer(test_text)\\n\",\n    \"filtered_count = text_pipeline(test_text)\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n📊 Results:\\\")\\n\",\n    \"print(f\\\"  Composed analysis: {analysis}\\\")\\n\",\n    \"print(f\\\"  Piped processing: {filtered_count} filtered tokens\\\")\\n\",\n    \"\\n\",\n    \"# Using FunctionalPipeline class\\n\",\n    \"pipeline = (FunctionalPipeline()\\n\",\n    \"           .add_step(str.strip)\\n\",\n    \"           .add_step(str.upper)\\n\",\n    \"           .add_step(lambda text: text.replace(\\\" \\\", \\\"_\\\")))\\n\",\n    \"\\n\",\n    \"pipeline_result = pipeline(test_text)\\n\",\n    \"print(f\\\"  Pipeline class result: '{pipeline_result}'\\\")\\n\",\n    \"\\n\",\n    \"# Demonstrate reusability\\n\",\n    \"print(f\\\"\\\\n🔄 Pipeline Reusability:\\\")\\n\",\n    \"test_texts = [\\\"hello world\\\", \\\"python rocks\\\", \\\"AI is amazing\\\"]\\n\",\n    \"results = [pipeline(text) for text in test_texts]\\n\",\n    \"print(f\\\"  Processed: {results}\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Composition Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Modularity: Small, focused functions\\\")\\n\",\n    \"print(f\\\"  ✅ Reusability: Combine in different ways\\\")\\n\",\n    \"print(f\\\"  ✅ Testability: Test each step independently\\\")\\n\",\n    \"print(f\\\"  ✅ Readability: Clear data flow\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 5: Higher-Order Functions\\n\",\n    \"\\n\",\n    \"**First Principle**: Higher-order functions take functions as arguments or return functions, enabling powerful abstractions.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use closures to create specialized functions, leverage `map`, `filter`, and `reduce` for data transformations.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Higher-order functions for AI processing\\n\",\n    \"def create_text_processor(\\n\",\n    \"    transformers: List[Callable[[str], str]]\\n\",\n    \") -> Callable[[str], str]:\\n\",\n    \"    \\\"\\\"\\\"Create composed text processor from list of transformations.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def process(text: str) -> str:\\n\",\n    \"        return reduce(lambda t, transformer: transformer(t), transformers, text)\\n\",\n    \"    \\n\",\n    \"    return process\\n\",\n    \"\\n\",\n    \"def create_confidence_filter(threshold: float) -> Callable[[ModelPrediction], bool]:\\n\",\n    \"    \\\"\\\"\\\"Create a confidence filter function.\\\"\\\"\\\"\\n\",\n    \"    return lambda prediction: prediction.confidence >= threshold\\n\",\n    \"\\n\",\n    \"def create_batch_processor(\\n\",\n    \"    processor: Callable[[T], U],\\n\",\n    \"    batch_size: int = 10\\n\",\n    \") -> Callable[[List[T]], List[U]]:\\n\",\n    \"    \\\"\\\"\\\"Create batch processor from single-item processor.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def process_batch(items: List[T]) -> List[U]:\\n\",\n    \"        results = []\\n\",\n    \"        for i in range(0, len(items), batch_size):\\n\",\n    \"            batch = items[i:i + batch_size]\\n\",\n    \"            batch_results = [processor(item) for item in batch]\\n\",\n    \"            results.extend(batch_results)\\n\",\n    \"        return results\\n\",\n    \"    \\n\",\n    \"    return process_batch\\n\",\n    \"\\n\",\n    \"def create_validator(validation_rules: List[Callable[[Any], bool]]) -> Callable[[Any], bool]:\\n\",\n    \"    \\\"\\\"\\\"Create validator that applies multiple rules.\\\"\\\"\\\"\\n\",\n    \"    return lambda value: all(rule(value) for rule in validation_rules)\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"🚀 Higher-Order Functions\\\", style=\\\"bold cyan\\\"))\\n\",\n    \"\\n\",\n    \"# Create composed text processor\\n\",\n    \"transformers = [\\n\",\n    \"    str.lower,\\n\",\n    \"    lambda text: text.replace(\\\"quick\\\", \\\"QUICK\\\"),\\n\",\n    \"    lambda text: text.replace(\\\"fox\\\", \\\"🦊\\\"),\\n\",\n    \"    str.title\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"processor = create_text_processor(transformers)\\n\",\n    \"test_text = \\\"The Quick Brown Fox\\\"\\n\",\n    \"result = processor(test_text)\\n\",\n    \"\\n\",\n    \"print(f\\\"📝 Text transformation pipeline:\\\")\\n\",\n    \"print(f\\\"  Input: '{test_text}'\\\")\\n\",\n    \"print(f\\\"  Output: '{result}'\\\")\\n\",\n    \"\\n\",\n    \"# Create specialized functions\\n\",\n    \"high_confidence_filter = create_confidence_filter(0.8)\\n\",\n    \"batch_stats_processor = create_batch_processor(calculate_text_stats, batch_size=2)\\n\",\n    \"\\n\",\n    \"# Test batch processor\\n\",\n    \"texts = [\\\"Hello world\\\", \\\"Python is great\\\", \\\"AI is fascinating\\\", \\\"Functional programming rocks\\\"]\\n\",\n    \"batch_stats = batch_stats_processor(texts)\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n📊 Batch processing results:\\\")\\n\",\n    \"for i, stats in enumerate(batch_stats):\\n\",\n    \"    print(f\\\"  Text {i+1}: {stats['word_count']} words, {stats['unique_words']} unique\\\")\\n\",\n    \"\\n\",\n    \"# Create validator with multiple rules\\n\",\n    \"text_validator = create_validator([\\n\",\n    \"    lambda text: isinstance(text, str),\\n\",\n    \"    lambda text: len(text) > 0,\\n\",\n    \"    lambda text: len(text) <= 1000,\\n\",\n    \"    lambda text: not text.isspace()\\n\",\n    \"])\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n✅ Validation tests:\\\")\\n\",\n    \"test_cases = [\\\"Valid text\\\", \\\"\\\", \\\"   \\\", \\\"x\\\" * 1001, 123]\\n\",\n    \"for test_case in test_cases:\\n\",\n    \"    is_valid = text_validator(test_case)\\n\",\n    \"    display = str(test_case)[:20] + \\\"...\\\" if len(str(test_case)) > 20 else str(test_case)\\n\",\n    \"    status = \\\"✅\\\" if is_valid else \\\"❌\\\"\\n\",\n    \"    print(f\\\"  {status} '{display}': {is_valid}\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Higher-Order Functions Enable:\\\")\\n\",\n    \"print(f\\\"  ✅ Abstraction: Hide implementation details\\\")\\n\",\n    \"print(f\\\"  ✅ Customization: Create specialized versions\\\")\\n\",\n    \"print(f\\\"  ✅ Code reuse: One pattern, many applications\\\")\\n\",\n    \"print(f\\\"  ✅ Flexibility: Runtime behavior modification\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 6: Currying and Partial Application\\n\",\n    \"\\n\",\n    \"**First Principle**: Currying transforms functions to enable partial application, creating specialized versions.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `functools.partial` for partial application, create curried functions for flexible APIs.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Currying for AI model predictions\\n\",\n    \"def curry_model_predict(\\n\",\n    \"    model_name: str,\\n\",\n    \"    temperature: float\\n\",\n    \") -> Callable[[str], ModelPrediction]:\\n\",\n    \"    \\\"\\\"\\\"Curried model prediction function.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def predict(text: str) -> ModelPrediction:\\n\",\n    \"        # Mock prediction logic with deterministic \\\"randomness\\\"\\n\",\n    \"        confidence = 0.8 + (hash(text) % 20) / 100\\n\",\n    \"        \\n\",\n    \"        return ModelPrediction(\\n\",\n    \"            text=text,\\n\",\n    \"            confidence=confidence,\\n\",\n    \"            model_used=model_name,\\n\",\n    \"            processing_time=0.1,\\n\",\n    \"            metadata={\\\"temperature\\\": temperature}\\n\",\n    \"        )\\n\",\n    \"    \\n\",\n    \"    return predict\\n\",\n    \"\\n\",\n    \"# General currying utility\\n\",\n    \"def curry_binary(func: Callable[[T, U], Any]) -> Callable[[T], Callable[[U], Any]]:\\n\",\n    \"    \\\"\\\"\\\"Convert binary function to curried form.\\\"\\\"\\\"\\n\",\n    \"    return lambda x: lambda y: func(x, y)\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"🥢 Currying & Partial Application\\\", style=\\\"bold red\\\"))\\n\",\n    \"\\n\",\n    \"# Create specialized model predictors\\n\",\n    \"gpt4_predictor = curry_model_predict(\\\"gpt-4\\\", 0.7)\\n\",\n    \"claude_predictor = curry_model_predict(\\\"claude-3\\\", 0.5)\\n\",\n    \"creative_predictor = curry_model_predict(\\\"gpt-4-creative\\\", 1.2)\\n\",\n    \"\\n\",\n    \"test_texts = [\\\"Hello world\\\", \\\"Python is awesome\\\", \\\"AI will change everything\\\"]\\n\",\n    \"\\n\",\n    \"print(f\\\"🤖 Curried predictions:\\\")\\n\",\n    \"for text in test_texts:\\n\",\n    \"    gpt_pred = gpt4_predictor(text)\\n\",\n    \"    claude_pred = claude_predictor(text)\\n\",\n    \"    creative_pred = creative_predictor(text)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  '{text}':\\\")\\n\",\n    \"    print(f\\\"    GPT-4: {gpt_pred.confidence:.3f} (temp: {gpt_pred.metadata['temperature']})\\\")\\n\",\n    \"    print(f\\\"    Claude: {claude_pred.confidence:.3f} (temp: {claude_pred.metadata['temperature']})\\\")\\n\",\n    \"    print(f\\\"    Creative: {creative_pred.confidence:.3f} (temp: {creative_pred.metadata['temperature']})\\\")\\n\",\n    \"\\n\",\n    \"# Partial application examples\\n\",\n    \"from operator import add, mul\\n\",\n    \"\\n\",\n    \"multiply_by_10 = partial(mul, 10)\\n\",\n    \"add_100 = partial(add, 100)\\n\",\n    \"\\n\",\n    \"# Create specialized text processors\\n\",\n    \"def apply_transformation(text: str, operation: str, value: Any) -> str:\\n\",\n    \"    \\\"\\\"\\\"Apply transformation to text.\\\"\\\"\\\"\\n\",\n    \"    if operation == \\\"prefix\\\":\\n\",\n    \"        return f\\\"{value}{text}\\\"\\n\",\n    \"    elif operation == \\\"suffix\\\":\\n\",\n    \"        return f\\\"{text}{value}\\\"\\n\",\n    \"    elif operation == \\\"replace\\\":\\n\",\n    \"        old, new = value\\n\",\n    \"        return text.replace(old, new)\\n\",\n    \"    return text\\n\",\n    \"\\n\",\n    \"# Create specialized transformers using partial\\n\",\n    \"add_ai_prefix = partial(apply_transformation, operation=\\\"prefix\\\", value=\\\"AI: \\\")\\n\",\n    \"add_processed_suffix = partial(apply_transformation, operation=\\\"suffix\\\", value=\\\" [PROCESSED]\\\")\\n\",\n    \"replace_hello = partial(apply_transformation, operation=\\\"replace\\\", value=(\\\"hello\\\", \\\"greetings\\\"))\\n\",\n    \"\\n\",\n    \"numbers = [1, 2, 3, 4, 5]\\n\",\n    \"multiplied = list(map(multiply_by_10, numbers))\\n\",\n    \"added = list(map(add_100, numbers))\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🔢 Partial application with numbers:\\\")\\n\",\n    \"print(f\\\"  Original: {numbers}\\\")\\n\",\n    \"print(f\\\"  × 10: {multiplied}\\\")\\n\",\n    \"print(f\\\"  + 100: {added}\\\")\\n\",\n    \"\\n\",\n    \"# Apply text transformations\\n\",\n    \"sample_texts = [\\\"hello world\\\", \\\"hello AI\\\", \\\"goodbye world\\\"]\\n\",\n    \"print(f\\\"\\\\n📝 Text transformations:\\\")\\n\",\n    \"for text in sample_texts:\\n\",\n    \"    prefixed = add_ai_prefix(text)\\n\",\n    \"    suffixed = add_processed_suffix(text)\\n\",\n    \"    replaced = replace_hello(text)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  '{text}':\\\")\\n\",\n    \"    print(f\\\"    Prefixed: '{prefixed}'\\\")\\n\",\n    \"    print(f\\\"    Suffixed: '{suffixed}'\\\")\\n\",\n    \"    print(f\\\"    Replaced: '{replaced}'\\\")\\n\",\n    \"\\n\",\n    \"# Curried binary function example\\n\",\n    \"curried_add = curry_binary(add)\\n\",\n    \"add_5 = curried_add(5)\\n\",\n    \"print(f\\\"\\\\n➕ Curried addition:\\\")\\n\",\n    \"print(f\\\"  add_5(10) = {add_5(10)}\\\")\\n\",\n    \"print(f\\\"  add_5(20) = {add_5(20)}\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Currying & Partial Application Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Specialization: Create focused functions\\\")\\n\",\n    \"print(f\\\"  ✅ Reusability: Same logic, different parameters\\\")\\n\",\n    \"print(f\\\"  ✅ Composability: Easier to combine functions\\\")\\n\",\n    \"print(f\\\"  ✅ Configuration: Parameterize behavior\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 7: Monadic Error Handling\\n\",\n    \"\\n\",\n    \"**First Principle**: Monadic patterns enable safe computation chains without explicit error checking at each step.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Create Result/Maybe types that chain operations safely, handling errors gracefully.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Result monad for safe error handling\\n\",\n    \"class Result:\\n\",\n    \"    \\\"\\\"\\\"Monadic Result type for error handling.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, value: Any = None, error: str = None):\\n\",\n    \"        self.value = value\\n\",\n    \"        self.error = error\\n\",\n    \"        self.is_success = error is None\\n\",\n    \"    \\n\",\n    \"    @classmethod\\n\",\n    \"    def success(cls, value: Any) -> 'Result':\\n\",\n    \"        \\\"\\\"\\\"Create successful result.\\\"\\\"\\\"\\n\",\n    \"        return cls(value=value)\\n\",\n    \"    \\n\",\n    \"    @classmethod\\n\",\n    \"    def failure(cls, error: str) -> 'Result':\\n\",\n    \"        \\\"\\\"\\\"Create failed result.\\\"\\\"\\\"\\n\",\n    \"        return cls(error=error)\\n\",\n    \"    \\n\",\n    \"    def map(self, func: Callable) -> 'Result':\\n\",\n    \"        \\\"\\\"\\\"Apply function if successful.\\\"\\\"\\\"\\n\",\n    \"        if self.is_success:\\n\",\n    \"            try:\\n\",\n    \"                return Result.success(func(self.value))\\n\",\n    \"            except Exception as e:\\n\",\n    \"                return Result.failure(str(e))\\n\",\n    \"        return self\\n\",\n    \"    \\n\",\n    \"    def flat_map(self, func: Callable) -> 'Result':\\n\",\n    \"        \\\"\\\"\\\"Apply function that returns Result if successful.\\\"\\\"\\\"\\n\",\n    \"        if self.is_success:\\n\",\n    \"            try:\\n\",\n    \"                return func(self.value)\\n\",\n    \"            except Exception as e:\\n\",\n    \"                return Result.failure(str(e))\\n\",\n    \"        return self\\n\",\n    \"    \\n\",\n    \"    def filter(self, predicate: Callable[[Any], bool], error_msg: str = \\\"Filter failed\\\") -> 'Result':\\n\",\n    \"        \\\"\\\"\\\"Filter result based on predicate.\\\"\\\"\\\"\\n\",\n    \"        if self.is_success and predicate(self.value):\\n\",\n    \"            return self\\n\",\n    \"        return Result.failure(error_msg if self.is_success else self.error)\\n\",\n    \"    \\n\",\n    \"    def get_or_else(self, default: Any) -> Any:\\n\",\n    \"        \\\"\\\"\\\"Get value or return default.\\\"\\\"\\\"\\n\",\n    \"        return self.value if self.is_success else default\\n\",\n    \"    \\n\",\n    \"    def __str__(self) -> str:\\n\",\n    \"        if self.is_success:\\n\",\n    \"            return f\\\"Success({self.value})\\\"\\n\",\n    \"        return f\\\"Failure({self.error})\\\"\\n\",\n    \"\\n\",\n    \"# Safe operations that return Results\\n\",\n    \"def safe_divide(a: float, b: float) -> Result:\\n\",\n    \"    \\\"\\\"\\\"Safe division that returns Result.\\\"\\\"\\\"\\n\",\n    \"    if b == 0:\\n\",\n    \"        return Result.failure(\\\"Division by zero\\\")\\n\",\n    \"    return Result.success(a / b)\\n\",\n    \"\\n\",\n    \"def safe_model_predict(text: str) -> Result:\\n\",\n    \"    \\\"\\\"\\\"Safe model prediction that can fail.\\\"\\\"\\\"\\n\",\n    \"    if not text.strip():\\n\",\n    \"        return Result.failure(\\\"Empty input text\\\")\\n\",\n    \"    \\n\",\n    \"    if len(text) > 1000:\\n\",\n    \"        return Result.failure(\\\"Text too long\\\")\\n\",\n    \"    \\n\",\n    \"    # Mock successful prediction\\n\",\n    \"    prediction = ModelPrediction(\\n\",\n    \"        text=text,\\n\",\n    \"        confidence=0.85,\\n\",\n    \"        model_used=\\\"safe-model\\\",\\n\",\n    \"        processing_time=0.1,\\n\",\n    \"        metadata={}\\n\",\n    \"    )\\n\",\n    \"    \\n\",\n    \"    return Result.success(prediction)\\n\",\n    \"\\n\",\n    \"def safe_parse_number(text: str) -> Result:\\n\",\n    \"    \\\"\\\"\\\"Safely parse number from text.\\\"\\\"\\\"\\n\",\n    \"    try:\\n\",\n    \"        return Result.success(float(text))\\n\",\n    \"    except ValueError:\\n\",\n    \"        return Result.failure(f\\\"Cannot parse '{text}' as number\\\")\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"🔄 Monadic Error Handling\\\", style=\\\"bold yellow\\\"))\\n\",\n    \"\\n\",\n    \"# Chaining operations with error handling\\n\",\n    \"print(f\\\"🧮 Safe calculation chains:\\\")\\n\",\n    \"\\n\",\n    \"result1 = (safe_divide(10, 2)\\n\",\n    \"           .map(lambda x: x * 3)\\n\",\n    \"           .map(lambda x: f\\\"Result: {x}\\\")\\n\",\n    \"           .filter(lambda s: \\\"15\\\" in s, \\\"Result doesn't contain 15\\\"))\\n\",\n    \"\\n\",\n    \"result2 = (safe_divide(10, 0)\\n\",\n    \"           .map(lambda x: x * 3)\\n\",\n    \"           .map(lambda x: f\\\"Result: {x}\\\"))\\n\",\n    \"\\n\",\n    \"print(f\\\"  Chain 1 (10 ÷ 2 × 3): {result1}\\\")\\n\",\n    \"print(f\\\"  Chain 2 (10 ÷ 0 × 3): {result2}\\\")\\n\",\n    \"\\n\",\n    \"# Complex parsing and calculation chain\\n\",\n    \"def calculate_average(numbers_text: List[str]) -> Result:\\n\",\n    \"    \\\"\\\"\\\"Calculate average of numbers from text list.\\\"\\\"\\\"\\n\",\n    \"    if not numbers_text:\\n\",\n    \"        return Result.failure(\\\"Empty list\\\")\\n\",\n    \"    \\n\",\n    \"    # Parse all numbers\\n\",\n    \"    parsed_numbers = []\\n\",\n    \"    for text in numbers_text:\\n\",\n    \"        result = safe_parse_number(text)\\n\",\n    \"        if not result.is_success:\\n\",\n    \"            return result\\n\",\n    \"        parsed_numbers.append(result.value)\\n\",\n    \"    \\n\",\n    \"    # Calculate average\\n\",\n    \"    average = sum(parsed_numbers) / len(parsed_numbers)\\n\",\n    \"    return Result.success(average)\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🔢 Number parsing and calculation:\\\")\\n\",\n    \"test_cases = [\\n\",\n    \"    [\\\"1\\\", \\\"2\\\", \\\"3\\\", \\\"4\\\", \\\"5\\\"],\\n\",\n    \"    [\\\"1.5\\\", \\\"2.5\\\", \\\"3.5\\\"],\\n\",\n    \"    [\\\"1\\\", \\\"not_a_number\\\", \\\"3\\\"],\\n\",\n    \"    []\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"for i, case in enumerate(test_cases, 1):\\n\",\n    \"    result = calculate_average(case)\\n\",\n    \"    print(f\\\"  Case {i} {case}: {result}\\\")\\n\",\n    \"\\n\",\n    \"# Model prediction with error handling\\n\",\n    \"test_cases = [\\\"Hello world\\\", \\\"\\\", \\\"x\\\" * 1001, \\\"Valid input\\\"]\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🤖 Safe model predictions:\\\")\\n\",\n    \"for text in test_cases:\\n\",\n    \"    result = (safe_model_predict(text)\\n\",\n    \"              .map(lambda pred: pred.transform_text(str.upper))\\n\",\n    \"              .filter(lambda pred: pred.confidence > 0.8, \\\"Low confidence\\\"))\\n\",\n    \"    \\n\",\n    \"    display_text = text[:20] + \\\"...\\\" if len(text) > 20 else text\\n\",\n    \"    if result.is_success:\\n\",\n    \"        print(f\\\"  ✅ '{display_text}': confidence {result.value.confidence}\\\")\\n\",\n    \"    else:\\n\",\n    \"        print(f\\\"  ❌ '{display_text}': {result.error}\\\")\\n\",\n    \"\\n\",\n    \"# Demonstrating the power of monadic chaining\\n\",\n    \"def process_user_input(input_text: str) -> str:\\n\",\n    \"    \\\"\\\"\\\"Process user input with comprehensive error handling.\\\"\\\"\\\"\\n\",\n    \"    result = (safe_model_predict(input_text)\\n\",\n    \"              .filter(lambda pred: pred.confidence > 0.7, \\\"Confidence too low\\\")\\n\",\n    \"              .map(lambda pred: pred.transform_text(str.title))\\n\",\n    \"              .map(lambda pred: f\\\"Processed: {pred.text} (confidence: {pred.confidence:.2f})\\\"))\\n\",\n    \"    \\n\",\n    \"    return result.get_or_else(f\\\"Error: {result.error}\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🔄 Complete processing pipeline:\\\")\\n\",\n    \"inputs = [\\\"hello world\\\", \\\"\\\", \\\"this is a good example\\\"]\\n\",\n    \"for inp in inputs:\\n\",\n    \"    output = process_user_input(inp)\\n\",\n    \"    display = inp if inp else \\\"(empty)\\\"\\n\",\n    \"    print(f\\\"  '{display}' → {output}\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Monadic Error Handling Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Safe chaining: No null pointer exceptions\\\")\\n\",\n    \"print(f\\\"  ✅ Explicit errors: All failures are tracked\\\")\\n\",\n    \"print(f\\\"  ✅ Composability: Chain complex operations safely\\\")\\n\",\n    \"print(f\\\"  ✅ Railway-oriented: Success/failure paths clearly separated\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 8: Lazy Evaluation and Generators\\n\",\n    \"\\n\",\n    \"**First Principle**: Lazy evaluation computes values only when needed, enabling efficient processing of large datasets.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use generators (`yield`) for lazy evaluation, `itertools` for lazy operations.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Lazy evaluation with generators\\n\",\n    \"def lazy_text_generator(texts: List[str]) -> Iterator[Dict[str, Any]]:\\n\",\n    \"    \\\"\\\"\\\"Lazily process texts and yield results.\\\"\\\"\\\"\\n\",\n    \"    for i, text in enumerate(texts):\\n\",\n    \"        print(f\\\"🔄 Processing item {i+1}: '{text[:20]}...'\\\")\\n\",\n    \"        # Only compute when needed\\n\",\n    \"        yield {\\n\",\n    \"            \\\"text\\\": text,\\n\",\n    \"            \\\"stats\\\": calculate_text_stats(text),\\n\",\n    \"            \\\"processed_at\\\": time.time(),\\n\",\n    \"            \\\"index\\\": i\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"def create_lazy_pipeline(\\n\",\n    \"    data_source: Iterable[T],\\n\",\n    \"    *processors: Callable[[T], T]\\n\",\n    \") -> Iterator[T]:\\n\",\n    \"    \\\"\\\"\\\"Create lazy processing pipeline.\\\"\\\"\\\"\\n\",\n    \"    for item in data_source:\\n\",\n    \"        result = item\\n\",\n    \"        for processor in processors:\\n\",\n    \"            result = processor(result)\\n\",\n    \"        yield result\\n\",\n    \"\\n\",\n    \"def infinite_text_generator(base_text: str) -> Iterator[str]:\\n\",\n    \"    \\\"\\\"\\\"Generate infinite variations of text.\\\"\\\"\\\"\\n\",\n    \"    counter = 0\\n\",\n    \"    while True:\\n\",\n    \"        yield f\\\"{base_text} (variation {counter})\\\"\\n\",\n    \"        counter += 1\\n\",\n    \"\\n\",\n    \"def chunked_processor(items: Iterable[T], chunk_size: int) -> Iterator[List[T]]:\\n\",\n    \"    \\\"\\\"\\\"Process items in chunks lazily.\\\"\\\"\\\"\\n\",\n    \"    chunk = []\\n\",\n    \"    for item in items:\\n\",\n    \"        chunk.append(item)\\n\",\n    \"        if len(chunk) >= chunk_size:\\n\",\n    \"            yield chunk\\n\",\n    \"            chunk = []\\n\",\n    \"    \\n\",\n    \"    # Yield remaining items\\n\",\n    \"    if chunk:\\n\",\n    \"        yield chunk\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"😴 Lazy Evaluation\\\", style=\\\"bold purple\\\"))\\n\",\n    \"\\n\",\n    \"# Create large dataset (but don't process yet)\\n\",\n    \"large_texts = [f\\\"Sample text number {i} for analysis\\\" for i in range(1000)]\\n\",\n    \"\\n\",\n    \"print(f\\\"📊 Lazy text processing (only processes what we consume):\\\")\\n\",\n    \"\\n\",\n    \"# Process only what we need\\n\",\n    \"lazy_processor = lazy_text_generator(large_texts[:10])\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🔍 Taking only first 3 items:\\\")\\n\",\n    \"count = 0\\n\",\n    \"for processed in lazy_processor:\\n\",\n    \"    if count >= 3:  # Only process first 3\\n\",\n    \"        break\\n\",\n    \"    print(f\\\"  Item {processed['index']}: {processed['stats']['word_count']} words\\\")\\n\",\n    \"    count += 1\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Notice: Only 3 items were actually processed!\\\")\\n\",\n    \"\\n\",\n    \"# Lazy pipeline with generators\\n\",\n    \"def slow_processor(text: str) -> str:\\n\",\n    \"    \\\"\\\"\\\"Simulate slow processing.\\\"\\\"\\\"\\n\",\n    \"    time.sleep(0.001)  # Simulate processing time\\n\",\n    \"    return text.upper()\\n\",\n    \"\\n\",\n    \"def add_prefix(text: str) -> str:\\n\",\n    \"    return f\\\"PROCESSED: {text}\\\"\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🔄 Lazy pipeline (processing on demand):\\\")\\n\",\n    \"\\n\",\n    \"lazy_pipeline = create_lazy_pipeline(\\n\",\n    \"    large_texts[:5],  # Small sample\\n\",\n    \"    slow_processor,\\n\",\n    \"    add_prefix\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"# Only consume what we need\\n\",\n    \"first_two = []\\n\",\n    \"for i, result in enumerate(lazy_pipeline):\\n\",\n    \"    first_two.append(result)\\n\",\n    \"    if i >= 1:  # Only take first 2\\n\",\n    \"        break\\n\",\n    \"\\n\",\n    \"for result in first_two:\\n\",\n    \"    print(f\\\"  {result[:50]}...\\\")\\n\",\n    \"\\n\",\n    \"# Infinite generators (be careful!)\\n\",\n    \"print(f\\\"\\\\n♾️ Infinite generator (limited consumption):\\\")\\n\",\n    \"infinite_gen = infinite_text_generator(\\\"AI prompt\\\")\\n\",\n    \"\\n\",\n    \"# Take only first 5 from infinite sequence\\n\",\n    \"for i, text in enumerate(infinite_gen):\\n\",\n    \"    if i >= 5:\\n\",\n    \"        break\\n\",\n    \"    print(f\\\"  {text}\\\")\\n\",\n    \"\\n\",\n    \"# Chunked processing\\n\",\n    \"print(f\\\"\\\\n📦 Chunked lazy processing:\\\")\\n\",\n    \"numbers = range(23)  # 23 numbers\\n\",\n    \"chunked = chunked_processor(numbers, chunk_size=5)\\n\",\n    \"\\n\",\n    \"for i, chunk in enumerate(chunked):\\n\",\n    \"    print(f\\\"  Chunk {i+1}: {list(chunk)}\\\")\\n\",\n    \"\\n\",\n    \"# Memory efficiency demonstration\\n\",\n    \"from itertools import islice, takewhile, dropwhile\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🧠 Memory-efficient operations with itertools:\\\")\\n\",\n    \"\\n\",\n    \"# Create large range without storing all values\\n\",\n    \"large_range = range(1000000)  # 1 million numbers\\n\",\n    \"\\n\",\n    \"# Take first 5 even numbers greater than 100\\n\",\n    \"result = list(islice(\\n\",\n    \"    filter(lambda x: x % 2 == 0, \\n\",\n    \"           dropwhile(lambda x: x <= 100, large_range)), \\n\",\n    \"    5\\n\",\n    \"))\\n\",\n    \"\\n\",\n    \"print(f\\\"  First 5 even numbers > 100: {result}\\\")\\n\",\n    \"\\n\",\n    \"# Generator expression vs list comprehension\\n\",\n    \"print(f\\\"\\\\n⚡ Generator vs List Memory Usage:\\\")\\n\",\n    \"\\n\",\n    \"# Generator expression - lazy\\n\",\n    \"squares_gen = (x**2 for x in range(10000))\\n\",\n    \"print(f\\\"  Generator created (no memory used yet)\\\")\\n\",\n    \"\\n\",\n    \"# Take only first 3\\n\",\n    \"first_three_squares = [next(squares_gen) for _ in range(3)]\\n\",\n    \"print(f\\\"  First 3 squares: {first_three_squares}\\\")\\n\",\n    \"\\n\",\n    \"# Chain multiple lazy operations\\n\",\n    \"from itertools import chain\\n\",\n    \"\\n\",\n    \"gen1 = (f\\\"AI-{i}\\\" for i in range(3))\\n\",\n    \"gen2 = (f\\\"ML-{i}\\\" for i in range(3))\\n\",\n    \"gen3 = (f\\\"DL-{i}\\\" for i in range(3))\\n\",\n    \"\\n\",\n    \"chained = chain(gen1, gen2, gen3)\\n\",\n    \"all_items = list(chained)\\n\",\n    \"print(f\\\"  Chained generators: {all_items}\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Lazy Evaluation Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Memory efficiency: Process large datasets\\\")\\n\",\n    \"print(f\\\"  ✅ Performance: Only compute what's needed\\\")\\n\",\n    \"print(f\\\"  ✅ Composability: Chain operations without intermediate storage\\\")\\n\",\n    \"print(f\\\"  ✅ Infinite sequences: Work with unbounded data\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 9: Memoization and Caching\\n\",\n    \"\\n\",\n    \"**First Principle**: Memoization caches function results to avoid recomputing expensive operations.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `@lru_cache` for automatic memoization, implement custom caches for specific needs.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Memoization for expensive operations\\n\",\n    \"@lru_cache(maxsize=128)\\n\",\n    \"def expensive_text_analysis(text: str) -> Dict[str, Any]:\\n\",\n    \"    \\\"\\\"\\\"Expensive analysis with memoization.\\\"\\\"\\\"\\n\",\n    \"    print(f\\\"🔍 Computing expensive analysis for: '{text[:30]}...'\\\")\\n\",\n    \"    # Simulate expensive computation\\n\",\n    \"    time.sleep(0.01)\\n\",\n    \"    \\n\",\n    \"    tokens = tokenize_text(text)\\n\",\n    \"    return {\\n\",\n    \"        \\\"complexity_score\\\": len(set(tokens)) / len(tokens) if tokens else 0,\\n\",\n    \"        \\\"sentiment_score\\\": hash(text) % 100 / 100,\\n\",\n    \"        \\\"readability\\\": len(tokens) / text.count('.') if '.' in text else len(tokens),\\n\",\n    \"        \\\"processing_time\\\": 0.01\\n\",\n    \"    }\\n\",\n    \"\\n\",\n    \"# Custom memoization decorator\\n\",\n    \"def memoize_with_ttl(ttl_seconds: float = 60.0):\\n\",\n    \"    \\\"\\\"\\\"Memoization with time-to-live.\\\"\\\"\\\"\\n\",\n    \"    def decorator(func):\\n\",\n    \"        cache = {}\\n\",\n    \"        \\n\",\n    \"        @wraps(func)\\n\",\n    \"        def wrapper(*args, **kwargs):\\n\",\n    \"            # Create cache key\\n\",\n    \"            key = str(args) + str(sorted(kwargs.items()))\\n\",\n    \"            current_time = time.time()\\n\",\n    \"            \\n\",\n    \"            # Check if cached and not expired\\n\",\n    \"            if key in cache:\\n\",\n    \"                result, timestamp = cache[key]\\n\",\n    \"                if current_time - timestamp < ttl_seconds:\\n\",\n    \"                    print(f\\\"💾 Cache hit for {func.__name__}\\\")\\n\",\n    \"                    return result\\n\",\n    \"                else:\\n\",\n    \"                    print(f\\\"⏰ Cache expired for {func.__name__}\\\")\\n\",\n    \"            \\n\",\n    \"            # Compute new result\\n\",\n    \"            print(f\\\"🔄 Cache miss for {func.__name__}\\\")\\n\",\n    \"            result = func(*args, **kwargs)\\n\",\n    \"            cache[key] = (result, current_time)\\n\",\n    \"            return result\\n\",\n    \"        \\n\",\n    \"        # Add cache management methods\\n\",\n    \"        wrapper.clear_cache = lambda: cache.clear()\\n\",\n    \"        wrapper.cache_info = lambda: {\\n\",\n    \"            'size': len(cache),\\n\",\n    \"            'ttl_seconds': ttl_seconds\\n\",\n    \"        }\\n\",\n    \"        \\n\",\n    \"        return wrapper\\n\",\n    \"    return decorator\\n\",\n    \"\\n\",\n    \"@memoize_with_ttl(ttl_seconds=2.0)\\n\",\n    \"def simulate_ai_api_call(query: str, model: str = \\\"gpt-4\\\") -> str:\\n\",\n    \"    \\\"\\\"\\\"Simulate expensive AI API call.\\\"\\\"\\\"\\n\",\n    \"    time.sleep(0.1)  # Simulate network delay\\n\",\n    \"    return f\\\"{model} response to: {query}\\\"\\n\",\n    \"\\n\",\n    \"# Fibonacci with and without memoization (classic example)\\n\",\n    \"def fibonacci_naive(n: int) -> int:\\n\",\n    \"    \\\"\\\"\\\"Naive Fibonacci (exponential time).\\\"\\\"\\\"\\n\",\n    \"    if n <= 1:\\n\",\n    \"        return n\\n\",\n    \"    return fibonacci_naive(n - 1) + fibonacci_naive(n - 2)\\n\",\n    \"\\n\",\n    \"@lru_cache(maxsize=None)\\n\",\n    \"def fibonacci_memoized(n: int) -> int:\\n\",\n    \"    \\\"\\\"\\\"Memoized Fibonacci (linear time).\\\"\\\"\\\"\\n\",\n    \"    if n <= 1:\\n\",\n    \"        return n\\n\",\n    \"    return fibonacci_memoized(n - 1) + fibonacci_memoized(n - 2)\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"🧠 Memoization\\\", style=\\\"bold orange\\\"))\\n\",\n    \"\\n\",\n    \"# Test expensive analysis with repeats\\n\",\n    \"test_texts = [\\n\",\n    \"    \\\"This is a test text for analysis and processing\\\",\\n\",\n    \"    \\\"Another sample text for computational analysis\\\",\\n\",\n    \"    \\\"This is a test text for analysis and processing\\\",  # Duplicate\\n\",\n    \"    \\\"Final text sample for testing our algorithms\\\",\\n\",\n    \"    \\\"Another sample text for computational analysis\\\",  # Duplicate\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"print(f\\\"📊 Memoized expensive analysis:\\\")\\n\",\n    \"\\n\",\n    \"# First run - will compute all\\n\",\n    \"start_time = time.time()\\n\",\n    \"for i, text in enumerate(test_texts, 1):\\n\",\n    \"    analysis = expensive_text_analysis(text)\\n\",\n    \"    print(f\\\"  {i}. Complexity: {analysis['complexity_score']:.3f}\\\")\\n\",\n    \"first_run_time = time.time() - start_time\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n📈 Cache info: {expensive_text_analysis.cache_info()}\\\")\\n\",\n    \"\\n\",\n    \"# Second run - should be faster due to caching\\n\",\n    \"print(f\\\"\\\\n🔄 Running same analysis again (should hit cache):\\\")\\n\",\n    \"start_time = time.time()\\n\",\n    \"for i, text in enumerate(test_texts, 1):\\n\",\n    \"    analysis = expensive_text_analysis(text)\\n\",\n    \"second_run_time = time.time() - start_time\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n⚡ Performance comparison:\\\")\\n\",\n    \"print(f\\\"  First run: {first_run_time:.4f}s\\\")\\n\",\n    \"print(f\\\"  Second run: {second_run_time:.4f}s\\\")\\n\",\n    \"print(f\\\"  Speedup: {first_run_time / second_run_time:.1f}x\\\")\\n\",\n    \"\\n\",\n    \"# Test TTL-based caching\\n\",\n    \"print(f\\\"\\\\n⏰ TTL-based caching (2 second TTL):\\\")\\n\",\n    \"\\n\",\n    \"# First call\\n\",\n    \"result1 = simulate_ai_api_call(\\\"What is AI?\\\", \\\"gpt-4\\\")\\n\",\n    \"print(f\\\"  Result 1: {result1[:30]}...\\\")\\n\",\n    \"\\n\",\n    \"# Second call immediately (should hit cache)\\n\",\n    \"result2 = simulate_ai_api_call(\\\"What is AI?\\\", \\\"gpt-4\\\")\\n\",\n    \"print(f\\\"  Result 2: {result2[:30]}...\\\")\\n\",\n    \"\\n\",\n    \"# Wait for cache to expire\\n\",\n    \"print(f\\\"  Waiting for cache to expire...\\\")\\n\",\n    \"time.sleep(2.1)\\n\",\n    \"\\n\",\n    \"# Third call (should miss cache)\\n\",\n    \"result3 = simulate_ai_api_call(\\\"What is AI?\\\", \\\"gpt-4\\\")\\n\",\n    \"print(f\\\"  Result 3: {result3[:30]}...\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\nCache info: {simulate_ai_api_call.cache_info()}\\\")\\n\",\n    \"\\n\",\n    \"# Fibonacci performance comparison\\n\",\n    \"print(f\\\"\\\\n🔢 Fibonacci performance (memoized vs naive):\\\")\\n\",\n    \"\\n\",\n    \"n = 30\\n\",\n    \"\\n\",\n    \"# Memoized version\\n\",\n    \"start_time = time.time()\\n\",\n    \"fib_memoized = fibonacci_memoized(n)\\n\",\n    \"memoized_time = time.time() - start_time\\n\",\n    \"\\n\",\n    \"print(f\\\"  Memoized fib({n}) = {fib_memoized} in {memoized_time:.6f}s\\\")\\n\",\n    \"print(f\\\"  Cache info: {fibonacci_memoized.cache_info()}\\\")\\n\",\n    \"\\n\",\n    \"# Naive version (only for small n to avoid timeout)\\n\",\n    \"n_small = 25\\n\",\n    \"start_time = time.time()\\n\",\n    \"fib_naive = fibonacci_naive(n_small)\\n\",\n    \"naive_time = time.time() - start_time\\n\",\n    \"\\n\",\n    \"print(f\\\"  Naive fib({n_small}) = {fib_naive} in {naive_time:.6f}s\\\")\\n\",\n    \"print(f\\\"  Speedup for fib({n_small}): {naive_time / memoized_time:.1f}x\\\")\\n\",\n    \"\\n\",\n    \"# Practical memoization patterns\\n\",\n    \"class MemoizedModelProcessor:\\n\",\n    \"    \\\"\\\"\\\"AI processor with built-in memoization.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self):\\n\",\n    \"        self.cache = {}\\n\",\n    \"        self.cache_hits = 0\\n\",\n    \"        self.cache_misses = 0\\n\",\n    \"    \\n\",\n    \"    def process(self, text: str, model_config: Dict[str, Any]) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Process text with caching.\\\"\\\"\\\"\\n\",\n    \"        # Create cache key from text and config\\n\",\n    \"        cache_key = hash(text + str(sorted(model_config.items())))\\n\",\n    \"        \\n\",\n    \"        if cache_key in self.cache:\\n\",\n    \"            self.cache_hits += 1\\n\",\n    \"            return self.cache[cache_key]\\n\",\n    \"        \\n\",\n    \"        # Simulate processing\\n\",\n    \"        self.cache_misses += 1\\n\",\n    \"        result = {\\n\",\n    \"            \\\"processed_text\\\": text.upper(),\\n\",\n    \"            \\\"score\\\": hash(text) % 100 / 100,\\n\",\n    \"            \\\"model_config\\\": model_config\\n\",\n    \"        }\\n\",\n    \"        \\n\",\n    \"        self.cache[cache_key] = result\\n\",\n    \"        return result\\n\",\n    \"    \\n\",\n    \"    def get_cache_stats(self) -> Dict[str, Any]:\\n\",\n    \"        total = self.cache_hits + self.cache_misses\\n\",\n    \"        hit_rate = self.cache_hits / total if total > 0 else 0\\n\",\n    \"        return {\\n\",\n    \"            \\\"cache_size\\\": len(self.cache),\\n\",\n    \"            \\\"hits\\\": self.cache_hits,\\n\",\n    \"            \\\"misses\\\": self.cache_misses,\\n\",\n    \"            \\\"hit_rate\\\": hit_rate\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🤖 Practical memoization in AI processing:\\\")\\n\",\n    \"\\n\",\n    \"processor = MemoizedModelProcessor()\\n\",\n    \"configs = [\\n\",\n    \"    {\\\"temperature\\\": 0.7, \\\"model\\\": \\\"gpt-4\\\"},\\n\",\n    \"    {\\\"temperature\\\": 0.5, \\\"model\\\": \\\"gpt-4\\\"},\\n\",\n    \"    {\\\"temperature\\\": 0.7, \\\"model\\\": \\\"gpt-4\\\"},  # Same as first\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"test_inputs = [\\\"hello world\\\", \\\"python rocks\\\", \\\"hello world\\\"]  # Some repeats\\n\",\n    \"\\n\",\n    \"for i, (text, config) in enumerate(zip(test_inputs, configs), 1):\\n\",\n    \"    result = processor.process(text, config)\\n\",\n    \"    print(f\\\"  {i}. '{text}' → score: {result['score']:.3f}\\\")\\n\",\n    \"\\n\",\n    \"stats = processor.get_cache_stats()\\n\",\n    \"print(f\\\"\\\\n📊 Final cache statistics: {stats}\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Memoization Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Performance: Avoid redundant computations\\\")\\n\",\n    \"print(f\\\"  ✅ Efficiency: Especially good for recursive algorithms\\\")\\n\",\n    \"print(f\\\"  ✅ Transparency: Functions remain pure\\\")\\n\",\n    \"print(f\\\"  ✅ Configurability: TTL, size limits, custom strategies\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 10: Advanced Functional Patterns\\n\",\n    \"\\n\",\n    \"**First Principle**: Advanced patterns combine multiple functional concepts for sophisticated AI architectures.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use single dispatch, decorators, and functional composition to create flexible, maintainable systems.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Single dispatch for different data types\\n\",\n    \"@singledispatch\\n\",\n    \"def process_input(data) -> str:\\n\",\n    \"    \\\"\\\"\\\"Process input data (default implementation).\\\"\\\"\\\"\\n\",\n    \"    return f\\\"Processed unknown type: {type(data).__name__}\\\"\\n\",\n    \"\\n\",\n    \"@process_input.register\\n\",\n    \"def _(data: str) -> str:\\n\",\n    \"    \\\"\\\"\\\"Process string input.\\\"\\\"\\\"\\n\",\n    \"    stats = calculate_text_stats(data)\\n\",\n    \"    return f\\\"String: {stats['word_count']} words, {stats['character_count']} chars\\\"\\n\",\n    \"\\n\",\n    \"@process_input.register\\n\",\n    \"def _(data: list) -> str:\\n\",\n    \"    \\\"\\\"\\\"Process list input.\\\"\\\"\\\"\\n\",\n    \"    return f\\\"List: {len(data)} items, types: {[type(x).__name__ for x in data[:3]]}\\\"\\n\",\n    \"\\n\",\n    \"@process_input.register\\n\",\n    \"def _(data: dict) -> str:\\n\",\n    \"    \\\"\\\"\\\"Process dictionary input.\\\"\\\"\\\"\\n\",\n    \"    return f\\\"Dict: {len(data)} keys: {list(data.keys())[:3]}\\\"\\n\",\n    \"\\n\",\n    \"@process_input.register\\n\",\n    \"def _(data: ModelPrediction) -> str:\\n\",\n    \"    \\\"\\\"\\\"Process model prediction input.\\\"\\\"\\\"\\n\",\n    \"    return f\\\"Prediction: '{data.text}' confidence={data.confidence:.3f}\\\"\\n\",\n    \"\\n\",\n    \"# Functional decorators for AI operations\\n\",\n    \"def validate_input(validator: Callable[[Any], bool], error_msg: str = \\\"Invalid input\\\"):\\n\",\n    \"    \\\"\\\"\\\"Decorator that validates function input.\\\"\\\"\\\"\\n\",\n    \"    def decorator(func):\\n\",\n    \"        @wraps(func)\\n\",\n    \"        def wrapper(*args, **kwargs):\\n\",\n    \"            if args and not validator(args[0]):\\n\",\n    \"                raise ValueError(f\\\"{error_msg}: {args[0]}\\\")\\n\",\n    \"            return func(*args, **kwargs)\\n\",\n    \"        return wrapper\\n\",\n    \"    return decorator\\n\",\n    \"\\n\",\n    \"def retry_with_backoff(max_attempts: int = 3, base_delay: float = 1.0):\\n\",\n    \"    \\\"\\\"\\\"Decorator for retrying failed operations.\\\"\\\"\\\"\\n\",\n    \"    def decorator(func):\\n\",\n    \"        @wraps(func)\\n\",\n    \"        def wrapper(*args, **kwargs):\\n\",\n    \"            last_exception = None\\n\",\n    \"            \\n\",\n    \"            for attempt in range(max_attempts):\\n\",\n    \"                try:\\n\",\n    \"                    return func(*args, **kwargs)\\n\",\n    \"                except Exception as e:\\n\",\n    \"                    last_exception = e\\n\",\n    \"                    if attempt < max_attempts - 1:\\n\",\n    \"                        delay = base_delay * (2 ** attempt)\\n\",\n    \"                        print(f\\\"🔄 Retry {attempt + 1}/{max_attempts} in {delay:.1f}s\\\")\\n\",\n    \"                        time.sleep(delay)\\n\",\n    \"            \\n\",\n    \"            raise last_exception\\n\",\n    \"        return wrapper\\n\",\n    \"    return decorator\\n\",\n    \"\\n\",\n    \"# Complete functional AI pipeline\\n\",\n    \"class FunctionalAIPipeline:\\n\",\n    \"    \\\"\\\"\\\"Complete AI processing pipeline using functional patterns.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self):\\n\",\n    \"        self.processors = []\\n\",\n    \"        self.validators = []\\n\",\n    \"        self.transformers = []\\n\",\n    \"    \\n\",\n    \"    def add_validator(self, validator: Callable[[Any], bool], error_msg: str = \\\"Validation failed\\\"):\\n\",\n    \"        \\\"\\\"\\\"Add input validator.\\\"\\\"\\\"\\n\",\n    \"        self.validators.append((validator, error_msg))\\n\",\n    \"        return self\\n\",\n    \"    \\n\",\n    \"    def add_transformer(self, transformer: Callable[[Any], Any]):\\n\",\n    \"        \\\"\\\"\\\"Add data transformer.\\\"\\\"\\\"\\n\",\n    \"        self.transformers.append(transformer)\\n\",\n    \"        return self\\n\",\n    \"    \\n\",\n    \"    def add_processor(self, processor: Callable[[Any], Any]):\\n\",\n    \"        \\\"\\\"\\\"Add main processor.\\\"\\\"\\\"\\n\",\n    \"        self.processors.append(processor)\\n\",\n    \"        return self\\n\",\n    \"    \\n\",\n    \"    def process(self, data: Any) -> Result:\\n\",\n    \"        \\\"\\\"\\\"Process data through the complete pipeline.\\\"\\\"\\\"\\n\",\n    \"        try:\\n\",\n    \"            # Validation phase\\n\",\n    \"            for validator, error_msg in self.validators:\\n\",\n    \"                if not validator(data):\\n\",\n    \"                    return Result.failure(error_msg)\\n\",\n    \"            \\n\",\n    \"            # Transformation phase\\n\",\n    \"            current_data = data\\n\",\n    \"            for transformer in self.transformers:\\n\",\n    \"                current_data = transformer(current_data)\\n\",\n    \"            \\n\",\n    \"            # Processing phase\\n\",\n    \"            for processor in self.processors:\\n\",\n    \"                current_data = processor(current_data)\\n\",\n    \"            \\n\",\n    \"            return Result.success(current_data)\\n\",\n    \"            \\n\",\n    \"        except Exception as e:\\n\",\n    \"            return Result.failure(str(e))\\n\",\n    \"\\n\",\n    \"# Example functions using decorators\\n\",\n    \"@validate_input(lambda x: isinstance(x, str) and len(x) > 0, \\\"Text must be non-empty string\\\")\\n\",\n    \"@retry_with_backoff(max_attempts=2, base_delay=0.1)\\n\",\n    \"@lru_cache(maxsize=64)\\n\",\n    \"def advanced_text_processor(text: str) -> Dict[str, Any]:\\n\",\n    \"    \\\"\\\"\\\"Advanced text processor with validation, retry, and caching.\\\"\\\"\\\"\\n\",\n    \"    # Simulate potential failure\\n\",\n    \"    import random\\n\",\n    \"    if random.random() < 0.3:  # 30% chance of failure\\n\",\n    \"        raise ConnectionError(\\\"Simulated processing error\\\")\\n\",\n    \"    \\n\",\n    \"    return {\\n\",\n    \"        \\\"processed_text\\\": text.upper(),\\n\",\n    \"        \\\"word_count\\\": len(text.split()),\\n\",\n    \"        \\\"sentiment\\\": \\\"positive\\\" if \\\"good\\\" in text.lower() else \\\"neutral\\\",\\n\",\n    \"        \\\"complexity\\\": len(set(text.lower())) / len(text) if text else 0\\n\",\n    \"    }\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"🚀 Advanced Functional Patterns\\\", style=\\\"bold cyan\\\"))\\n\",\n    \"\\n\",\n    \"# Single dispatch demonstration\\n\",\n    \"test_data = [\\n\",\n    \"    \\\"Hello functional world\\\",\\n\",\n    \"    [1, 2, 3, \\\"text\\\", True],\\n\",\n    \"    {\\\"name\\\": \\\"AI\\\", \\\"type\\\": \\\"system\\\", \\\"version\\\": 1.0},\\n\",\n    \"    ModelPrediction(\\\"test\\\", 0.95, \\\"gpt-4\\\", 0.1, {}),\\n\",\n    \"    42.5\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"print(f\\\"🎯 Single dispatch processing:\\\")\\n\",\n    \"for i, data in enumerate(test_data, 1):\\n\",\n    \"    result = process_input(data)\\n\",\n    \"    print(f\\\"  {i}. {type(data).__name__}: {result}\\\")\\n\",\n    \"\\n\",\n    \"# Advanced processor with decorators\\n\",\n    \"print(f\\\"\\\\n🔧 Advanced processor (validation + retry + caching):\\\")\\n\",\n    \"\\n\",\n    \"test_texts = [\\\"good example\\\", \\\"another test\\\", \\\"good example\\\", \\\"\\\"]  # Last one should fail\\n\",\n    \"\\n\",\n    \"for i, text in enumerate(test_texts, 1):\\n\",\n    \"    try:\\n\",\n    \"        result = advanced_text_processor(text)\\n\",\n    \"        print(f\\\"  {i}. ✅ '{text}': {result['sentiment']} (complexity: {result['complexity']:.3f})\\\")\\n\",\n    \"    except Exception as e:\\n\",\n    \"        print(f\\\"  {i}. ❌ '{text}': {e}\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n📊 Cache info: {advanced_text_processor.cache_info()}\\\")\\n\",\n    \"\\n\",\n    \"# Complete functional pipeline\\n\",\n    \"print(f\\\"\\\\n🔄 Complete functional AI pipeline:\\\")\\n\",\n    \"\\n\",\n    \"pipeline = (FunctionalAIPipeline()\\n\",\n    \"           .add_validator(lambda x: isinstance(x, str), \\\"Input must be string\\\")\\n\",\n    \"           .add_validator(lambda x: len(x.strip()) > 0, \\\"Input must not be empty\\\")\\n\",\n    \"           .add_validator(lambda x: len(x) <= 1000, \\\"Input too long\\\")\\n\",\n    \"           .add_transformer(str.strip)\\n\",\n    \"           .add_transformer(str.lower)\\n\",\n    \"           .add_processor(calculate_text_stats)\\n\",\n    \"           .add_processor(lambda stats: {**stats, \\\"quality_score\\\": stats[\\\"unique_words\\\"] / stats[\\\"word_count\\\"] if stats[\\\"word_count\\\"] > 0 else 0}))\\n\",\n    \"\\n\",\n    \"pipeline_tests = [\\n\",\n    \"    \\\"  This is a great example of functional programming!  \\\",\\n\",\n    \"    \\\"\\\",\\n\",\n    \"    \\\"Short\\\",\\n\",\n    \"    \\\"x\\\" * 1001,  # Too long\\n\",\n    \"    123  # Wrong type\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"for i, test_input in enumerate(pipeline_tests, 1):\\n\",\n    \"    result = pipeline.process(test_input)\\n\",\n    \"    display = str(test_input)[:30] + \\\"...\\\" if len(str(test_input)) > 30 else str(test_input)\\n\",\n    \"    \\n\",\n    \"    if result.is_success:\\n\",\n    \"        data = result.value\\n\",\n    \"        print(f\\\"  {i}. ✅ '{display}': {data['word_count']} words, quality: {data['quality_score']:.3f}\\\")\\n\",\n    \"    else:\\n\",\n    \"        print(f\\\"  {i}. ❌ '{display}': {result.error}\\\")\\n\",\n    \"\\n\",\n    \"# Functional composition showcase\\n\",\n    \"print(f\\\"\\\\n🎼 Functional composition showcase:\\\")\\n\",\n    \"\\n\",\n    \"# Create a complex text processing function by composing simple ones\\n\",\n    \"text_normalizer = pipe(\\n\",\n    \"    str.strip,\\n\",\n    \"    str.lower,\\n\",\n    \"    lambda text: text.replace(\\\"'\\\", \\\"\\\"),  # Remove apostrophes\\n\",\n    \"    lambda text: \\\" \\\".join(text.split())  # Normalize whitespace\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"text_analyzer = compose(\\n\",\n    \"    lambda stats: f\\\"Quality text: {stats['word_count']} words, {stats['unique_words']} unique (quality: {stats['unique_words']/stats['word_count']:.2f})\\\",\\n\",\n    \"    calculate_text_stats,\\n\",\n    \"    text_normalizer\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"messy_text = \\\"  Hello   World!   This   is   a   GREAT   example...   \\\"\\n\",\n    \"analysis = text_analyzer(messy_text)\\n\",\n    \"print(f\\\"  Input: '{messy_text}'\\\")\\n\",\n    \"print(f\\\"  Analysis: {analysis}\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Advanced Functional Programming Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Modularity: Small, composable pieces\\\")\\n\",\n    \"print(f\\\"  ✅ Reliability: Pure functions + error handling\\\")\\n\",\n    \"print(f\\\"  ✅ Performance: Lazy evaluation + memoization\\\")\\n\",\n    \"print(f\\\"  ✅ Maintainability: Clear data flow\\\")\\n\",\n    \"print(f\\\"  ✅ Testability: Each function can be tested independently\\\")\\n\",\n    \"print(f\\\"  ✅ Scalability: Parallel processing safe\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 11: Real-World Application\\n\",\n    \"\\n\",\n    \"**First Principle**: Combine all functional programming concepts to build a production-ready AI text processing system.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use functional patterns as the backbone for reliable, scalable AI applications.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Complete functional AI text processing system\\n\",\n    \"from dataclasses import dataclass\\n\",\n    \"from typing import Protocol\\n\",\n    \"\\n\",\n    \"@dataclass(frozen=True)\\n\",\n    \"class ProcessingConfig:\\n\",\n    \"    \\\"\\\"\\\"Immutable processing configuration.\\\"\\\"\\\"\\n\",\n    \"    min_length: int = 5\\n\",\n    \"    max_length: int = 10000\\n\",\n    \"    enable_sentiment: bool = True\\n\",\n    \"    enable_complexity: bool = True\\n\",\n    \"    cache_ttl: float = 300.0  # 5 minutes\\n\",\n    \"\\n\",\n    \"@dataclass(frozen=True)\\n\",\n    \"class ProcessingResult:\\n\",\n    \"    \\\"\\\"\\\"Immutable processing result.\\\"\\\"\\\"\\n\",\n    \"    original_text: str\\n\",\n    \"    normalized_text: str\\n\",\n    \"    word_count: int\\n\",\n    \"    sentiment: Optional[str] = None\\n\",\n    \"    complexity_score: Optional[float] = None\\n\",\n    \"    processing_time: float = 0.0\\n\",\n    \"    cached: bool = False\\n\",\n    \"\\n\",\n    \"class FunctionalTextProcessor:\\n\",\n    \"    \\\"\\\"\\\"Production-ready functional text processor.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, config: ProcessingConfig):\\n\",\n    \"        self.config = config\\n\",\n    \"        self.cache = {}\\n\",\n    \"        self.metrics = {\\\"total_processed\\\": 0, \\\"cache_hits\\\": 0, \\\"errors\\\": 0}\\n\",\n    \"        \\n\",\n    \"        # Create processing pipeline using functional composition\\n\",\n    \"        self.normalizer = pipe(\\n\",\n    \"            str.strip,\\n\",\n    \"            str.lower,\\n\",\n    \"            lambda text: \\\" \\\".join(text.split())  # Normalize whitespace\\n\",\n    \"        )\\n\",\n    \"        \\n\",\n    \"        # Create validators\\n\",\n    \"        self.validators = [\\n\",\n    \"            (lambda text: isinstance(text, str), \\\"Input must be a string\\\"),\\n\",\n    \"            (lambda text: len(text.strip()) >= self.config.min_length, f\\\"Text too short (min: {self.config.min_length})\\\"),\\n\",\n    \"            (lambda text: len(text) <= self.config.max_length, f\\\"Text too long (max: {self.config.max_length})\\\")\\n\",\n    \"        ]\\n\",\n    \"    \\n\",\n    \"    def _validate_input(self, text: str) -> Result:\\n\",\n    \"        \\\"\\\"\\\"Validate input using functional approach.\\\"\\\"\\\"\\n\",\n    \"        for validator, error_msg in self.validators:\\n\",\n    \"            if not validator(text):\\n\",\n    \"                return Result.failure(error_msg)\\n\",\n    \"        return Result.success(text)\\n\",\n    \"    \\n\",\n    \"    def _get_cache_key(self, text: str) -> str:\\n\",\n    \"        \\\"\\\"\\\"Generate cache key for text.\\\"\\\"\\\"\\n\",\n    \"        config_hash = hash(str(self.config))\\n\",\n    \"        text_hash = hash(text)\\n\",\n    \"        return f\\\"{config_hash}_{text_hash}\\\"\\n\",\n    \"    \\n\",\n    \"    def _check_cache(self, cache_key: str) -> Optional[ProcessingResult]:\\n\",\n    \"        \\\"\\\"\\\"Check if result is cached and not expired.\\\"\\\"\\\"\\n\",\n    \"        if cache_key in self.cache:\\n\",\n    \"            result, timestamp = self.cache[cache_key]\\n\",\n    \"            if time.time() - timestamp < self.config.cache_ttl:\\n\",\n    \"                self.metrics[\\\"cache_hits\\\"] += 1\\n\",\n    \"                # Return new instance with cached flag set\\n\",\n    \"                return replace(result, cached=True)\\n\",\n    \"        return None\\n\",\n    \"    \\n\",\n    \"    def _compute_sentiment(self, text: str) -> str:\\n\",\n    \"        \\\"\\\"\\\"Compute sentiment (simplified).\\\"\\\"\\\"\\n\",\n    \"        positive_words = {'good', 'great', 'excellent', 'amazing', 'wonderful', 'fantastic'}\\n\",\n    \"        negative_words = {'bad', 'terrible', 'awful', 'horrible', 'disgusting', 'hate'}\\n\",\n    \"        \\n\",\n    \"        words = set(text.lower().split())\\n\",\n    \"        positive_count = len(words.intersection(positive_words))\\n\",\n    \"        negative_count = len(words.intersection(negative_words))\\n\",\n    \"        \\n\",\n    \"        if positive_count > negative_count:\\n\",\n    \"            return \\\"positive\\\"\\n\",\n    \"        elif negative_count > positive_count:\\n\",\n    \"            return \\\"negative\\\"\\n\",\n    \"        else:\\n\",\n    \"            return \\\"neutral\\\"\\n\",\n    \"    \\n\",\n    \"    def _compute_complexity(self, text: str) -> float:\\n\",\n    \"        \\\"\\\"\\\"Compute text complexity score.\\\"\\\"\\\"\\n\",\n    \"        words = text.split()\\n\",\n    \"        if not words:\\n\",\n    \"            return 0.0\\n\",\n    \"        \\n\",\n    \"        unique_words = len(set(words))\\n\",\n    \"        total_words = len(words)\\n\",\n    \"        avg_word_length = sum(len(word) for word in words) / total_words\\n\",\n    \"        \\n\",\n    \"        # Complexity combines lexical diversity and word length\\n\",\n    \"        lexical_diversity = unique_words / total_words\\n\",\n    \"        length_factor = min(avg_word_length / 5.0, 1.0)  # Normalize to 0-1\\n\",\n    \"        \\n\",\n    \"        return (lexical_diversity + length_factor) / 2.0\\n\",\n    \"    \\n\",\n    \"    def process(self, text: str) -> Result[ProcessingResult]:\\n\",\n    \"        \\\"\\\"\\\"Process text using functional pipeline.\\\"\\\"\\\"\\n\",\n    \"        start_time = time.time()\\n\",\n    \"        \\n\",\n    \"        try:\\n\",\n    \"            # Validation phase\\n\",\n    \"            validation_result = self._validate_input(text)\\n\",\n    \"            if not validation_result.is_success:\\n\",\n    \"                self.metrics[\\\"errors\\\"] += 1\\n\",\n    \"                return validation_result\\n\",\n    \"            \\n\",\n    \"            # Check cache\\n\",\n    \"            cache_key = self._get_cache_key(text)\\n\",\n    \"            cached_result = self._check_cache(cache_key)\\n\",\n    \"            if cached_result:\\n\",\n    \"                return Result.success(cached_result)\\n\",\n    \"            \\n\",\n    \"            # Normalize text\\n\",\n    \"            normalized_text = self.normalizer(text)\\n\",\n    \"            word_count = len(normalized_text.split())\\n\",\n    \"            \\n\",\n    \"            # Optional processing based on config\\n\",\n    \"            sentiment = self._compute_sentiment(normalized_text) if self.config.enable_sentiment else None\\n\",\n    \"            complexity = self._compute_complexity(normalized_text) if self.config.enable_complexity else None\\n\",\n    \"            \\n\",\n    \"            processing_time = time.time() - start_time\\n\",\n    \"            \\n\",\n    \"            # Create result\\n\",\n    \"            result = ProcessingResult(\\n\",\n    \"                original_text=text,\\n\",\n    \"                normalized_text=normalized_text,\\n\",\n    \"                word_count=word_count,\\n\",\n    \"                sentiment=sentiment,\\n\",\n    \"                complexity_score=complexity,\\n\",\n    \"                processing_time=processing_time,\\n\",\n    \"                cached=False\\n\",\n    \"            )\\n\",\n    \"            \\n\",\n    \"            # Cache result\\n\",\n    \"            self.cache[cache_key] = (result, time.time())\\n\",\n    \"            \\n\",\n    \"            # Update metrics\\n\",\n    \"            self.metrics[\\\"total_processed\\\"] += 1\\n\",\n    \"            \\n\",\n    \"            return Result.success(result)\\n\",\n    \"            \\n\",\n    \"        except Exception as e:\\n\",\n    \"            self.metrics[\\\"errors\\\"] += 1\\n\",\n    \"            return Result.failure(f\\\"Processing error: {str(e)}\\\")\\n\",\n    \"    \\n\",\n    \"    def process_batch(self, texts: List[str]) -> List[Result[ProcessingResult]]:\\n\",\n    \"        \\\"\\\"\\\"Process multiple texts efficiently.\\\"\\\"\\\"\\n\",\n    \"        return [self.process(text) for text in texts]\\n\",\n    \"    \\n\",\n    \"    def get_metrics(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get processing metrics.\\\"\\\"\\\"\\n\",\n    \"        total = self.metrics[\\\"total_processed\\\"] + self.metrics[\\\"cache_hits\\\"]\\n\",\n    \"        cache_hit_rate = self.metrics[\\\"cache_hits\\\"] / total if total > 0 else 0\\n\",\n    \"        \\n\",\n    \"        return {\\n\",\n    \"            **self.metrics,\\n\",\n    \"            \\\"cache_size\\\": len(self.cache),\\n\",\n    \"            \\\"cache_hit_rate\\\": cache_hit_rate\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"🏭 Production Functional AI System\\\", style=\\\"bold green\\\"))\\n\",\n    \"\\n\",\n    \"# Create processor with configuration\\n\",\n    \"config = ProcessingConfig(\\n\",\n    \"    min_length=3,\\n\",\n    \"    max_length=500,\\n\",\n    \"    enable_sentiment=True,\\n\",\n    \"    enable_complexity=True,\\n\",\n    \"    cache_ttl=60.0\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"processor = FunctionalTextProcessor(config)\\n\",\n    \"\\n\",\n    \"# Test with various inputs\\n\",\n    \"test_inputs = [\\n\",\n    \"    \\\"This is a great example of functional programming in AI!\\\",\\n\",\n    \"    \\\"Python is an amazing language for data science.\\\",\\n\",\n    \"    \\\"Bad terrible awful experience with this product.\\\",\\n\",\n    \"    \\\"The quick brown fox jumps over the lazy dog.\\\",\\n\",\n    \"    \\\"This is a great example of functional programming in AI!\\\",  # Duplicate for cache test\\n\",\n    \"    \\\"\\\",  # Should fail validation\\n\",\n    \"    \\\"AI\\\",  # Too short\\n\",\n    \"    \\\"Simple text for processing\\\"\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"print(f\\\"🔄 Processing {len(test_inputs)} texts:\\\")\\n\",\n    \"\\n\",\n    \"results = processor.process_batch(test_inputs)\\n\",\n    \"\\n\",\n    \"for i, (text, result) in enumerate(zip(test_inputs, results), 1):\\n\",\n    \"    display_text = text[:40] + \\\"...\\\" if len(text) > 40 else text\\n\",\n    \"    \\n\",\n    \"    if result.is_success:\\n\",\n    \"        data = result.value\\n\",\n    \"        cache_indicator = \\\"💾\\\" if data.cached else \\\"🔄\\\"\\n\",\n    \"        print(f\\\"  {i}. {cache_indicator} '{display_text}'\\\")\\n\",\n    \"        print(f\\\"     Words: {data.word_count}, Sentiment: {data.sentiment}, Complexity: {data.complexity_score:.3f if data.complexity_score else 'N/A'}\\\")\\n\",\n    \"        print(f\\\"     Time: {data.processing_time:.4f}s\\\")\\n\",\n    \"    else:\\n\",\n    \"        print(f\\\"  {i}. ❌ '{display_text}': {result.error}\\\")\\n\",\n    \"\\n\",\n    \"# Show metrics\\n\",\n    \"metrics = processor.get_metrics()\\n\",\n    \"print(f\\\"\\\\n📊 Processing Metrics:\\\")\\n\",\n    \"print(f\\\"  Total processed: {metrics['total_processed']}\\\")\\n\",\n    \"print(f\\\"  Cache hits: {metrics['cache_hits']}\\\")\\n\",\n    \"print(f\\\"  Cache hit rate: {metrics['cache_hit_rate']:.1%}\\\")\\n\",\n    \"print(f\\\"  Errors: {metrics['errors']}\\\")\\n\",\n    \"print(f\\\"  Cache size: {metrics['cache_size']}\\\")\\n\",\n    \"\\n\",\n    \"# Demonstrate functional composition in batch processing\\n\",\n    \"print(f\\\"\\\\n🎯 Functional batch processing with filtering:\\\")\\n\",\n    \"\\n\",\n    \"# Create a functional pipeline for batch processing\\n\",\n    \"batch_processor = pipe(\\n\",\n    \"    # Filter successful results\\n\",\n    \"    lambda results: [r.value for r in results if r.is_success],\\n\",\n    \"    # Filter by sentiment\\n\",\n    \"    lambda data_list: [d for d in data_list if d.sentiment == \\\"positive\\\"],\\n\",\n    \"    # Sort by complexity\\n\",\n    \"    lambda data_list: sorted(data_list, key=lambda d: d.complexity_score or 0, reverse=True),\\n\",\n    \"    # Take top 3\\n\",\n    \"    lambda data_list: data_list[:3]\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"top_positive_complex = batch_processor(results)\\n\",\n    \"\\n\",\n    \"print(f\\\"  Top positive, complex texts:\\\")\\n\",\n    \"for i, data in enumerate(top_positive_complex, 1):\\n\",\n    \"    print(f\\\"    {i}. '{data.original_text[:50]}...' (complexity: {data.complexity_score:.3f})\\\")\\n\",\n    \"\\n\",\n    \"# Show the power of immutability\\n\",\n    \"print(f\\\"\\\\n🔒 Demonstrating immutability benefits:\\\")\\n\",\n    \"original_config = config\\n\",\n    \"new_config = replace(config, enable_sentiment=False, cache_ttl=30.0)\\n\",\n    \"\\n\",\n    \"print(f\\\"  Original config sentiment enabled: {original_config.enable_sentiment}\\\")\\n\",\n    \"print(f\\\"  New config sentiment enabled: {new_config.enable_sentiment}\\\")\\n\",\n    \"print(f\\\"  Original config unchanged: {original_config.enable_sentiment}\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🎉 Production System Highlights:\\\")\\n\",\n    \"print(f\\\"  ✅ Immutable configuration and results\\\")\\n\",\n    \"print(f\\\"  ✅ Pure functions for core processing\\\")\\n\",\n    \"print(f\\\"  ✅ Monadic error handling throughout\\\")\\n\",\n    \"print(f\\\"  ✅ Automatic caching with TTL\\\")\\n\",\n    \"print(f\\\"  ✅ Functional composition for complex operations\\\")\\n\",\n    \"print(f\\\"  ✅ Comprehensive metrics and monitoring\\\")\\n\",\n    \"print(f\\\"  ✅ Thread-safe design (no shared mutable state)\\\")\\n\",\n    \"print(f\\\"  ✅ Easy testing (pure functions)\\\")\\n\",\n    \"print(f\\\"  ✅ Scalable architecture (stateless processing)\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Summary: Functional Programming Mastery\\n\",\n    \"\\n\",\n    \"**🎯 Key Takeaways:**\\n\",\n    \"\\n\",\n    \"1. **Immutability** prevents bugs and enables safe concurrency\\n\",\n    \"2. **Pure Functions** make code predictable and testable\\n\",\n    \"3. **Composition** builds complex systems from simple parts\\n\",\n    \"4. **Higher-Order Functions** enable powerful abstractions\\n\",\n    \"5. **Monadic Error Handling** creates safe computation chains\\n\",\n    \"6. **Lazy Evaluation** provides memory and performance benefits\\n\",\n    \"7. **Memoization** eliminates redundant computations\\n\",\n    \"\\n\",\n    \"**🚀 Next Steps:**\\n\",\n    \"- Apply these patterns to your AI projects\\n\",\n    \"- Combine functional and object-oriented approaches\\n\",\n    \"- Build immutable data pipelines\\n\",\n    \"- Create composable AI model architectures\\n\",\n    \"\\n\",\n    \"**💡 Remember:** Functional programming isn't about avoiding all state—it's about controlling state to make your AI systems more reliable, testable, and maintainable!\"\n   ]\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"Python 3\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.11.0\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 4\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":21349,"cache_read_input_tokens":66522,"output_tokens":1}},"requestId":"req_vrtx_011CRhRePCWGZqYgmToG7wck","type":"assistant","uuid":"d51ec123-bc7a-4dab-b500-40b45dcf44a9","timestamp":"2025-08-01T18:05:49.322Z"}
{"parentUuid":"d51ec123-bc7a-4dab-b500-40b45dcf44a9","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_vrtx_01HrrMWitDeuXXkw7Zps9yso","type":"tool_result","content":"File created successfully at: /home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/notebooks/03_functional_programming_learning.ipynb"}]},"uuid":"0152b606-de3d-4394-ab7e-93c3c00bf5d2","timestamp":"2025-08-01T18:05:49.352Z","toolUseResult":{"type":"create","filePath":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/notebooks/03_functional_programming_learning.ipynb","content":"{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Functional Programming for AI Systems\\n\",\n    \"\\n\",\n    \"This notebook teaches functional programming patterns that make AI code more predictable, testable, and maintainable. You'll learn:\\n\",\n    \"\\n\",\n    \"1. **Immutable Data Structures** - Building predictable AI configurations\\n\",\n    \"2. **Pure Functions** - Creating testable and reliable transformations\\n\",\n    \"3. **Higher-Order Functions** - Composing complex AI operations\\n\",\n    \"4. **Function Composition** - Building pipelines from simple components\\n\",\n    \"5. **Currying & Partial Application** - Creating specialized functions\\n\",\n    \"6. **Monadic Error Handling** - Safe computation chains\\n\",\n    \"7. **Lazy Evaluation** - Efficient processing of large datasets\\n\",\n    \"8. **Memoization** - Caching expensive computations\\n\",\n    \"\\n\",\n    \"## Prerequisites\\n\",\n    \"```bash\\n\",\n    \"pip install rich\\n\",\n    \"```\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 1: Essential Imports and Core Concepts\\n\",\n    \"\\n\",\n    \"**First Principle**: Functional programming emphasizes immutability, pure functions, and composition over mutation and side effects.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `functools` for functional utilities, `dataclasses(frozen=True)` for immutability, and `itertools` for lazy operations.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Essential imports for functional programming\\n\",\n    \"from typing import (\\n\",\n    \"    Callable, List, Dict, Any, Optional, Tuple, Union,\\n\",\n    \"    TypeVar, Iterator, Iterable\\n\",\n    \")\\n\",\n    \"from functools import reduce, partial, singledispatch, lru_cache, wraps\\n\",\n    \"from itertools import chain, groupby, accumulate\\n\",\n    \"from dataclasses import dataclass, replace\\n\",\n    \"from operator import add, mul, itemgetter\\n\",\n    \"import time\\n\",\n    \"from rich.console import Console\\n\",\n    \"from rich.panel import Panel\\n\",\n    \"\\n\",\n    \"console = Console()\\n\",\n    \"T = TypeVar('T')\\n\",\n    \"U = TypeVar('U')\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"🎯 Functional Programming Fundamentals\\\", style=\\\"bold blue\\\"))\\n\",\n    \"print(\\\"\\\"\\\"\\n\",\n    \"Key Principles of Functional Programming:\\n\",\n    \"\\n\",\n    \"1. **Immutability**: Data structures don't change after creation\\n\",\n    \"2. **Pure Functions**: No side effects, same input = same output\\n\",\n    \"3. **Composition**: Building complex operations from simple ones\\n\",\n    \"4. **Higher-Order Functions**: Functions that take or return functions\\n\",\n    \"5. **Lazy Evaluation**: Computing values only when needed\\n\",\n    \"\\n\",\n    \"Benefits for AI Systems:\\n\",\n    \"• Predictable behavior\\n\",\n    \"• Easy testing and debugging\\n\",\n    \"• Parallel processing safety\\n\",\n    \"• Reproducible results\\n\",\n    \"\\\"\\\"\\\")\\n\",\n    \"\\n\",\n    \"print(\\\"✅ Functional programming toolkit loaded!\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 2: Immutable Data Structures\\n\",\n    \"\\n\",\n    \"**First Principle**: Immutable data prevents accidental state changes and makes code more predictable.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `@dataclass(frozen=True)` and `replace()` to create new instances instead of modifying existing ones.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"@dataclass(frozen=True)\\n\",\n    \"class ImmutableConfig:\\n\",\n    \"    \\\"\\\"\\\"Immutable configuration for AI models.\\\"\\\"\\\"\\n\",\n    \"    model_name: str\\n\",\n    \"    temperature: float\\n\",\n    \"    max_tokens: int\\n\",\n    \"    provider: str\\n\",\n    \"    api_key: Optional[str] = None\\n\",\n    \"    \\n\",\n    \"    def with_temperature(self, temperature: float) -> 'ImmutableConfig':\\n\",\n    \"        \\\"\\\"\\\"Create new config with different temperature.\\\"\\\"\\\"\\n\",\n    \"        return replace(self, temperature=temperature)\\n\",\n    \"    \\n\",\n    \"    def with_provider(self, provider: str, api_key: Optional[str] = None) -> 'ImmutableConfig':\\n\",\n    \"        \\\"\\\"\\\"Create new config with different provider.\\\"\\\"\\\"\\n\",\n    \"        return replace(self, provider=provider, api_key=api_key)\\n\",\n    \"\\n\",\n    \"@dataclass(frozen=True)\\n\",\n    \"class ModelPrediction:\\n\",\n    \"    \\\"\\\"\\\"Immutable prediction result.\\\"\\\"\\\"\\n\",\n    \"    text: str\\n\",\n    \"    confidence: float\\n\",\n    \"    model_used: str\\n\",\n    \"    processing_time: float\\n\",\n    \"    metadata: Dict[str, Any]\\n\",\n    \"    \\n\",\n    \"    def with_confidence_threshold(self, threshold: float) -> Optional['ModelPrediction']:\\n\",\n    \"        \\\"\\\"\\\"Return prediction only if confidence meets threshold.\\\"\\\"\\\"\\n\",\n    \"        return self if self.confidence >= threshold else None\\n\",\n    \"    \\n\",\n    \"    def transform_text(self, transformer: Callable[[str], str]) -> 'ModelPrediction':\\n\",\n    \"        \\\"\\\"\\\"Transform text while preserving other fields.\\\"\\\"\\\"\\n\",\n    \"        return replace(self, text=transformer(self.text))\\n\",\n    \"\\n\",\n    \"# Demonstrate immutability\\n\",\n    \"console.print(Panel(\\\"🔒 Immutable Data Structures\\\", style=\\\"bold green\\\"))\\n\",\n    \"\\n\",\n    \"# Create base configuration\\n\",\n    \"base_config = ImmutableConfig(\\n\",\n    \"    model_name=\\\"gpt-4\\\",\\n\",\n    \"    temperature=0.7,\\n\",\n    \"    max_tokens=1000,\\n\",\n    \"    provider=\\\"openai\\\"\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"print(f\\\"📋 Original config: {base_config.model_name} (temp: {base_config.temperature})\\\")\\n\",\n    \"\\n\",\n    \"# Create variations without mutating original\\n\",\n    \"hot_config = base_config.with_temperature(1.2)\\n\",\n    \"anthropic_config = base_config.with_provider(\\\"anthropic\\\", \\\"api-key-123\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"🔥 Hot config: temp={hot_config.temperature}, original unchanged: {base_config.temperature}\\\")\\n\",\n    \"print(f\\\"🏢 Anthropic config: {anthropic_config.provider}, original: {base_config.provider}\\\")\\n\",\n    \"\\n\",\n    \"# Create and transform prediction\\n\",\n    \"prediction = ModelPrediction(\\n\",\n    \"    text=\\\"Hello world\\\",\\n\",\n    \"    confidence=0.85,\\n\",\n    \"    model_used=\\\"gpt-4\\\",\\n\",\n    \"    processing_time=0.1,\\n\",\n    \"    metadata={\\\"source\\\": \\\"test\\\"}\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"upper_prediction = prediction.transform_text(str.upper)\\n\",\n    \"filtered_prediction = prediction.with_confidence_threshold(0.9)\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🔄 Transformations:\\\")\\n\",\n    \"print(f\\\"  Original: '{prediction.text}'\\\")\\n\",\n    \"print(f\\\"  Uppercase: '{upper_prediction.text}'\\\")\\n\",\n    \"print(f\\\"  Filtered (>0.9): {filtered_prediction}\\\")\\n\",\n    \"\\n\",\n    \"# Try to modify frozen dataclass (will fail)\\n\",\n    \"try:\\n\",\n    \"    base_config.temperature = 0.8\\n\",\n    \"except Exception as e:\\n\",\n    \"    print(f\\\"\\\\n❌ Immutability enforced: {type(e).__name__}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 3: Pure Functions\\n\",\n    \"\\n\",\n    \"**First Principle**: Pure functions have no side effects and always return the same output for the same input.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Write functions that only depend on their parameters and don't modify external state.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Pure functions for text processing\\n\",\n    \"def tokenize_text(text: str) -> List[str]:\\n\",\n    \"    \\\"\\\"\\\"Pure function to tokenize text.\\\"\\\"\\\"\\n\",\n    \"    return text.lower().split()\\n\",\n    \"\\n\",\n    \"def count_tokens(tokens: List[str]) -> int:\\n\",\n    \"    \\\"\\\"\\\"Pure function to count tokens.\\\"\\\"\\\"\\n\",\n    \"    return len(tokens)\\n\",\n    \"\\n\",\n    \"def filter_tokens(tokens: List[str], min_length: int = 2) -> List[str]:\\n\",\n    \"    \\\"\\\"\\\"Pure function to filter tokens by length.\\\"\\\"\\\"\\n\",\n    \"    return [token for token in tokens if len(token) >= min_length]\\n\",\n    \"\\n\",\n    \"def calculate_text_stats(text: str) -> Dict[str, Any]:\\n\",\n    \"    \\\"\\\"\\\"Pure function to calculate text statistics.\\\"\\\"\\\"\\n\",\n    \"    tokens = tokenize_text(text)\\n\",\n    \"    filtered_tokens = filter_tokens(tokens)\\n\",\n    \"    \\n\",\n    \"    return {\\n\",\n    \"        \\\"character_count\\\": len(text),\\n\",\n    \"        \\\"word_count\\\": len(tokens),\\n\",\n    \"        \\\"unique_words\\\": len(set(tokens)),\\n\",\n    \"        \\\"filtered_words\\\": len(filtered_tokens),\\n\",\n    \"        \\\"avg_word_length\\\": sum(len(token) for token in tokens) / len(tokens) if tokens else 0\\n\",\n    \"    }\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"✨ Pure Functions\\\", style=\\\"bold blue\\\"))\\n\",\n    \"\\n\",\n    \"test_text = \\\"The Quick Brown Fox Jumps Over The Lazy Dog\\\"\\n\",\n    \"print(f\\\"📝 Processing: '{test_text}'\\\")\\n\",\n    \"\\n\",\n    \"# Pure functions are predictable and testable\\n\",\n    \"tokens = tokenize_text(test_text)\\n\",\n    \"filtered = filter_tokens(tokens, min_length=3)\\n\",\n    \"stats = calculate_text_stats(test_text)\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🔍 Results:\\\")\\n\",\n    \"print(f\\\"  Tokens: {tokens[:5]}... ({len(tokens)} total)\\\")\\n\",\n    \"print(f\\\"  Filtered (len>=3): {filtered[:5]}... ({len(filtered)} total)\\\")\\n\",\n    \"print(f\\\"  Stats: {stats}\\\")\\n\",\n    \"\\n\",\n    \"# Pure functions can be easily tested\\n\",\n    \"print(f\\\"\\\\n🧪 Testing predictability:\\\")\\n\",\n    \"result1 = calculate_text_stats(test_text)\\n\",\n    \"result2 = calculate_text_stats(test_text)\\n\",\n    \"print(f\\\"  Same input, same output: {result1 == result2}\\\")\\n\",\n    \"\\n\",\n    \"# Benefits of pure functions\\n\",\n    \"print(f\\\"\\\\n💡 Benefits of Pure Functions:\\\")\\n\",\n    \"print(f\\\"  ✅ Predictable: Same input always gives same output\\\")\\n\",\n    \"print(f\\\"  ✅ Testable: Easy to write unit tests\\\")\\n\",\n    \"print(f\\\"  ✅ Cacheable: Results can be memoized\\\")\\n\",\n    \"print(f\\\"  ✅ Parallel-safe: No shared state to corrupt\\\")\\n\",\n    \"print(f\\\"  ✅ Composable: Can be combined easily\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 4: Function Composition and Pipelines\\n\",\n    \"\\n\",\n    \"**First Principle**: Complex operations can be built by composing simple functions together.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `reduce()` for composition, create pipeline classes for reusable processing chains.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Function composition utilities\\n\",\n    \"def compose(*functions: Callable) -> Callable:\\n\",\n    \"    \\\"\\\"\\\"Compose functions right to left (mathematical composition).\\\"\\\"\\\"\\n\",\n    \"    return reduce(lambda f, g: lambda x: f(g(x)), functions, lambda x: x)\\n\",\n    \"\\n\",\n    \"def pipe(*functions: Callable) -> Callable:\\n\",\n    \"    \\\"\\\"\\\"Pipe functions left to right (more intuitive for data flow).\\\"\\\"\\\"\\n\",\n    \"    return reduce(lambda f, g: lambda x: g(f(x)), functions, lambda x: x)\\n\",\n    \"\\n\",\n    \"# Functional pipeline class\\n\",\n    \"class FunctionalPipeline:\\n\",\n    \"    \\\"\\\"\\\"Functional pipeline for processing AI data.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self):\\n\",\n    \"        self.steps: List[Callable] = []\\n\",\n    \"    \\n\",\n    \"    def add_step(self, func: Callable) -> 'FunctionalPipeline':\\n\",\n    \"        \\\"\\\"\\\"Add processing step (returns new pipeline).\\\"\\\"\\\"\\n\",\n    \"        new_pipeline = FunctionalPipeline()\\n\",\n    \"        new_pipeline.steps = self.steps + [func]\\n\",\n    \"        return new_pipeline\\n\",\n    \"    \\n\",\n    \"    def process(self, data: Any) -> Any:\\n\",\n    \"        \\\"\\\"\\\"Process data through the pipeline.\\\"\\\"\\\"\\n\",\n    \"        return reduce(lambda result, step: step(result), self.steps, data)\\n\",\n    \"    \\n\",\n    \"    def __call__(self, data: Any) -> Any:\\n\",\n    \"        \\\"\\\"\\\"Make pipeline callable.\\\"\\\"\\\"\\n\",\n    \"        return self.process(data)\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"🔗 Function Composition\\\", style=\\\"bold magenta\\\"))\\n\",\n    \"\\n\",\n    \"# Mathematical composition (right to left)\\n\",\n    \"text_analyzer = compose(\\n\",\n    \"    lambda stats: f\\\"Analysis: {stats['word_count']} words, {stats['unique_words']} unique\\\",\\n\",\n    \"    calculate_text_stats\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"# Pipe composition (left to right) - more intuitive\\n\",\n    \"text_pipeline = pipe(\\n\",\n    \"    str.strip,\\n\",\n    \"    str.lower,\\n\",\n    \"    tokenize_text,\\n\",\n    \"    lambda tokens: filter_tokens(tokens, 2),\\n\",\n    \"    len\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"test_text = \\\"  The Quick Brown Fox Jumps Over The Lazy Dog  \\\"\\n\",\n    \"print(f\\\"📝 Input: '{test_text}'\\\")\\n\",\n    \"\\n\",\n    \"analysis = text_analyzer(test_text)\\n\",\n    \"filtered_count = text_pipeline(test_text)\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n📊 Results:\\\")\\n\",\n    \"print(f\\\"  Composed analysis: {analysis}\\\")\\n\",\n    \"print(f\\\"  Piped processing: {filtered_count} filtered tokens\\\")\\n\",\n    \"\\n\",\n    \"# Using FunctionalPipeline class\\n\",\n    \"pipeline = (FunctionalPipeline()\\n\",\n    \"           .add_step(str.strip)\\n\",\n    \"           .add_step(str.upper)\\n\",\n    \"           .add_step(lambda text: text.replace(\\\" \\\", \\\"_\\\")))\\n\",\n    \"\\n\",\n    \"pipeline_result = pipeline(test_text)\\n\",\n    \"print(f\\\"  Pipeline class result: '{pipeline_result}'\\\")\\n\",\n    \"\\n\",\n    \"# Demonstrate reusability\\n\",\n    \"print(f\\\"\\\\n🔄 Pipeline Reusability:\\\")\\n\",\n    \"test_texts = [\\\"hello world\\\", \\\"python rocks\\\", \\\"AI is amazing\\\"]\\n\",\n    \"results = [pipeline(text) for text in test_texts]\\n\",\n    \"print(f\\\"  Processed: {results}\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Composition Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Modularity: Small, focused functions\\\")\\n\",\n    \"print(f\\\"  ✅ Reusability: Combine in different ways\\\")\\n\",\n    \"print(f\\\"  ✅ Testability: Test each step independently\\\")\\n\",\n    \"print(f\\\"  ✅ Readability: Clear data flow\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 5: Higher-Order Functions\\n\",\n    \"\\n\",\n    \"**First Principle**: Higher-order functions take functions as arguments or return functions, enabling powerful abstractions.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use closures to create specialized functions, leverage `map`, `filter`, and `reduce` for data transformations.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Higher-order functions for AI processing\\n\",\n    \"def create_text_processor(\\n\",\n    \"    transformers: List[Callable[[str], str]]\\n\",\n    \") -> Callable[[str], str]:\\n\",\n    \"    \\\"\\\"\\\"Create composed text processor from list of transformations.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def process(text: str) -> str:\\n\",\n    \"        return reduce(lambda t, transformer: transformer(t), transformers, text)\\n\",\n    \"    \\n\",\n    \"    return process\\n\",\n    \"\\n\",\n    \"def create_confidence_filter(threshold: float) -> Callable[[ModelPrediction], bool]:\\n\",\n    \"    \\\"\\\"\\\"Create a confidence filter function.\\\"\\\"\\\"\\n\",\n    \"    return lambda prediction: prediction.confidence >= threshold\\n\",\n    \"\\n\",\n    \"def create_batch_processor(\\n\",\n    \"    processor: Callable[[T], U],\\n\",\n    \"    batch_size: int = 10\\n\",\n    \") -> Callable[[List[T]], List[U]]:\\n\",\n    \"    \\\"\\\"\\\"Create batch processor from single-item processor.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def process_batch(items: List[T]) -> List[U]:\\n\",\n    \"        results = []\\n\",\n    \"        for i in range(0, len(items), batch_size):\\n\",\n    \"            batch = items[i:i + batch_size]\\n\",\n    \"            batch_results = [processor(item) for item in batch]\\n\",\n    \"            results.extend(batch_results)\\n\",\n    \"        return results\\n\",\n    \"    \\n\",\n    \"    return process_batch\\n\",\n    \"\\n\",\n    \"def create_validator(validation_rules: List[Callable[[Any], bool]]) -> Callable[[Any], bool]:\\n\",\n    \"    \\\"\\\"\\\"Create validator that applies multiple rules.\\\"\\\"\\\"\\n\",\n    \"    return lambda value: all(rule(value) for rule in validation_rules)\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"🚀 Higher-Order Functions\\\", style=\\\"bold cyan\\\"))\\n\",\n    \"\\n\",\n    \"# Create composed text processor\\n\",\n    \"transformers = [\\n\",\n    \"    str.lower,\\n\",\n    \"    lambda text: text.replace(\\\"quick\\\", \\\"QUICK\\\"),\\n\",\n    \"    lambda text: text.replace(\\\"fox\\\", \\\"🦊\\\"),\\n\",\n    \"    str.title\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"processor = create_text_processor(transformers)\\n\",\n    \"test_text = \\\"The Quick Brown Fox\\\"\\n\",\n    \"result = processor(test_text)\\n\",\n    \"\\n\",\n    \"print(f\\\"📝 Text transformation pipeline:\\\")\\n\",\n    \"print(f\\\"  Input: '{test_text}'\\\")\\n\",\n    \"print(f\\\"  Output: '{result}'\\\")\\n\",\n    \"\\n\",\n    \"# Create specialized functions\\n\",\n    \"high_confidence_filter = create_confidence_filter(0.8)\\n\",\n    \"batch_stats_processor = create_batch_processor(calculate_text_stats, batch_size=2)\\n\",\n    \"\\n\",\n    \"# Test batch processor\\n\",\n    \"texts = [\\\"Hello world\\\", \\\"Python is great\\\", \\\"AI is fascinating\\\", \\\"Functional programming rocks\\\"]\\n\",\n    \"batch_stats = batch_stats_processor(texts)\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n📊 Batch processing results:\\\")\\n\",\n    \"for i, stats in enumerate(batch_stats):\\n\",\n    \"    print(f\\\"  Text {i+1}: {stats['word_count']} words, {stats['unique_words']} unique\\\")\\n\",\n    \"\\n\",\n    \"# Create validator with multiple rules\\n\",\n    \"text_validator = create_validator([\\n\",\n    \"    lambda text: isinstance(text, str),\\n\",\n    \"    lambda text: len(text) > 0,\\n\",\n    \"    lambda text: len(text) <= 1000,\\n\",\n    \"    lambda text: not text.isspace()\\n\",\n    \"])\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n✅ Validation tests:\\\")\\n\",\n    \"test_cases = [\\\"Valid text\\\", \\\"\\\", \\\"   \\\", \\\"x\\\" * 1001, 123]\\n\",\n    \"for test_case in test_cases:\\n\",\n    \"    is_valid = text_validator(test_case)\\n\",\n    \"    display = str(test_case)[:20] + \\\"...\\\" if len(str(test_case)) > 20 else str(test_case)\\n\",\n    \"    status = \\\"✅\\\" if is_valid else \\\"❌\\\"\\n\",\n    \"    print(f\\\"  {status} '{display}': {is_valid}\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Higher-Order Functions Enable:\\\")\\n\",\n    \"print(f\\\"  ✅ Abstraction: Hide implementation details\\\")\\n\",\n    \"print(f\\\"  ✅ Customization: Create specialized versions\\\")\\n\",\n    \"print(f\\\"  ✅ Code reuse: One pattern, many applications\\\")\\n\",\n    \"print(f\\\"  ✅ Flexibility: Runtime behavior modification\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 6: Currying and Partial Application\\n\",\n    \"\\n\",\n    \"**First Principle**: Currying transforms functions to enable partial application, creating specialized versions.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `functools.partial` for partial application, create curried functions for flexible APIs.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Currying for AI model predictions\\n\",\n    \"def curry_model_predict(\\n\",\n    \"    model_name: str,\\n\",\n    \"    temperature: float\\n\",\n    \") -> Callable[[str], ModelPrediction]:\\n\",\n    \"    \\\"\\\"\\\"Curried model prediction function.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def predict(text: str) -> ModelPrediction:\\n\",\n    \"        # Mock prediction logic with deterministic \\\"randomness\\\"\\n\",\n    \"        confidence = 0.8 + (hash(text) % 20) / 100\\n\",\n    \"        \\n\",\n    \"        return ModelPrediction(\\n\",\n    \"            text=text,\\n\",\n    \"            confidence=confidence,\\n\",\n    \"            model_used=model_name,\\n\",\n    \"            processing_time=0.1,\\n\",\n    \"            metadata={\\\"temperature\\\": temperature}\\n\",\n    \"        )\\n\",\n    \"    \\n\",\n    \"    return predict\\n\",\n    \"\\n\",\n    \"# General currying utility\\n\",\n    \"def curry_binary(func: Callable[[T, U], Any]) -> Callable[[T], Callable[[U], Any]]:\\n\",\n    \"    \\\"\\\"\\\"Convert binary function to curried form.\\\"\\\"\\\"\\n\",\n    \"    return lambda x: lambda y: func(x, y)\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"🥢 Currying & Partial Application\\\", style=\\\"bold red\\\"))\\n\",\n    \"\\n\",\n    \"# Create specialized model predictors\\n\",\n    \"gpt4_predictor = curry_model_predict(\\\"gpt-4\\\", 0.7)\\n\",\n    \"claude_predictor = curry_model_predict(\\\"claude-3\\\", 0.5)\\n\",\n    \"creative_predictor = curry_model_predict(\\\"gpt-4-creative\\\", 1.2)\\n\",\n    \"\\n\",\n    \"test_texts = [\\\"Hello world\\\", \\\"Python is awesome\\\", \\\"AI will change everything\\\"]\\n\",\n    \"\\n\",\n    \"print(f\\\"🤖 Curried predictions:\\\")\\n\",\n    \"for text in test_texts:\\n\",\n    \"    gpt_pred = gpt4_predictor(text)\\n\",\n    \"    claude_pred = claude_predictor(text)\\n\",\n    \"    creative_pred = creative_predictor(text)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  '{text}':\\\")\\n\",\n    \"    print(f\\\"    GPT-4: {gpt_pred.confidence:.3f} (temp: {gpt_pred.metadata['temperature']})\\\")\\n\",\n    \"    print(f\\\"    Claude: {claude_pred.confidence:.3f} (temp: {claude_pred.metadata['temperature']})\\\")\\n\",\n    \"    print(f\\\"    Creative: {creative_pred.confidence:.3f} (temp: {creative_pred.metadata['temperature']})\\\")\\n\",\n    \"\\n\",\n    \"# Partial application examples\\n\",\n    \"from operator import add, mul\\n\",\n    \"\\n\",\n    \"multiply_by_10 = partial(mul, 10)\\n\",\n    \"add_100 = partial(add, 100)\\n\",\n    \"\\n\",\n    \"# Create specialized text processors\\n\",\n    \"def apply_transformation(text: str, operation: str, value: Any) -> str:\\n\",\n    \"    \\\"\\\"\\\"Apply transformation to text.\\\"\\\"\\\"\\n\",\n    \"    if operation == \\\"prefix\\\":\\n\",\n    \"        return f\\\"{value}{text}\\\"\\n\",\n    \"    elif operation == \\\"suffix\\\":\\n\",\n    \"        return f\\\"{text}{value}\\\"\\n\",\n    \"    elif operation == \\\"replace\\\":\\n\",\n    \"        old, new = value\\n\",\n    \"        return text.replace(old, new)\\n\",\n    \"    return text\\n\",\n    \"\\n\",\n    \"# Create specialized transformers using partial\\n\",\n    \"add_ai_prefix = partial(apply_transformation, operation=\\\"prefix\\\", value=\\\"AI: \\\")\\n\",\n    \"add_processed_suffix = partial(apply_transformation, operation=\\\"suffix\\\", value=\\\" [PROCESSED]\\\")\\n\",\n    \"replace_hello = partial(apply_transformation, operation=\\\"replace\\\", value=(\\\"hello\\\", \\\"greetings\\\"))\\n\",\n    \"\\n\",\n    \"numbers = [1, 2, 3, 4, 5]\\n\",\n    \"multiplied = list(map(multiply_by_10, numbers))\\n\",\n    \"added = list(map(add_100, numbers))\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🔢 Partial application with numbers:\\\")\\n\",\n    \"print(f\\\"  Original: {numbers}\\\")\\n\",\n    \"print(f\\\"  × 10: {multiplied}\\\")\\n\",\n    \"print(f\\\"  + 100: {added}\\\")\\n\",\n    \"\\n\",\n    \"# Apply text transformations\\n\",\n    \"sample_texts = [\\\"hello world\\\", \\\"hello AI\\\", \\\"goodbye world\\\"]\\n\",\n    \"print(f\\\"\\\\n📝 Text transformations:\\\")\\n\",\n    \"for text in sample_texts:\\n\",\n    \"    prefixed = add_ai_prefix(text)\\n\",\n    \"    suffixed = add_processed_suffix(text)\\n\",\n    \"    replaced = replace_hello(text)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  '{text}':\\\")\\n\",\n    \"    print(f\\\"    Prefixed: '{prefixed}'\\\")\\n\",\n    \"    print(f\\\"    Suffixed: '{suffixed}'\\\")\\n\",\n    \"    print(f\\\"    Replaced: '{replaced}'\\\")\\n\",\n    \"\\n\",\n    \"# Curried binary function example\\n\",\n    \"curried_add = curry_binary(add)\\n\",\n    \"add_5 = curried_add(5)\\n\",\n    \"print(f\\\"\\\\n➕ Curried addition:\\\")\\n\",\n    \"print(f\\\"  add_5(10) = {add_5(10)}\\\")\\n\",\n    \"print(f\\\"  add_5(20) = {add_5(20)}\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Currying & Partial Application Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Specialization: Create focused functions\\\")\\n\",\n    \"print(f\\\"  ✅ Reusability: Same logic, different parameters\\\")\\n\",\n    \"print(f\\\"  ✅ Composability: Easier to combine functions\\\")\\n\",\n    \"print(f\\\"  ✅ Configuration: Parameterize behavior\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 7: Monadic Error Handling\\n\",\n    \"\\n\",\n    \"**First Principle**: Monadic patterns enable safe computation chains without explicit error checking at each step.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Create Result/Maybe types that chain operations safely, handling errors gracefully.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Result monad for safe error handling\\n\",\n    \"class Result:\\n\",\n    \"    \\\"\\\"\\\"Monadic Result type for error handling.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, value: Any = None, error: str = None):\\n\",\n    \"        self.value = value\\n\",\n    \"        self.error = error\\n\",\n    \"        self.is_success = error is None\\n\",\n    \"    \\n\",\n    \"    @classmethod\\n\",\n    \"    def success(cls, value: Any) -> 'Result':\\n\",\n    \"        \\\"\\\"\\\"Create successful result.\\\"\\\"\\\"\\n\",\n    \"        return cls(value=value)\\n\",\n    \"    \\n\",\n    \"    @classmethod\\n\",\n    \"    def failure(cls, error: str) -> 'Result':\\n\",\n    \"        \\\"\\\"\\\"Create failed result.\\\"\\\"\\\"\\n\",\n    \"        return cls(error=error)\\n\",\n    \"    \\n\",\n    \"    def map(self, func: Callable) -> 'Result':\\n\",\n    \"        \\\"\\\"\\\"Apply function if successful.\\\"\\\"\\\"\\n\",\n    \"        if self.is_success:\\n\",\n    \"            try:\\n\",\n    \"                return Result.success(func(self.value))\\n\",\n    \"            except Exception as e:\\n\",\n    \"                return Result.failure(str(e))\\n\",\n    \"        return self\\n\",\n    \"    \\n\",\n    \"    def flat_map(self, func: Callable) -> 'Result':\\n\",\n    \"        \\\"\\\"\\\"Apply function that returns Result if successful.\\\"\\\"\\\"\\n\",\n    \"        if self.is_success:\\n\",\n    \"            try:\\n\",\n    \"                return func(self.value)\\n\",\n    \"            except Exception as e:\\n\",\n    \"                return Result.failure(str(e))\\n\",\n    \"        return self\\n\",\n    \"    \\n\",\n    \"    def filter(self, predicate: Callable[[Any], bool], error_msg: str = \\\"Filter failed\\\") -> 'Result':\\n\",\n    \"        \\\"\\\"\\\"Filter result based on predicate.\\\"\\\"\\\"\\n\",\n    \"        if self.is_success and predicate(self.value):\\n\",\n    \"            return self\\n\",\n    \"        return Result.failure(error_msg if self.is_success else self.error)\\n\",\n    \"    \\n\",\n    \"    def get_or_else(self, default: Any) -> Any:\\n\",\n    \"        \\\"\\\"\\\"Get value or return default.\\\"\\\"\\\"\\n\",\n    \"        return self.value if self.is_success else default\\n\",\n    \"    \\n\",\n    \"    def __str__(self) -> str:\\n\",\n    \"        if self.is_success:\\n\",\n    \"            return f\\\"Success({self.value})\\\"\\n\",\n    \"        return f\\\"Failure({self.error})\\\"\\n\",\n    \"\\n\",\n    \"# Safe operations that return Results\\n\",\n    \"def safe_divide(a: float, b: float) -> Result:\\n\",\n    \"    \\\"\\\"\\\"Safe division that returns Result.\\\"\\\"\\\"\\n\",\n    \"    if b == 0:\\n\",\n    \"        return Result.failure(\\\"Division by zero\\\")\\n\",\n    \"    return Result.success(a / b)\\n\",\n    \"\\n\",\n    \"def safe_model_predict(text: str) -> Result:\\n\",\n    \"    \\\"\\\"\\\"Safe model prediction that can fail.\\\"\\\"\\\"\\n\",\n    \"    if not text.strip():\\n\",\n    \"        return Result.failure(\\\"Empty input text\\\")\\n\",\n    \"    \\n\",\n    \"    if len(text) > 1000:\\n\",\n    \"        return Result.failure(\\\"Text too long\\\")\\n\",\n    \"    \\n\",\n    \"    # Mock successful prediction\\n\",\n    \"    prediction = ModelPrediction(\\n\",\n    \"        text=text,\\n\",\n    \"        confidence=0.85,\\n\",\n    \"        model_used=\\\"safe-model\\\",\\n\",\n    \"        processing_time=0.1,\\n\",\n    \"        metadata={}\\n\",\n    \"    )\\n\",\n    \"    \\n\",\n    \"    return Result.success(prediction)\\n\",\n    \"\\n\",\n    \"def safe_parse_number(text: str) -> Result:\\n\",\n    \"    \\\"\\\"\\\"Safely parse number from text.\\\"\\\"\\\"\\n\",\n    \"    try:\\n\",\n    \"        return Result.success(float(text))\\n\",\n    \"    except ValueError:\\n\",\n    \"        return Result.failure(f\\\"Cannot parse '{text}' as number\\\")\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"🔄 Monadic Error Handling\\\", style=\\\"bold yellow\\\"))\\n\",\n    \"\\n\",\n    \"# Chaining operations with error handling\\n\",\n    \"print(f\\\"🧮 Safe calculation chains:\\\")\\n\",\n    \"\\n\",\n    \"result1 = (safe_divide(10, 2)\\n\",\n    \"           .map(lambda x: x * 3)\\n\",\n    \"           .map(lambda x: f\\\"Result: {x}\\\")\\n\",\n    \"           .filter(lambda s: \\\"15\\\" in s, \\\"Result doesn't contain 15\\\"))\\n\",\n    \"\\n\",\n    \"result2 = (safe_divide(10, 0)\\n\",\n    \"           .map(lambda x: x * 3)\\n\",\n    \"           .map(lambda x: f\\\"Result: {x}\\\"))\\n\",\n    \"\\n\",\n    \"print(f\\\"  Chain 1 (10 ÷ 2 × 3): {result1}\\\")\\n\",\n    \"print(f\\\"  Chain 2 (10 ÷ 0 × 3): {result2}\\\")\\n\",\n    \"\\n\",\n    \"# Complex parsing and calculation chain\\n\",\n    \"def calculate_average(numbers_text: List[str]) -> Result:\\n\",\n    \"    \\\"\\\"\\\"Calculate average of numbers from text list.\\\"\\\"\\\"\\n\",\n    \"    if not numbers_text:\\n\",\n    \"        return Result.failure(\\\"Empty list\\\")\\n\",\n    \"    \\n\",\n    \"    # Parse all numbers\\n\",\n    \"    parsed_numbers = []\\n\",\n    \"    for text in numbers_text:\\n\",\n    \"        result = safe_parse_number(text)\\n\",\n    \"        if not result.is_success:\\n\",\n    \"            return result\\n\",\n    \"        parsed_numbers.append(result.value)\\n\",\n    \"    \\n\",\n    \"    # Calculate average\\n\",\n    \"    average = sum(parsed_numbers) / len(parsed_numbers)\\n\",\n    \"    return Result.success(average)\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🔢 Number parsing and calculation:\\\")\\n\",\n    \"test_cases = [\\n\",\n    \"    [\\\"1\\\", \\\"2\\\", \\\"3\\\", \\\"4\\\", \\\"5\\\"],\\n\",\n    \"    [\\\"1.5\\\", \\\"2.5\\\", \\\"3.5\\\"],\\n\",\n    \"    [\\\"1\\\", \\\"not_a_number\\\", \\\"3\\\"],\\n\",\n    \"    []\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"for i, case in enumerate(test_cases, 1):\\n\",\n    \"    result = calculate_average(case)\\n\",\n    \"    print(f\\\"  Case {i} {case}: {result}\\\")\\n\",\n    \"\\n\",\n    \"# Model prediction with error handling\\n\",\n    \"test_cases = [\\\"Hello world\\\", \\\"\\\", \\\"x\\\" * 1001, \\\"Valid input\\\"]\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🤖 Safe model predictions:\\\")\\n\",\n    \"for text in test_cases:\\n\",\n    \"    result = (safe_model_predict(text)\\n\",\n    \"              .map(lambda pred: pred.transform_text(str.upper))\\n\",\n    \"              .filter(lambda pred: pred.confidence > 0.8, \\\"Low confidence\\\"))\\n\",\n    \"    \\n\",\n    \"    display_text = text[:20] + \\\"...\\\" if len(text) > 20 else text\\n\",\n    \"    if result.is_success:\\n\",\n    \"        print(f\\\"  ✅ '{display_text}': confidence {result.value.confidence}\\\")\\n\",\n    \"    else:\\n\",\n    \"        print(f\\\"  ❌ '{display_text}': {result.error}\\\")\\n\",\n    \"\\n\",\n    \"# Demonstrating the power of monadic chaining\\n\",\n    \"def process_user_input(input_text: str) -> str:\\n\",\n    \"    \\\"\\\"\\\"Process user input with comprehensive error handling.\\\"\\\"\\\"\\n\",\n    \"    result = (safe_model_predict(input_text)\\n\",\n    \"              .filter(lambda pred: pred.confidence > 0.7, \\\"Confidence too low\\\")\\n\",\n    \"              .map(lambda pred: pred.transform_text(str.title))\\n\",\n    \"              .map(lambda pred: f\\\"Processed: {pred.text} (confidence: {pred.confidence:.2f})\\\"))\\n\",\n    \"    \\n\",\n    \"    return result.get_or_else(f\\\"Error: {result.error}\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🔄 Complete processing pipeline:\\\")\\n\",\n    \"inputs = [\\\"hello world\\\", \\\"\\\", \\\"this is a good example\\\"]\\n\",\n    \"for inp in inputs:\\n\",\n    \"    output = process_user_input(inp)\\n\",\n    \"    display = inp if inp else \\\"(empty)\\\"\\n\",\n    \"    print(f\\\"  '{display}' → {output}\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Monadic Error Handling Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Safe chaining: No null pointer exceptions\\\")\\n\",\n    \"print(f\\\"  ✅ Explicit errors: All failures are tracked\\\")\\n\",\n    \"print(f\\\"  ✅ Composability: Chain complex operations safely\\\")\\n\",\n    \"print(f\\\"  ✅ Railway-oriented: Success/failure paths clearly separated\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 8: Lazy Evaluation and Generators\\n\",\n    \"\\n\",\n    \"**First Principle**: Lazy evaluation computes values only when needed, enabling efficient processing of large datasets.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use generators (`yield`) for lazy evaluation, `itertools` for lazy operations.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Lazy evaluation with generators\\n\",\n    \"def lazy_text_generator(texts: List[str]) -> Iterator[Dict[str, Any]]:\\n\",\n    \"    \\\"\\\"\\\"Lazily process texts and yield results.\\\"\\\"\\\"\\n\",\n    \"    for i, text in enumerate(texts):\\n\",\n    \"        print(f\\\"🔄 Processing item {i+1}: '{text[:20]}...'\\\")\\n\",\n    \"        # Only compute when needed\\n\",\n    \"        yield {\\n\",\n    \"            \\\"text\\\": text,\\n\",\n    \"            \\\"stats\\\": calculate_text_stats(text),\\n\",\n    \"            \\\"processed_at\\\": time.time(),\\n\",\n    \"            \\\"index\\\": i\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"def create_lazy_pipeline(\\n\",\n    \"    data_source: Iterable[T],\\n\",\n    \"    *processors: Callable[[T], T]\\n\",\n    \") -> Iterator[T]:\\n\",\n    \"    \\\"\\\"\\\"Create lazy processing pipeline.\\\"\\\"\\\"\\n\",\n    \"    for item in data_source:\\n\",\n    \"        result = item\\n\",\n    \"        for processor in processors:\\n\",\n    \"            result = processor(result)\\n\",\n    \"        yield result\\n\",\n    \"\\n\",\n    \"def infinite_text_generator(base_text: str) -> Iterator[str]:\\n\",\n    \"    \\\"\\\"\\\"Generate infinite variations of text.\\\"\\\"\\\"\\n\",\n    \"    counter = 0\\n\",\n    \"    while True:\\n\",\n    \"        yield f\\\"{base_text} (variation {counter})\\\"\\n\",\n    \"        counter += 1\\n\",\n    \"\\n\",\n    \"def chunked_processor(items: Iterable[T], chunk_size: int) -> Iterator[List[T]]:\\n\",\n    \"    \\\"\\\"\\\"Process items in chunks lazily.\\\"\\\"\\\"\\n\",\n    \"    chunk = []\\n\",\n    \"    for item in items:\\n\",\n    \"        chunk.append(item)\\n\",\n    \"        if len(chunk) >= chunk_size:\\n\",\n    \"            yield chunk\\n\",\n    \"            chunk = []\\n\",\n    \"    \\n\",\n    \"    # Yield remaining items\\n\",\n    \"    if chunk:\\n\",\n    \"        yield chunk\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"😴 Lazy Evaluation\\\", style=\\\"bold purple\\\"))\\n\",\n    \"\\n\",\n    \"# Create large dataset (but don't process yet)\\n\",\n    \"large_texts = [f\\\"Sample text number {i} for analysis\\\" for i in range(1000)]\\n\",\n    \"\\n\",\n    \"print(f\\\"📊 Lazy text processing (only processes what we consume):\\\")\\n\",\n    \"\\n\",\n    \"# Process only what we need\\n\",\n    \"lazy_processor = lazy_text_generator(large_texts[:10])\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🔍 Taking only first 3 items:\\\")\\n\",\n    \"count = 0\\n\",\n    \"for processed in lazy_processor:\\n\",\n    \"    if count >= 3:  # Only process first 3\\n\",\n    \"        break\\n\",\n    \"    print(f\\\"  Item {processed['index']}: {processed['stats']['word_count']} words\\\")\\n\",\n    \"    count += 1\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Notice: Only 3 items were actually processed!\\\")\\n\",\n    \"\\n\",\n    \"# Lazy pipeline with generators\\n\",\n    \"def slow_processor(text: str) -> str:\\n\",\n    \"    \\\"\\\"\\\"Simulate slow processing.\\\"\\\"\\\"\\n\",\n    \"    time.sleep(0.001)  # Simulate processing time\\n\",\n    \"    return text.upper()\\n\",\n    \"\\n\",\n    \"def add_prefix(text: str) -> str:\\n\",\n    \"    return f\\\"PROCESSED: {text}\\\"\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🔄 Lazy pipeline (processing on demand):\\\")\\n\",\n    \"\\n\",\n    \"lazy_pipeline = create_lazy_pipeline(\\n\",\n    \"    large_texts[:5],  # Small sample\\n\",\n    \"    slow_processor,\\n\",\n    \"    add_prefix\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"# Only consume what we need\\n\",\n    \"first_two = []\\n\",\n    \"for i, result in enumerate(lazy_pipeline):\\n\",\n    \"    first_two.append(result)\\n\",\n    \"    if i >= 1:  # Only take first 2\\n\",\n    \"        break\\n\",\n    \"\\n\",\n    \"for result in first_two:\\n\",\n    \"    print(f\\\"  {result[:50]}...\\\")\\n\",\n    \"\\n\",\n    \"# Infinite generators (be careful!)\\n\",\n    \"print(f\\\"\\\\n♾️ Infinite generator (limited consumption):\\\")\\n\",\n    \"infinite_gen = infinite_text_generator(\\\"AI prompt\\\")\\n\",\n    \"\\n\",\n    \"# Take only first 5 from infinite sequence\\n\",\n    \"for i, text in enumerate(infinite_gen):\\n\",\n    \"    if i >= 5:\\n\",\n    \"        break\\n\",\n    \"    print(f\\\"  {text}\\\")\\n\",\n    \"\\n\",\n    \"# Chunked processing\\n\",\n    \"print(f\\\"\\\\n📦 Chunked lazy processing:\\\")\\n\",\n    \"numbers = range(23)  # 23 numbers\\n\",\n    \"chunked = chunked_processor(numbers, chunk_size=5)\\n\",\n    \"\\n\",\n    \"for i, chunk in enumerate(chunked):\\n\",\n    \"    print(f\\\"  Chunk {i+1}: {list(chunk)}\\\")\\n\",\n    \"\\n\",\n    \"# Memory efficiency demonstration\\n\",\n    \"from itertools import islice, takewhile, dropwhile\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🧠 Memory-efficient operations with itertools:\\\")\\n\",\n    \"\\n\",\n    \"# Create large range without storing all values\\n\",\n    \"large_range = range(1000000)  # 1 million numbers\\n\",\n    \"\\n\",\n    \"# Take first 5 even numbers greater than 100\\n\",\n    \"result = list(islice(\\n\",\n    \"    filter(lambda x: x % 2 == 0, \\n\",\n    \"           dropwhile(lambda x: x <= 100, large_range)), \\n\",\n    \"    5\\n\",\n    \"))\\n\",\n    \"\\n\",\n    \"print(f\\\"  First 5 even numbers > 100: {result}\\\")\\n\",\n    \"\\n\",\n    \"# Generator expression vs list comprehension\\n\",\n    \"print(f\\\"\\\\n⚡ Generator vs List Memory Usage:\\\")\\n\",\n    \"\\n\",\n    \"# Generator expression - lazy\\n\",\n    \"squares_gen = (x**2 for x in range(10000))\\n\",\n    \"print(f\\\"  Generator created (no memory used yet)\\\")\\n\",\n    \"\\n\",\n    \"# Take only first 3\\n\",\n    \"first_three_squares = [next(squares_gen) for _ in range(3)]\\n\",\n    \"print(f\\\"  First 3 squares: {first_three_squares}\\\")\\n\",\n    \"\\n\",\n    \"# Chain multiple lazy operations\\n\",\n    \"from itertools import chain\\n\",\n    \"\\n\",\n    \"gen1 = (f\\\"AI-{i}\\\" for i in range(3))\\n\",\n    \"gen2 = (f\\\"ML-{i}\\\" for i in range(3))\\n\",\n    \"gen3 = (f\\\"DL-{i}\\\" for i in range(3))\\n\",\n    \"\\n\",\n    \"chained = chain(gen1, gen2, gen3)\\n\",\n    \"all_items = list(chained)\\n\",\n    \"print(f\\\"  Chained generators: {all_items}\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Lazy Evaluation Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Memory efficiency: Process large datasets\\\")\\n\",\n    \"print(f\\\"  ✅ Performance: Only compute what's needed\\\")\\n\",\n    \"print(f\\\"  ✅ Composability: Chain operations without intermediate storage\\\")\\n\",\n    \"print(f\\\"  ✅ Infinite sequences: Work with unbounded data\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 9: Memoization and Caching\\n\",\n    \"\\n\",\n    \"**First Principle**: Memoization caches function results to avoid recomputing expensive operations.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `@lru_cache` for automatic memoization, implement custom caches for specific needs.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Memoization for expensive operations\\n\",\n    \"@lru_cache(maxsize=128)\\n\",\n    \"def expensive_text_analysis(text: str) -> Dict[str, Any]:\\n\",\n    \"    \\\"\\\"\\\"Expensive analysis with memoization.\\\"\\\"\\\"\\n\",\n    \"    print(f\\\"🔍 Computing expensive analysis for: '{text[:30]}...'\\\")\\n\",\n    \"    # Simulate expensive computation\\n\",\n    \"    time.sleep(0.01)\\n\",\n    \"    \\n\",\n    \"    tokens = tokenize_text(text)\\n\",\n    \"    return {\\n\",\n    \"        \\\"complexity_score\\\": len(set(tokens)) / len(tokens) if tokens else 0,\\n\",\n    \"        \\\"sentiment_score\\\": hash(text) % 100 / 100,\\n\",\n    \"        \\\"readability\\\": len(tokens) / text.count('.') if '.' in text else len(tokens),\\n\",\n    \"        \\\"processing_time\\\": 0.01\\n\",\n    \"    }\\n\",\n    \"\\n\",\n    \"# Custom memoization decorator\\n\",\n    \"def memoize_with_ttl(ttl_seconds: float = 60.0):\\n\",\n    \"    \\\"\\\"\\\"Memoization with time-to-live.\\\"\\\"\\\"\\n\",\n    \"    def decorator(func):\\n\",\n    \"        cache = {}\\n\",\n    \"        \\n\",\n    \"        @wraps(func)\\n\",\n    \"        def wrapper(*args, **kwargs):\\n\",\n    \"            # Create cache key\\n\",\n    \"            key = str(args) + str(sorted(kwargs.items()))\\n\",\n    \"            current_time = time.time()\\n\",\n    \"            \\n\",\n    \"            # Check if cached and not expired\\n\",\n    \"            if key in cache:\\n\",\n    \"                result, timestamp = cache[key]\\n\",\n    \"                if current_time - timestamp < ttl_seconds:\\n\",\n    \"                    print(f\\\"💾 Cache hit for {func.__name__}\\\")\\n\",\n    \"                    return result\\n\",\n    \"                else:\\n\",\n    \"                    print(f\\\"⏰ Cache expired for {func.__name__}\\\")\\n\",\n    \"            \\n\",\n    \"            # Compute new result\\n\",\n    \"            print(f\\\"🔄 Cache miss for {func.__name__}\\\")\\n\",\n    \"            result = func(*args, **kwargs)\\n\",\n    \"            cache[key] = (result, current_time)\\n\",\n    \"            return result\\n\",\n    \"        \\n\",\n    \"        # Add cache management methods\\n\",\n    \"        wrapper.clear_cache = lambda: cache.clear()\\n\",\n    \"        wrapper.cache_info = lambda: {\\n\",\n    \"            'size': len(cache),\\n\",\n    \"            'ttl_seconds': ttl_seconds\\n\",\n    \"        }\\n\",\n    \"        \\n\",\n    \"        return wrapper\\n\",\n    \"    return decorator\\n\",\n    \"\\n\",\n    \"@memoize_with_ttl(ttl_seconds=2.0)\\n\",\n    \"def simulate_ai_api_call(query: str, model: str = \\\"gpt-4\\\") -> str:\\n\",\n    \"    \\\"\\\"\\\"Simulate expensive AI API call.\\\"\\\"\\\"\\n\",\n    \"    time.sleep(0.1)  # Simulate network delay\\n\",\n    \"    return f\\\"{model} response to: {query}\\\"\\n\",\n    \"\\n\",\n    \"# Fibonacci with and without memoization (classic example)\\n\",\n    \"def fibonacci_naive(n: int) -> int:\\n\",\n    \"    \\\"\\\"\\\"Naive Fibonacci (exponential time).\\\"\\\"\\\"\\n\",\n    \"    if n <= 1:\\n\",\n    \"        return n\\n\",\n    \"    return fibonacci_naive(n - 1) + fibonacci_naive(n - 2)\\n\",\n    \"\\n\",\n    \"@lru_cache(maxsize=None)\\n\",\n    \"def fibonacci_memoized(n: int) -> int:\\n\",\n    \"    \\\"\\\"\\\"Memoized Fibonacci (linear time).\\\"\\\"\\\"\\n\",\n    \"    if n <= 1:\\n\",\n    \"        return n\\n\",\n    \"    return fibonacci_memoized(n - 1) + fibonacci_memoized(n - 2)\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"🧠 Memoization\\\", style=\\\"bold orange\\\"))\\n\",\n    \"\\n\",\n    \"# Test expensive analysis with repeats\\n\",\n    \"test_texts = [\\n\",\n    \"    \\\"This is a test text for analysis and processing\\\",\\n\",\n    \"    \\\"Another sample text for computational analysis\\\",\\n\",\n    \"    \\\"This is a test text for analysis and processing\\\",  # Duplicate\\n\",\n    \"    \\\"Final text sample for testing our algorithms\\\",\\n\",\n    \"    \\\"Another sample text for computational analysis\\\",  # Duplicate\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"print(f\\\"📊 Memoized expensive analysis:\\\")\\n\",\n    \"\\n\",\n    \"# First run - will compute all\\n\",\n    \"start_time = time.time()\\n\",\n    \"for i, text in enumerate(test_texts, 1):\\n\",\n    \"    analysis = expensive_text_analysis(text)\\n\",\n    \"    print(f\\\"  {i}. Complexity: {analysis['complexity_score']:.3f}\\\")\\n\",\n    \"first_run_time = time.time() - start_time\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n📈 Cache info: {expensive_text_analysis.cache_info()}\\\")\\n\",\n    \"\\n\",\n    \"# Second run - should be faster due to caching\\n\",\n    \"print(f\\\"\\\\n🔄 Running same analysis again (should hit cache):\\\")\\n\",\n    \"start_time = time.time()\\n\",\n    \"for i, text in enumerate(test_texts, 1):\\n\",\n    \"    analysis = expensive_text_analysis(text)\\n\",\n    \"second_run_time = time.time() - start_time\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n⚡ Performance comparison:\\\")\\n\",\n    \"print(f\\\"  First run: {first_run_time:.4f}s\\\")\\n\",\n    \"print(f\\\"  Second run: {second_run_time:.4f}s\\\")\\n\",\n    \"print(f\\\"  Speedup: {first_run_time / second_run_time:.1f}x\\\")\\n\",\n    \"\\n\",\n    \"# Test TTL-based caching\\n\",\n    \"print(f\\\"\\\\n⏰ TTL-based caching (2 second TTL):\\\")\\n\",\n    \"\\n\",\n    \"# First call\\n\",\n    \"result1 = simulate_ai_api_call(\\\"What is AI?\\\", \\\"gpt-4\\\")\\n\",\n    \"print(f\\\"  Result 1: {result1[:30]}...\\\")\\n\",\n    \"\\n\",\n    \"# Second call immediately (should hit cache)\\n\",\n    \"result2 = simulate_ai_api_call(\\\"What is AI?\\\", \\\"gpt-4\\\")\\n\",\n    \"print(f\\\"  Result 2: {result2[:30]}...\\\")\\n\",\n    \"\\n\",\n    \"# Wait for cache to expire\\n\",\n    \"print(f\\\"  Waiting for cache to expire...\\\")\\n\",\n    \"time.sleep(2.1)\\n\",\n    \"\\n\",\n    \"# Third call (should miss cache)\\n\",\n    \"result3 = simulate_ai_api_call(\\\"What is AI?\\\", \\\"gpt-4\\\")\\n\",\n    \"print(f\\\"  Result 3: {result3[:30]}...\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\nCache info: {simulate_ai_api_call.cache_info()}\\\")\\n\",\n    \"\\n\",\n    \"# Fibonacci performance comparison\\n\",\n    \"print(f\\\"\\\\n🔢 Fibonacci performance (memoized vs naive):\\\")\\n\",\n    \"\\n\",\n    \"n = 30\\n\",\n    \"\\n\",\n    \"# Memoized version\\n\",\n    \"start_time = time.time()\\n\",\n    \"fib_memoized = fibonacci_memoized(n)\\n\",\n    \"memoized_time = time.time() - start_time\\n\",\n    \"\\n\",\n    \"print(f\\\"  Memoized fib({n}) = {fib_memoized} in {memoized_time:.6f}s\\\")\\n\",\n    \"print(f\\\"  Cache info: {fibonacci_memoized.cache_info()}\\\")\\n\",\n    \"\\n\",\n    \"# Naive version (only for small n to avoid timeout)\\n\",\n    \"n_small = 25\\n\",\n    \"start_time = time.time()\\n\",\n    \"fib_naive = fibonacci_naive(n_small)\\n\",\n    \"naive_time = time.time() - start_time\\n\",\n    \"\\n\",\n    \"print(f\\\"  Naive fib({n_small}) = {fib_naive} in {naive_time:.6f}s\\\")\\n\",\n    \"print(f\\\"  Speedup for fib({n_small}): {naive_time / memoized_time:.1f}x\\\")\\n\",\n    \"\\n\",\n    \"# Practical memoization patterns\\n\",\n    \"class MemoizedModelProcessor:\\n\",\n    \"    \\\"\\\"\\\"AI processor with built-in memoization.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self):\\n\",\n    \"        self.cache = {}\\n\",\n    \"        self.cache_hits = 0\\n\",\n    \"        self.cache_misses = 0\\n\",\n    \"    \\n\",\n    \"    def process(self, text: str, model_config: Dict[str, Any]) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Process text with caching.\\\"\\\"\\\"\\n\",\n    \"        # Create cache key from text and config\\n\",\n    \"        cache_key = hash(text + str(sorted(model_config.items())))\\n\",\n    \"        \\n\",\n    \"        if cache_key in self.cache:\\n\",\n    \"            self.cache_hits += 1\\n\",\n    \"            return self.cache[cache_key]\\n\",\n    \"        \\n\",\n    \"        # Simulate processing\\n\",\n    \"        self.cache_misses += 1\\n\",\n    \"        result = {\\n\",\n    \"            \\\"processed_text\\\": text.upper(),\\n\",\n    \"            \\\"score\\\": hash(text) % 100 / 100,\\n\",\n    \"            \\\"model_config\\\": model_config\\n\",\n    \"        }\\n\",\n    \"        \\n\",\n    \"        self.cache[cache_key] = result\\n\",\n    \"        return result\\n\",\n    \"    \\n\",\n    \"    def get_cache_stats(self) -> Dict[str, Any]:\\n\",\n    \"        total = self.cache_hits + self.cache_misses\\n\",\n    \"        hit_rate = self.cache_hits / total if total > 0 else 0\\n\",\n    \"        return {\\n\",\n    \"            \\\"cache_size\\\": len(self.cache),\\n\",\n    \"            \\\"hits\\\": self.cache_hits,\\n\",\n    \"            \\\"misses\\\": self.cache_misses,\\n\",\n    \"            \\\"hit_rate\\\": hit_rate\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🤖 Practical memoization in AI processing:\\\")\\n\",\n    \"\\n\",\n    \"processor = MemoizedModelProcessor()\\n\",\n    \"configs = [\\n\",\n    \"    {\\\"temperature\\\": 0.7, \\\"model\\\": \\\"gpt-4\\\"},\\n\",\n    \"    {\\\"temperature\\\": 0.5, \\\"model\\\": \\\"gpt-4\\\"},\\n\",\n    \"    {\\\"temperature\\\": 0.7, \\\"model\\\": \\\"gpt-4\\\"},  # Same as first\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"test_inputs = [\\\"hello world\\\", \\\"python rocks\\\", \\\"hello world\\\"]  # Some repeats\\n\",\n    \"\\n\",\n    \"for i, (text, config) in enumerate(zip(test_inputs, configs), 1):\\n\",\n    \"    result = processor.process(text, config)\\n\",\n    \"    print(f\\\"  {i}. '{text}' → score: {result['score']:.3f}\\\")\\n\",\n    \"\\n\",\n    \"stats = processor.get_cache_stats()\\n\",\n    \"print(f\\\"\\\\n📊 Final cache statistics: {stats}\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Memoization Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Performance: Avoid redundant computations\\\")\\n\",\n    \"print(f\\\"  ✅ Efficiency: Especially good for recursive algorithms\\\")\\n\",\n    \"print(f\\\"  ✅ Transparency: Functions remain pure\\\")\\n\",\n    \"print(f\\\"  ✅ Configurability: TTL, size limits, custom strategies\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 10: Advanced Functional Patterns\\n\",\n    \"\\n\",\n    \"**First Principle**: Advanced patterns combine multiple functional concepts for sophisticated AI architectures.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use single dispatch, decorators, and functional composition to create flexible, maintainable systems.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Single dispatch for different data types\\n\",\n    \"@singledispatch\\n\",\n    \"def process_input(data) -> str:\\n\",\n    \"    \\\"\\\"\\\"Process input data (default implementation).\\\"\\\"\\\"\\n\",\n    \"    return f\\\"Processed unknown type: {type(data).__name__}\\\"\\n\",\n    \"\\n\",\n    \"@process_input.register\\n\",\n    \"def _(data: str) -> str:\\n\",\n    \"    \\\"\\\"\\\"Process string input.\\\"\\\"\\\"\\n\",\n    \"    stats = calculate_text_stats(data)\\n\",\n    \"    return f\\\"String: {stats['word_count']} words, {stats['character_count']} chars\\\"\\n\",\n    \"\\n\",\n    \"@process_input.register\\n\",\n    \"def _(data: list) -> str:\\n\",\n    \"    \\\"\\\"\\\"Process list input.\\\"\\\"\\\"\\n\",\n    \"    return f\\\"List: {len(data)} items, types: {[type(x).__name__ for x in data[:3]]}\\\"\\n\",\n    \"\\n\",\n    \"@process_input.register\\n\",\n    \"def _(data: dict) -> str:\\n\",\n    \"    \\\"\\\"\\\"Process dictionary input.\\\"\\\"\\\"\\n\",\n    \"    return f\\\"Dict: {len(data)} keys: {list(data.keys())[:3]}\\\"\\n\",\n    \"\\n\",\n    \"@process_input.register\\n\",\n    \"def _(data: ModelPrediction) -> str:\\n\",\n    \"    \\\"\\\"\\\"Process model prediction input.\\\"\\\"\\\"\\n\",\n    \"    return f\\\"Prediction: '{data.text}' confidence={data.confidence:.3f}\\\"\\n\",\n    \"\\n\",\n    \"# Functional decorators for AI operations\\n\",\n    \"def validate_input(validator: Callable[[Any], bool], error_msg: str = \\\"Invalid input\\\"):\\n\",\n    \"    \\\"\\\"\\\"Decorator that validates function input.\\\"\\\"\\\"\\n\",\n    \"    def decorator(func):\\n\",\n    \"        @wraps(func)\\n\",\n    \"        def wrapper(*args, **kwargs):\\n\",\n    \"            if args and not validator(args[0]):\\n\",\n    \"                raise ValueError(f\\\"{error_msg}: {args[0]}\\\")\\n\",\n    \"            return func(*args, **kwargs)\\n\",\n    \"        return wrapper\\n\",\n    \"    return decorator\\n\",\n    \"\\n\",\n    \"def retry_with_backoff(max_attempts: int = 3, base_delay: float = 1.0):\\n\",\n    \"    \\\"\\\"\\\"Decorator for retrying failed operations.\\\"\\\"\\\"\\n\",\n    \"    def decorator(func):\\n\",\n    \"        @wraps(func)\\n\",\n    \"        def wrapper(*args, **kwargs):\\n\",\n    \"            last_exception = None\\n\",\n    \"            \\n\",\n    \"            for attempt in range(max_attempts):\\n\",\n    \"                try:\\n\",\n    \"                    return func(*args, **kwargs)\\n\",\n    \"                except Exception as e:\\n\",\n    \"                    last_exception = e\\n\",\n    \"                    if attempt < max_attempts - 1:\\n\",\n    \"                        delay = base_delay * (2 ** attempt)\\n\",\n    \"                        print(f\\\"🔄 Retry {attempt + 1}/{max_attempts} in {delay:.1f}s\\\")\\n\",\n    \"                        time.sleep(delay)\\n\",\n    \"            \\n\",\n    \"            raise last_exception\\n\",\n    \"        return wrapper\\n\",\n    \"    return decorator\\n\",\n    \"\\n\",\n    \"# Complete functional AI pipeline\\n\",\n    \"class FunctionalAIPipeline:\\n\",\n    \"    \\\"\\\"\\\"Complete AI processing pipeline using functional patterns.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self):\\n\",\n    \"        self.processors = []\\n\",\n    \"        self.validators = []\\n\",\n    \"        self.transformers = []\\n\",\n    \"    \\n\",\n    \"    def add_validator(self, validator: Callable[[Any], bool], error_msg: str = \\\"Validation failed\\\"):\\n\",\n    \"        \\\"\\\"\\\"Add input validator.\\\"\\\"\\\"\\n\",\n    \"        self.validators.append((validator, error_msg))\\n\",\n    \"        return self\\n\",\n    \"    \\n\",\n    \"    def add_transformer(self, transformer: Callable[[Any], Any]):\\n\",\n    \"        \\\"\\\"\\\"Add data transformer.\\\"\\\"\\\"\\n\",\n    \"        self.transformers.append(transformer)\\n\",\n    \"        return self\\n\",\n    \"    \\n\",\n    \"    def add_processor(self, processor: Callable[[Any], Any]):\\n\",\n    \"        \\\"\\\"\\\"Add main processor.\\\"\\\"\\\"\\n\",\n    \"        self.processors.append(processor)\\n\",\n    \"        return self\\n\",\n    \"    \\n\",\n    \"    def process(self, data: Any) -> Result:\\n\",\n    \"        \\\"\\\"\\\"Process data through the complete pipeline.\\\"\\\"\\\"\\n\",\n    \"        try:\\n\",\n    \"            # Validation phase\\n\",\n    \"            for validator, error_msg in self.validators:\\n\",\n    \"                if not validator(data):\\n\",\n    \"                    return Result.failure(error_msg)\\n\",\n    \"            \\n\",\n    \"            # Transformation phase\\n\",\n    \"            current_data = data\\n\",\n    \"            for transformer in self.transformers:\\n\",\n    \"                current_data = transformer(current_data)\\n\",\n    \"            \\n\",\n    \"            # Processing phase\\n\",\n    \"            for processor in self.processors:\\n\",\n    \"                current_data = processor(current_data)\\n\",\n    \"            \\n\",\n    \"            return Result.success(current_data)\\n\",\n    \"            \\n\",\n    \"        except Exception as e:\\n\",\n    \"            return Result.failure(str(e))\\n\",\n    \"\\n\",\n    \"# Example functions using decorators\\n\",\n    \"@validate_input(lambda x: isinstance(x, str) and len(x) > 0, \\\"Text must be non-empty string\\\")\\n\",\n    \"@retry_with_backoff(max_attempts=2, base_delay=0.1)\\n\",\n    \"@lru_cache(maxsize=64)\\n\",\n    \"def advanced_text_processor(text: str) -> Dict[str, Any]:\\n\",\n    \"    \\\"\\\"\\\"Advanced text processor with validation, retry, and caching.\\\"\\\"\\\"\\n\",\n    \"    # Simulate potential failure\\n\",\n    \"    import random\\n\",\n    \"    if random.random() < 0.3:  # 30% chance of failure\\n\",\n    \"        raise ConnectionError(\\\"Simulated processing error\\\")\\n\",\n    \"    \\n\",\n    \"    return {\\n\",\n    \"        \\\"processed_text\\\": text.upper(),\\n\",\n    \"        \\\"word_count\\\": len(text.split()),\\n\",\n    \"        \\\"sentiment\\\": \\\"positive\\\" if \\\"good\\\" in text.lower() else \\\"neutral\\\",\\n\",\n    \"        \\\"complexity\\\": len(set(text.lower())) / len(text) if text else 0\\n\",\n    \"    }\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"🚀 Advanced Functional Patterns\\\", style=\\\"bold cyan\\\"))\\n\",\n    \"\\n\",\n    \"# Single dispatch demonstration\\n\",\n    \"test_data = [\\n\",\n    \"    \\\"Hello functional world\\\",\\n\",\n    \"    [1, 2, 3, \\\"text\\\", True],\\n\",\n    \"    {\\\"name\\\": \\\"AI\\\", \\\"type\\\": \\\"system\\\", \\\"version\\\": 1.0},\\n\",\n    \"    ModelPrediction(\\\"test\\\", 0.95, \\\"gpt-4\\\", 0.1, {}),\\n\",\n    \"    42.5\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"print(f\\\"🎯 Single dispatch processing:\\\")\\n\",\n    \"for i, data in enumerate(test_data, 1):\\n\",\n    \"    result = process_input(data)\\n\",\n    \"    print(f\\\"  {i}. {type(data).__name__}: {result}\\\")\\n\",\n    \"\\n\",\n    \"# Advanced processor with decorators\\n\",\n    \"print(f\\\"\\\\n🔧 Advanced processor (validation + retry + caching):\\\")\\n\",\n    \"\\n\",\n    \"test_texts = [\\\"good example\\\", \\\"another test\\\", \\\"good example\\\", \\\"\\\"]  # Last one should fail\\n\",\n    \"\\n\",\n    \"for i, text in enumerate(test_texts, 1):\\n\",\n    \"    try:\\n\",\n    \"        result = advanced_text_processor(text)\\n\",\n    \"        print(f\\\"  {i}. ✅ '{text}': {result['sentiment']} (complexity: {result['complexity']:.3f})\\\")\\n\",\n    \"    except Exception as e:\\n\",\n    \"        print(f\\\"  {i}. ❌ '{text}': {e}\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n📊 Cache info: {advanced_text_processor.cache_info()}\\\")\\n\",\n    \"\\n\",\n    \"# Complete functional pipeline\\n\",\n    \"print(f\\\"\\\\n🔄 Complete functional AI pipeline:\\\")\\n\",\n    \"\\n\",\n    \"pipeline = (FunctionalAIPipeline()\\n\",\n    \"           .add_validator(lambda x: isinstance(x, str), \\\"Input must be string\\\")\\n\",\n    \"           .add_validator(lambda x: len(x.strip()) > 0, \\\"Input must not be empty\\\")\\n\",\n    \"           .add_validator(lambda x: len(x) <= 1000, \\\"Input too long\\\")\\n\",\n    \"           .add_transformer(str.strip)\\n\",\n    \"           .add_transformer(str.lower)\\n\",\n    \"           .add_processor(calculate_text_stats)\\n\",\n    \"           .add_processor(lambda stats: {**stats, \\\"quality_score\\\": stats[\\\"unique_words\\\"] / stats[\\\"word_count\\\"] if stats[\\\"word_count\\\"] > 0 else 0}))\\n\",\n    \"\\n\",\n    \"pipeline_tests = [\\n\",\n    \"    \\\"  This is a great example of functional programming!  \\\",\\n\",\n    \"    \\\"\\\",\\n\",\n    \"    \\\"Short\\\",\\n\",\n    \"    \\\"x\\\" * 1001,  # Too long\\n\",\n    \"    123  # Wrong type\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"for i, test_input in enumerate(pipeline_tests, 1):\\n\",\n    \"    result = pipeline.process(test_input)\\n\",\n    \"    display = str(test_input)[:30] + \\\"...\\\" if len(str(test_input)) > 30 else str(test_input)\\n\",\n    \"    \\n\",\n    \"    if result.is_success:\\n\",\n    \"        data = result.value\\n\",\n    \"        print(f\\\"  {i}. ✅ '{display}': {data['word_count']} words, quality: {data['quality_score']:.3f}\\\")\\n\",\n    \"    else:\\n\",\n    \"        print(f\\\"  {i}. ❌ '{display}': {result.error}\\\")\\n\",\n    \"\\n\",\n    \"# Functional composition showcase\\n\",\n    \"print(f\\\"\\\\n🎼 Functional composition showcase:\\\")\\n\",\n    \"\\n\",\n    \"# Create a complex text processing function by composing simple ones\\n\",\n    \"text_normalizer = pipe(\\n\",\n    \"    str.strip,\\n\",\n    \"    str.lower,\\n\",\n    \"    lambda text: text.replace(\\\"'\\\", \\\"\\\"),  # Remove apostrophes\\n\",\n    \"    lambda text: \\\" \\\".join(text.split())  # Normalize whitespace\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"text_analyzer = compose(\\n\",\n    \"    lambda stats: f\\\"Quality text: {stats['word_count']} words, {stats['unique_words']} unique (quality: {stats['unique_words']/stats['word_count']:.2f})\\\",\\n\",\n    \"    calculate_text_stats,\\n\",\n    \"    text_normalizer\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"messy_text = \\\"  Hello   World!   This   is   a   GREAT   example...   \\\"\\n\",\n    \"analysis = text_analyzer(messy_text)\\n\",\n    \"print(f\\\"  Input: '{messy_text}'\\\")\\n\",\n    \"print(f\\\"  Analysis: {analysis}\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Advanced Functional Programming Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Modularity: Small, composable pieces\\\")\\n\",\n    \"print(f\\\"  ✅ Reliability: Pure functions + error handling\\\")\\n\",\n    \"print(f\\\"  ✅ Performance: Lazy evaluation + memoization\\\")\\n\",\n    \"print(f\\\"  ✅ Maintainability: Clear data flow\\\")\\n\",\n    \"print(f\\\"  ✅ Testability: Each function can be tested independently\\\")\\n\",\n    \"print(f\\\"  ✅ Scalability: Parallel processing safe\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 11: Real-World Application\\n\",\n    \"\\n\",\n    \"**First Principle**: Combine all functional programming concepts to build a production-ready AI text processing system.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use functional patterns as the backbone for reliable, scalable AI applications.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Complete functional AI text processing system\\n\",\n    \"from dataclasses import dataclass\\n\",\n    \"from typing import Protocol\\n\",\n    \"\\n\",\n    \"@dataclass(frozen=True)\\n\",\n    \"class ProcessingConfig:\\n\",\n    \"    \\\"\\\"\\\"Immutable processing configuration.\\\"\\\"\\\"\\n\",\n    \"    min_length: int = 5\\n\",\n    \"    max_length: int = 10000\\n\",\n    \"    enable_sentiment: bool = True\\n\",\n    \"    enable_complexity: bool = True\\n\",\n    \"    cache_ttl: float = 300.0  # 5 minutes\\n\",\n    \"\\n\",\n    \"@dataclass(frozen=True)\\n\",\n    \"class ProcessingResult:\\n\",\n    \"    \\\"\\\"\\\"Immutable processing result.\\\"\\\"\\\"\\n\",\n    \"    original_text: str\\n\",\n    \"    normalized_text: str\\n\",\n    \"    word_count: int\\n\",\n    \"    sentiment: Optional[str] = None\\n\",\n    \"    complexity_score: Optional[float] = None\\n\",\n    \"    processing_time: float = 0.0\\n\",\n    \"    cached: bool = False\\n\",\n    \"\\n\",\n    \"class FunctionalTextProcessor:\\n\",\n    \"    \\\"\\\"\\\"Production-ready functional text processor.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, config: ProcessingConfig):\\n\",\n    \"        self.config = config\\n\",\n    \"        self.cache = {}\\n\",\n    \"        self.metrics = {\\\"total_processed\\\": 0, \\\"cache_hits\\\": 0, \\\"errors\\\": 0}\\n\",\n    \"        \\n\",\n    \"        # Create processing pipeline using functional composition\\n\",\n    \"        self.normalizer = pipe(\\n\",\n    \"            str.strip,\\n\",\n    \"            str.lower,\\n\",\n    \"            lambda text: \\\" \\\".join(text.split())  # Normalize whitespace\\n\",\n    \"        )\\n\",\n    \"        \\n\",\n    \"        # Create validators\\n\",\n    \"        self.validators = [\\n\",\n    \"            (lambda text: isinstance(text, str), \\\"Input must be a string\\\"),\\n\",\n    \"            (lambda text: len(text.strip()) >= self.config.min_length, f\\\"Text too short (min: {self.config.min_length})\\\"),\\n\",\n    \"            (lambda text: len(text) <= self.config.max_length, f\\\"Text too long (max: {self.config.max_length})\\\")\\n\",\n    \"        ]\\n\",\n    \"    \\n\",\n    \"    def _validate_input(self, text: str) -> Result:\\n\",\n    \"        \\\"\\\"\\\"Validate input using functional approach.\\\"\\\"\\\"\\n\",\n    \"        for validator, error_msg in self.validators:\\n\",\n    \"            if not validator(text):\\n\",\n    \"                return Result.failure(error_msg)\\n\",\n    \"        return Result.success(text)\\n\",\n    \"    \\n\",\n    \"    def _get_cache_key(self, text: str) -> str:\\n\",\n    \"        \\\"\\\"\\\"Generate cache key for text.\\\"\\\"\\\"\\n\",\n    \"        config_hash = hash(str(self.config))\\n\",\n    \"        text_hash = hash(text)\\n\",\n    \"        return f\\\"{config_hash}_{text_hash}\\\"\\n\",\n    \"    \\n\",\n    \"    def _check_cache(self, cache_key: str) -> Optional[ProcessingResult]:\\n\",\n    \"        \\\"\\\"\\\"Check if result is cached and not expired.\\\"\\\"\\\"\\n\",\n    \"        if cache_key in self.cache:\\n\",\n    \"            result, timestamp = self.cache[cache_key]\\n\",\n    \"            if time.time() - timestamp < self.config.cache_ttl:\\n\",\n    \"                self.metrics[\\\"cache_hits\\\"] += 1\\n\",\n    \"                # Return new instance with cached flag set\\n\",\n    \"                return replace(result, cached=True)\\n\",\n    \"        return None\\n\",\n    \"    \\n\",\n    \"    def _compute_sentiment(self, text: str) -> str:\\n\",\n    \"        \\\"\\\"\\\"Compute sentiment (simplified).\\\"\\\"\\\"\\n\",\n    \"        positive_words = {'good', 'great', 'excellent', 'amazing', 'wonderful', 'fantastic'}\\n\",\n    \"        negative_words = {'bad', 'terrible', 'awful', 'horrible', 'disgusting', 'hate'}\\n\",\n    \"        \\n\",\n    \"        words = set(text.lower().split())\\n\",\n    \"        positive_count = len(words.intersection(positive_words))\\n\",\n    \"        negative_count = len(words.intersection(negative_words))\\n\",\n    \"        \\n\",\n    \"        if positive_count > negative_count:\\n\",\n    \"            return \\\"positive\\\"\\n\",\n    \"        elif negative_count > positive_count:\\n\",\n    \"            return \\\"negative\\\"\\n\",\n    \"        else:\\n\",\n    \"            return \\\"neutral\\\"\\n\",\n    \"    \\n\",\n    \"    def _compute_complexity(self, text: str) -> float:\\n\",\n    \"        \\\"\\\"\\\"Compute text complexity score.\\\"\\\"\\\"\\n\",\n    \"        words = text.split()\\n\",\n    \"        if not words:\\n\",\n    \"            return 0.0\\n\",\n    \"        \\n\",\n    \"        unique_words = len(set(words))\\n\",\n    \"        total_words = len(words)\\n\",\n    \"        avg_word_length = sum(len(word) for word in words) / total_words\\n\",\n    \"        \\n\",\n    \"        # Complexity combines lexical diversity and word length\\n\",\n    \"        lexical_diversity = unique_words / total_words\\n\",\n    \"        length_factor = min(avg_word_length / 5.0, 1.0)  # Normalize to 0-1\\n\",\n    \"        \\n\",\n    \"        return (lexical_diversity + length_factor) / 2.0\\n\",\n    \"    \\n\",\n    \"    def process(self, text: str) -> Result[ProcessingResult]:\\n\",\n    \"        \\\"\\\"\\\"Process text using functional pipeline.\\\"\\\"\\\"\\n\",\n    \"        start_time = time.time()\\n\",\n    \"        \\n\",\n    \"        try:\\n\",\n    \"            # Validation phase\\n\",\n    \"            validation_result = self._validate_input(text)\\n\",\n    \"            if not validation_result.is_success:\\n\",\n    \"                self.metrics[\\\"errors\\\"] += 1\\n\",\n    \"                return validation_result\\n\",\n    \"            \\n\",\n    \"            # Check cache\\n\",\n    \"            cache_key = self._get_cache_key(text)\\n\",\n    \"            cached_result = self._check_cache(cache_key)\\n\",\n    \"            if cached_result:\\n\",\n    \"                return Result.success(cached_result)\\n\",\n    \"            \\n\",\n    \"            # Normalize text\\n\",\n    \"            normalized_text = self.normalizer(text)\\n\",\n    \"            word_count = len(normalized_text.split())\\n\",\n    \"            \\n\",\n    \"            # Optional processing based on config\\n\",\n    \"            sentiment = self._compute_sentiment(normalized_text) if self.config.enable_sentiment else None\\n\",\n    \"            complexity = self._compute_complexity(normalized_text) if self.config.enable_complexity else None\\n\",\n    \"            \\n\",\n    \"            processing_time = time.time() - start_time\\n\",\n    \"            \\n\",\n    \"            # Create result\\n\",\n    \"            result = ProcessingResult(\\n\",\n    \"                original_text=text,\\n\",\n    \"                normalized_text=normalized_text,\\n\",\n    \"                word_count=word_count,\\n\",\n    \"                sentiment=sentiment,\\n\",\n    \"                complexity_score=complexity,\\n\",\n    \"                processing_time=processing_time,\\n\",\n    \"                cached=False\\n\",\n    \"            )\\n\",\n    \"            \\n\",\n    \"            # Cache result\\n\",\n    \"            self.cache[cache_key] = (result, time.time())\\n\",\n    \"            \\n\",\n    \"            # Update metrics\\n\",\n    \"            self.metrics[\\\"total_processed\\\"] += 1\\n\",\n    \"            \\n\",\n    \"            return Result.success(result)\\n\",\n    \"            \\n\",\n    \"        except Exception as e:\\n\",\n    \"            self.metrics[\\\"errors\\\"] += 1\\n\",\n    \"            return Result.failure(f\\\"Processing error: {str(e)}\\\")\\n\",\n    \"    \\n\",\n    \"    def process_batch(self, texts: List[str]) -> List[Result[ProcessingResult]]:\\n\",\n    \"        \\\"\\\"\\\"Process multiple texts efficiently.\\\"\\\"\\\"\\n\",\n    \"        return [self.process(text) for text in texts]\\n\",\n    \"    \\n\",\n    \"    def get_metrics(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get processing metrics.\\\"\\\"\\\"\\n\",\n    \"        total = self.metrics[\\\"total_processed\\\"] + self.metrics[\\\"cache_hits\\\"]\\n\",\n    \"        cache_hit_rate = self.metrics[\\\"cache_hits\\\"] / total if total > 0 else 0\\n\",\n    \"        \\n\",\n    \"        return {\\n\",\n    \"            **self.metrics,\\n\",\n    \"            \\\"cache_size\\\": len(self.cache),\\n\",\n    \"            \\\"cache_hit_rate\\\": cache_hit_rate\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"🏭 Production Functional AI System\\\", style=\\\"bold green\\\"))\\n\",\n    \"\\n\",\n    \"# Create processor with configuration\\n\",\n    \"config = ProcessingConfig(\\n\",\n    \"    min_length=3,\\n\",\n    \"    max_length=500,\\n\",\n    \"    enable_sentiment=True,\\n\",\n    \"    enable_complexity=True,\\n\",\n    \"    cache_ttl=60.0\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"processor = FunctionalTextProcessor(config)\\n\",\n    \"\\n\",\n    \"# Test with various inputs\\n\",\n    \"test_inputs = [\\n\",\n    \"    \\\"This is a great example of functional programming in AI!\\\",\\n\",\n    \"    \\\"Python is an amazing language for data science.\\\",\\n\",\n    \"    \\\"Bad terrible awful experience with this product.\\\",\\n\",\n    \"    \\\"The quick brown fox jumps over the lazy dog.\\\",\\n\",\n    \"    \\\"This is a great example of functional programming in AI!\\\",  # Duplicate for cache test\\n\",\n    \"    \\\"\\\",  # Should fail validation\\n\",\n    \"    \\\"AI\\\",  # Too short\\n\",\n    \"    \\\"Simple text for processing\\\"\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"print(f\\\"🔄 Processing {len(test_inputs)} texts:\\\")\\n\",\n    \"\\n\",\n    \"results = processor.process_batch(test_inputs)\\n\",\n    \"\\n\",\n    \"for i, (text, result) in enumerate(zip(test_inputs, results), 1):\\n\",\n    \"    display_text = text[:40] + \\\"...\\\" if len(text) > 40 else text\\n\",\n    \"    \\n\",\n    \"    if result.is_success:\\n\",\n    \"        data = result.value\\n\",\n    \"        cache_indicator = \\\"💾\\\" if data.cached else \\\"🔄\\\"\\n\",\n    \"        print(f\\\"  {i}. {cache_indicator} '{display_text}'\\\")\\n\",\n    \"        print(f\\\"     Words: {data.word_count}, Sentiment: {data.sentiment}, Complexity: {data.complexity_score:.3f if data.complexity_score else 'N/A'}\\\")\\n\",\n    \"        print(f\\\"     Time: {data.processing_time:.4f}s\\\")\\n\",\n    \"    else:\\n\",\n    \"        print(f\\\"  {i}. ❌ '{display_text}': {result.error}\\\")\\n\",\n    \"\\n\",\n    \"# Show metrics\\n\",\n    \"metrics = processor.get_metrics()\\n\",\n    \"print(f\\\"\\\\n📊 Processing Metrics:\\\")\\n\",\n    \"print(f\\\"  Total processed: {metrics['total_processed']}\\\")\\n\",\n    \"print(f\\\"  Cache hits: {metrics['cache_hits']}\\\")\\n\",\n    \"print(f\\\"  Cache hit rate: {metrics['cache_hit_rate']:.1%}\\\")\\n\",\n    \"print(f\\\"  Errors: {metrics['errors']}\\\")\\n\",\n    \"print(f\\\"  Cache size: {metrics['cache_size']}\\\")\\n\",\n    \"\\n\",\n    \"# Demonstrate functional composition in batch processing\\n\",\n    \"print(f\\\"\\\\n🎯 Functional batch processing with filtering:\\\")\\n\",\n    \"\\n\",\n    \"# Create a functional pipeline for batch processing\\n\",\n    \"batch_processor = pipe(\\n\",\n    \"    # Filter successful results\\n\",\n    \"    lambda results: [r.value for r in results if r.is_success],\\n\",\n    \"    # Filter by sentiment\\n\",\n    \"    lambda data_list: [d for d in data_list if d.sentiment == \\\"positive\\\"],\\n\",\n    \"    # Sort by complexity\\n\",\n    \"    lambda data_list: sorted(data_list, key=lambda d: d.complexity_score or 0, reverse=True),\\n\",\n    \"    # Take top 3\\n\",\n    \"    lambda data_list: data_list[:3]\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"top_positive_complex = batch_processor(results)\\n\",\n    \"\\n\",\n    \"print(f\\\"  Top positive, complex texts:\\\")\\n\",\n    \"for i, data in enumerate(top_positive_complex, 1):\\n\",\n    \"    print(f\\\"    {i}. '{data.original_text[:50]}...' (complexity: {data.complexity_score:.3f})\\\")\\n\",\n    \"\\n\",\n    \"# Show the power of immutability\\n\",\n    \"print(f\\\"\\\\n🔒 Demonstrating immutability benefits:\\\")\\n\",\n    \"original_config = config\\n\",\n    \"new_config = replace(config, enable_sentiment=False, cache_ttl=30.0)\\n\",\n    \"\\n\",\n    \"print(f\\\"  Original config sentiment enabled: {original_config.enable_sentiment}\\\")\\n\",\n    \"print(f\\\"  New config sentiment enabled: {new_config.enable_sentiment}\\\")\\n\",\n    \"print(f\\\"  Original config unchanged: {original_config.enable_sentiment}\\\")\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🎉 Production System Highlights:\\\")\\n\",\n    \"print(f\\\"  ✅ Immutable configuration and results\\\")\\n\",\n    \"print(f\\\"  ✅ Pure functions for core processing\\\")\\n\",\n    \"print(f\\\"  ✅ Monadic error handling throughout\\\")\\n\",\n    \"print(f\\\"  ✅ Automatic caching with TTL\\\")\\n\",\n    \"print(f\\\"  ✅ Functional composition for complex operations\\\")\\n\",\n    \"print(f\\\"  ✅ Comprehensive metrics and monitoring\\\")\\n\",\n    \"print(f\\\"  ✅ Thread-safe design (no shared mutable state)\\\")\\n\",\n    \"print(f\\\"  ✅ Easy testing (pure functions)\\\")\\n\",\n    \"print(f\\\"  ✅ Scalable architecture (stateless processing)\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Summary: Functional Programming Mastery\\n\",\n    \"\\n\",\n    \"**🎯 Key Takeaways:**\\n\",\n    \"\\n\",\n    \"1. **Immutability** prevents bugs and enables safe concurrency\\n\",\n    \"2. **Pure Functions** make code predictable and testable\\n\",\n    \"3. **Composition** builds complex systems from simple parts\\n\",\n    \"4. **Higher-Order Functions** enable powerful abstractions\\n\",\n    \"5. **Monadic Error Handling** creates safe computation chains\\n\",\n    \"6. **Lazy Evaluation** provides memory and performance benefits\\n\",\n    \"7. **Memoization** eliminates redundant computations\\n\",\n    \"\\n\",\n    \"**🚀 Next Steps:**\\n\",\n    \"- Apply these patterns to your AI projects\\n\",\n    \"- Combine functional and object-oriented approaches\\n\",\n    \"- Build immutable data pipelines\\n\",\n    \"- Create composable AI model architectures\\n\",\n    \"\\n\",\n    \"**💡 Remember:** Functional programming isn't about avoiding all state—it's about controlling state to make your AI systems more reliable, testable, and maintainable!\"\n   ]\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"Python 3\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.11.0\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 4\n}","structuredPatch":[]}}
{"parentUuid":"0152b606-de3d-4394-ab7e-93c3c00bf5d2","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_01Syd2xFqP6t3MckS3u1BGnY","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Now let me create the notebook for async patterns (file 2):"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":113147,"cache_read_input_tokens":0,"output_tokens":4}},"requestId":"req_vrtx_011CRhS6YnSYL32R2dyM71Md","type":"assistant","uuid":"ef7f0b3c-2dbe-4042-b28c-ed5b37f00bb2","timestamp":"2025-08-01T18:05:52.857Z"}
{"parentUuid":"ef7f0b3c-2dbe-4042-b28c-ed5b37f00bb2","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_01Syd2xFqP6t3MckS3u1BGnY","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_vrtx_01Sr2ysBL8ApSp79gBgJR1My","name":"Write","input":{"file_path":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/notebooks/02_async_patterns_learning.ipynb","content":"{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Async Patterns for High-Performance AI Systems\\n\",\n    \"\\n\",\n    \"This notebook teaches advanced asyncio patterns for building high-performance AI systems with concurrent processing, streaming, and resource management. You'll learn:\\n\",\n    \"\\n\",\n    \"1. **Streaming Patterns** - Real-time AI response streaming\\n\",\n    \"2. **Rate Limiting** - Controlling API usage and preventing overload\\n\",\n    \"3. **Connection Pooling** - Efficient resource management\\n\",\n    \"4. **Concurrent Processing** - Parallel AI inference\\n\",\n    \"5. **Batch Processing** - Optimizing throughput\\n\",\n    \"6. **Async Context Managers** - Proper resource cleanup\\n\",\n    \"7. **Async Generators** - Memory-efficient data processing\\n\",\n    \"8. **Error Handling** - Robust async error management\\n\",\n    \"\\n\",\n    \"## Prerequisites\\n\",\n    \"```bash\\n\",\n    \"pip install rich asyncio\\n\",\n    \"```\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 1: Async Fundamentals and Setup\\n\",\n    \"\\n\",\n    \"**First Principle**: Async programming enables concurrent execution without blocking, essential for I/O-bound AI applications.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `async def` for coroutines, `await` for async operations, and `asyncio.create_task()` for concurrent execution.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Essential imports for async programming\\n\",\n    \"import asyncio\\n\",\n    \"from typing import AsyncGenerator, AsyncIterator, Callable, Any, Optional, List, Dict\\n\",\n    \"from dataclasses import dataclass\\n\",\n    \"from contextlib import asynccontextmanager\\n\",\n    \"import time\\n\",\n    \"from rich.console import Console\\n\",\n    \"from rich.panel import Panel\\n\",\n    \"from rich.table import Table\\n\",\n    \"\\n\",\n    \"console = Console()\\n\",\n    \"\\n\",\n    \"# Basic data structures for AI processing\\n\",\n    \"@dataclass\\n\",\n    \"class StreamingChunk:\\n\",\n    \"    \\\"\\\"\\\"Represents a chunk of streaming data.\\\"\\\"\\\"\\n\",\n    \"    content: str\\n\",\n    \"    chunk_id: int\\n\",\n    \"    is_final: bool\\n\",\n    \"    metadata: Dict[str, Any] = None\\n\",\n    \"    \\n\",\n    \"    def __post_init__(self):\\n\",\n    \"        if self.metadata is None:\\n\",\n    \"            self.metadata = {}\\n\",\n    \"\\n\",\n    \"@dataclass\\n\",\n    \"class Message:\\n\",\n    \"    \\\"\\\"\\\"Chat message structure.\\\"\\\"\\\"\\n\",\n    \"    role: str\\n\",\n    \"    content: str\\n\",\n    \"    timestamp: float = None\\n\",\n    \"    \\n\",\n    \"    def __post_init__(self):\\n\",\n    \"        if self.timestamp is None:\\n\",\n    \"            self.timestamp = time.time()\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"⚡ Async Programming Fundamentals\\\", style=\\\"bold blue\\\"))\\n\",\n    \"\\n\",\n    \"print(\\\"\\\"\\\"\\n\",\n    \"🔑 Key Async Concepts:\\n\",\n    \"\\n\",\n    \"1. **Coroutines**: Functions defined with 'async def'\\n\",\n    \"2. **Awaitable**: Objects that can be used with 'await'\\n\",\n    \"3. **Event Loop**: Manages and executes async operations\\n\",\n    \"4. **Tasks**: Concurrent execution of coroutines\\n\",\n    \"5. **Futures**: Placeholders for future results\\n\",\n    \"\\n\",\n    \"🎯 Benefits for AI Systems:\\n\",\n    \"• Handle multiple API calls concurrently\\n\",\n    \"• Stream responses in real-time\\n\",\n    \"• Manage resources efficiently\\n\",\n    \"• Scale to thousands of connections\\n\",\n    \"• Non-blocking I/O operations\\n\",\n    \"\\\"\\\"\\\")\\n\",\n    \"\\n\",\n    \"# Simple async demonstration\\n\",\n    \"async def simple_async_demo():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate basic async concepts.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    async def fetch_data(source: str, delay: float) -> str:\\n\",\n    \"        \\\"\\\"\\\"Simulate fetching data from different sources.\\\"\\\"\\\"\\n\",\n    \"        print(f\\\"🔄 Starting to fetch from {source}...\\\")\\n\",\n    \"        await asyncio.sleep(delay)  # Simulate I/O delay\\n\",\n    \"        result = f\\\"Data from {source}\\\"\\n\",\n    \"        print(f\\\"✅ Finished fetching from {source}\\\")\\n\",\n    \"        return result\\n\",\n    \"    \\n\",\n    \"    # Sequential execution (blocking)\\n\",\n    \"    print(\\\"📊 Sequential execution:\\\")\\n\",\n    \"    start_time = time.time()\\n\",\n    \"    \\n\",\n    \"    result1 = await fetch_data(\\\"API-1\\\", 0.5)\\n\",\n    \"    result2 = await fetch_data(\\\"API-2\\\", 0.3)\\n\",\n    \"    result3 = await fetch_data(\\\"API-3\\\", 0.4)\\n\",\n    \"    \\n\",\n    \"    sequential_time = time.time() - start_time\\n\",\n    \"    print(f\\\"Sequential results: {[result1, result2, result3]}\\\")\\n\",\n    \"    print(f\\\"Sequential time: {sequential_time:.2f}s\\\")\\n\",\n    \"    \\n\",\n    \"    # Concurrent execution (non-blocking)\\n\",\n    \"    print(f\\\"\\\\n🚀 Concurrent execution:\\\")\\n\",\n    \"    start_time = time.time()\\n\",\n    \"    \\n\",\n    \"    # Create tasks for concurrent execution\\n\",\n    \"    task1 = asyncio.create_task(fetch_data(\\\"API-1\\\", 0.5))\\n\",\n    \"    task2 = asyncio.create_task(fetch_data(\\\"API-2\\\", 0.3))\\n\",\n    \"    task3 = asyncio.create_task(fetch_data(\\\"API-3\\\", 0.4))\\n\",\n    \"    \\n\",\n    \"    # Wait for all tasks to complete\\n\",\n    \"    concurrent_results = await asyncio.gather(task1, task2, task3)\\n\",\n    \"    \\n\",\n    \"    concurrent_time = time.time() - start_time\\n\",\n    \"    print(f\\\"Concurrent results: {concurrent_results}\\\")\\n\",\n    \"    print(f\\\"Concurrent time: {concurrent_time:.2f}s\\\")\\n\",\n    \"    \\n\",\n    \"    speedup = sequential_time / concurrent_time\\n\",\n    \"    print(f\\\"\\\\n⚡ Speedup: {speedup:.1f}x faster with async!\\\")\\n\",\n    \"\\n\",\n    \"# Run the demo\\n\",\n    \"await simple_async_demo()\\n\",\n    \"\\n\",\n    \"print(\\\"\\\\n💡 Key Takeaway: Async shines with I/O-bound operations!\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 2: Streaming Patterns for Real-Time AI\\n\",\n    \"\\n\",\n    \"**First Principle**: Streaming enables real-time user feedback and better resource utilization in AI applications.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `async def` with `yield` to create async generators for streaming data.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class StreamingAIProvider:\\n\",\n    \"    \\\"\\\"\\\"AI provider that supports streaming responses.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, response_delay: float = 0.1):\\n\",\n    \"        self.response_delay = response_delay\\n\",\n    \"        self.call_count = 0\\n\",\n    \"    \\n\",\n    \"    async def stream_completion(\\n\",\n    \"        self, \\n\",\n    \"        model_id: str, \\n\",\n    \"        messages: List[Message]\\n\",\n    \"    ) -> AsyncGenerator[StreamingChunk, None]:\\n\",\n    \"        \\\"\\\"\\\"Stream chat completion chunks.\\\"\\\"\\\"\\n\",\n    \"        self.call_count += 1\\n\",\n    \"        \\n\",\n    \"        # Simulate streaming response\\n\",\n    \"        response_text = f\\\"This is a streaming response to: {messages[-1].content}\\\"\\n\",\n    \"        words = response_text.split()\\n\",\n    \"        \\n\",\n    \"        for i, word in enumerate(words):\\n\",\n    \"            await asyncio.sleep(self.response_delay)\\n\",\n    \"            \\n\",\n    \"            chunk = StreamingChunk(\\n\",\n    \"                content=word + (\\\" \\\" if i < len(words) - 1 else \\\"\\\"),\\n\",\n    \"                chunk_id=i,\\n\",\n    \"                is_final=i == len(words) - 1,\\n\",\n    \"                metadata={\\n\",\n    \"                    \\\"model\\\": model_id,\\n\",\n    \"                    \\\"total_chunks\\\": len(words),\\n\",\n    \"                    \\\"call_id\\\": self.call_count\\n\",\n    \"                }\\n\",\n    \"            )\\n\",\n    \"            \\n\",\n    \"            yield chunk\\n\",\n    \"    \\n\",\n    \"    async def stream_multiple_responses(\\n\",\n    \"        self,\\n\",\n    \"        queries: List[str]\\n\",\n    \"    ) -> AsyncGenerator[Dict[str, Any], None]:\\n\",\n    \"        \\\"\\\"\\\"Stream responses for multiple queries concurrently.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        async def process_query(query_id: int, query: str):\\n\",\n    \"            \\\"\\\"\\\"Process a single query and yield results.\\\"\\\"\\\"\\n\",\n    \"            messages = [Message(role=\\\"user\\\", content=query)]\\n\",\n    \"            \\n\",\n    \"            async for chunk in self.stream_completion(\\\"gpt-4\\\", messages):\\n\",\n    \"                yield {\\n\",\n    \"                    \\\"query_id\\\": query_id,\\n\",\n    \"                    \\\"query\\\": query,\\n\",\n    \"                    \\\"chunk\\\": chunk\\n\",\n    \"                }\\n\",\n    \"        \\n\",\n    \"        # Create tasks for all queries\\n\",\n    \"        tasks = [\\n\",\n    \"            process_query(i, query) \\n\",\n    \"            for i, query in enumerate(queries)\\n\",\n    \"        ]\\n\",\n    \"        \\n\",\n    \"        # Use async generators concurrently\\n\",\n    \"        async def merge_streams():\\n\",\n    \"            \\\"\\\"\\\"Merge multiple async generators.\\\"\\\"\\\"\\n\",\n    \"            active_tasks = [task.__aiter__() for task in tasks]\\n\",\n    \"            \\n\",\n    \"            while active_tasks:\\n\",\n    \"                # Try to get next item from each active stream\\n\",\n    \"                for i, stream in enumerate(active_tasks[:]):\\n\",\n    \"                    try:\\n\",\n    \"                        result = await stream.__anext__()\\n\",\n    \"                        yield result\\n\",\n    \"                    except StopAsyncIteration:\\n\",\n    \"                        active_tasks.remove(stream)\\n\",\n    \"                \\n\",\n    \"                # Small delay to prevent tight loop\\n\",\n    \"                if active_tasks:\\n\",\n    \"                    await asyncio.sleep(0.01)\\n\",\n    \"        \\n\",\n    \"        async for result in merge_streams():\\n\",\n    \"            yield result\\n\",\n    \"\\n\",\n    \"async def demonstrate_streaming():\\n\",\n    \"    \\\"\\\"\\\"Show streaming patterns.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    console.print(Panel(\\\"🌊 Streaming Patterns\\\", style=\\\"bold blue\\\"))\\n\",\n    \"    \\n\",\n    \"    provider = StreamingAIProvider(response_delay=0.15)\\n\",\n    \"    \\n\",\n    \"    print(\\\"📡 Single streaming completion:\\\")\\n\",\n    \"    \\n\",\n    \"    messages = [Message(role=\\\"user\\\", content=\\\"Tell me about async programming\\\")]\\n\",\n    \"    \\n\",\n    \"    # Collect streaming chunks\\n\",\n    \"    chunks = []\\n\",\n    \"    full_response = \\\"\\\"\\n\",\n    \"    \\n\",\n    \"    async for chunk in provider.stream_completion(\\\"gpt-4\\\", messages):\\n\",\n    \"        chunks.append(chunk)\\n\",\n    \"        full_response += chunk.content\\n\",\n    \"        \\n\",\n    \"        # Show real-time progress\\n\",\n    \"        if chunk.is_final:\\n\",\n    \"            print(f\\\"  Chunk {chunk.chunk_id}: '{chunk.content.strip()}' [FINAL]\\\")\\n\",\n    \"        else:\\n\",\n    \"            print(f\\\"  Chunk {chunk.chunk_id}: '{chunk.content.strip()}'\\\")\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n📊 Streaming Summary:\\\")\\n\",\n    \"    print(f\\\"  Total chunks: {len(chunks)}\\\")\\n\",\n    \"    print(f\\\"  Full response: {full_response}\\\")\\n\",\n    \"    print(f\\\"  Final chunk metadata: {chunks[-1].metadata}\\\")\\n\",\n    \"    \\n\",\n    \"    # Multiple concurrent streams\\n\",\n    \"    print(f\\\"\\\\n🔀 Multiple concurrent streams:\\\")\\n\",\n    \"    \\n\",\n    \"    queries = [\\n\",\n    \"        \\\"What is machine learning?\\\",\\n\",\n    \"        \\\"Explain neural networks\\\",\\n\",\n    \"        \\\"How does AI work?\\\"\\n\",\n    \"    ]\\n\",\n    \"    \\n\",\n    \"    query_responses = {i: \\\"\\\" for i in range(len(queries))}\\n\",\n    \"    \\n\",\n    \"    async for result in provider.stream_multiple_responses(queries):\\n\",\n    \"        query_id = result[\\\"query_id\\\"]\\n\",\n    \"        chunk = result[\\\"chunk\\\"]\\n\",\n    \"        query_responses[query_id] += chunk.content\\n\",\n    \"        \\n\",\n    \"        status = \\\"[FINAL]\\\" if chunk.is_final else \\\"\\\"\\n\",\n    \"        print(f\\\"  Query {query_id}: chunk {chunk.chunk_id} '{chunk.content.strip()}' {status}\\\")\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n📋 Final responses:\\\")\\n\",\n    \"    for i, response in query_responses.items():\\n\",\n    \"        print(f\\\"  Query {i}: {response}\\\")\\n\",\n    \"\\n\",\n    \"# Real-time streaming with buffer management\\n\",\n    \"class StreamBuffer:\\n\",\n    \"    \\\"\\\"\\\"Buffer for managing streaming data.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, max_size: int = 100):\\n\",\n    \"        self.buffer = []\\n\",\n    \"        self.max_size = max_size\\n\",\n    \"        self.overflow_count = 0\\n\",\n    \"    \\n\",\n    \"    async def add_chunk(self, chunk: StreamingChunk) -> bool:\\n\",\n    \"        \\\"\\\"\\\"Add chunk to buffer, return True if successful.\\\"\\\"\\\"\\n\",\n    \"        if len(self.buffer) >= self.max_size:\\n\",\n    \"            self.overflow_count += 1\\n\",\n    \"            return False\\n\",\n    \"        \\n\",\n    \"        self.buffer.append(chunk)\\n\",\n    \"        return True\\n\",\n    \"    \\n\",\n    \"    async def get_chunks(self, count: int = None) -> List[StreamingChunk]:\\n\",\n    \"        \\\"\\\"\\\"Get chunks from buffer.\\\"\\\"\\\"\\n\",\n    \"        if count is None:\\n\",\n    \"            chunks = self.buffer.copy()\\n\",\n    \"            self.buffer.clear()\\n\",\n    \"        else:\\n\",\n    \"            chunks = self.buffer[:count]\\n\",\n    \"            self.buffer = self.buffer[count:]\\n\",\n    \"        \\n\",\n    \"        return chunks\\n\",\n    \"    \\n\",\n    \"    def get_stats(self) -> Dict[str, int]:\\n\",\n    \"        return {\\n\",\n    \"            \\\"buffer_size\\\": len(self.buffer),\\n\",\n    \"            \\\"max_size\\\": self.max_size,\\n\",\n    \"            \\\"overflow_count\\\": self.overflow_count\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"async def demonstrate_buffered_streaming():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate streaming with buffer management.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n💾 Buffered streaming demonstration:\\\")\\n\",\n    \"    \\n\",\n    \"    provider = StreamingAIProvider(response_delay=0.05)\\n\",\n    \"    buffer = StreamBuffer(max_size=5)\\n\",\n    \"    \\n\",\n    \"    messages = [Message(role=\\\"user\\\", content=\\\"Generate a long response about AI benefits\\\")]\\n\",\n    \"    \\n\",\n    \"    # Producer: Add chunks to buffer\\n\",\n    \"    async def producer():\\n\",\n    \"        async for chunk in provider.stream_completion(\\\"gpt-4\\\", messages):\\n\",\n    \"            success = await buffer.add_chunk(chunk)\\n\",\n    \"            if not success:\\n\",\n    \"                print(f\\\"⚠️  Buffer overflow! Chunk {chunk.chunk_id} dropped\\\")\\n\",\n    \"    \\n\",\n    \"    # Consumer: Process chunks from buffer\\n\",\n    \"    async def consumer():\\n\",\n    \"        processed_count = 0\\n\",\n    \"        while True:\\n\",\n    \"            chunks = await buffer.get_chunks(2)  # Process 2 at a time\\n\",\n    \"            if not chunks:\\n\",\n    \"                await asyncio.sleep(0.1)  # Wait for more data\\n\",\n    \"                continue\\n\",\n    \"            \\n\",\n    \"            for chunk in chunks:\\n\",\n    \"                processed_count += 1\\n\",\n    \"                print(f\\\"🔧 Processed chunk {chunk.chunk_id}: '{chunk.content.strip()}'\\\")\\n\",\n    \"                \\n\",\n    \"                if chunk.is_final:\\n\",\n    \"                    print(f\\\"✅ Processing complete! Total chunks: {processed_count}\\\")\\n\",\n    \"                    return\\n\",\n    \"            \\n\",\n    \"            await asyncio.sleep(0.1)  # Simulate processing time\\n\",\n    \"    \\n\",\n    \"    # Run producer and consumer concurrently\\n\",\n    \"    await asyncio.gather(producer(), consumer())\\n\",\n    \"    \\n\",\n    \"    stats = buffer.get_stats()\\n\",\n    \"    print(f\\\"📊 Buffer stats: {stats}\\\")\\n\",\n    \"\\n\",\n    \"# Run streaming demonstrations\\n\",\n    \"await demonstrate_streaming()\\n\",\n    \"await demonstrate_buffered_streaming()\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Streaming Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Real-time user feedback\\\")\\n\",\n    \"print(f\\\"  ✅ Lower perceived latency\\\")\\n\",\n    \"print(f\\\"  ✅ Memory efficiency for large responses\\\")\\n\",\n    \"print(f\\\"  ✅ Better resource utilization\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 3: Rate Limiting and Resource Control\\n\",\n    \"\\n\",\n    \"**First Principle**: Rate limiting prevents resource exhaustion and ensures fair usage across multiple clients.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `asyncio.Semaphore` and `asyncio.Lock` for controlling concurrent access to resources.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class AsyncRateLimiter:\\n\",\n    \"    \\\"\\\"\\\"Async rate limiter for API calls.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, max_calls: int, time_window: float):\\n\",\n    \"        self.max_calls = max_calls\\n\",\n    \"        self.time_window = time_window\\n\",\n    \"        self.calls: List[float] = []\\n\",\n    \"        self._lock = asyncio.Lock()\\n\",\n    \"    \\n\",\n    \"    async def acquire(self) -> None:\\n\",\n    \"        \\\"\\\"\\\"Acquire permission to make a call.\\\"\\\"\\\"\\n\",\n    \"        async with self._lock:\\n\",\n    \"            now = time.time()\\n\",\n    \"            \\n\",\n    \"            # Remove old calls outside the window\\n\",\n    \"            self.calls = [call_time for call_time in self.calls \\n\",\n    \"                         if now - call_time < self.time_window]\\n\",\n    \"            \\n\",\n    \"            # If we're at the limit, wait\\n\",\n    \"            if len(self.calls) >= self.max_calls:\\n\",\n    \"                oldest_call = min(self.calls)\\n\",\n    \"                wait_time = self.time_window - (now - oldest_call)\\n\",\n    \"                if wait_time > 0:\\n\",\n    \"                    print(f\\\"🚦 Rate limit reached, waiting {wait_time:.2f}s\\\")\\n\",\n    \"                    await asyncio.sleep(wait_time)\\n\",\n    \"                    # Recursive call to try again\\n\",\n    \"                    return await self.acquire()\\n\",\n    \"            \\n\",\n    \"            # Record this call\\n\",\n    \"            self.calls.append(now)\\n\",\n    \"    \\n\",\n    \"    def get_stats(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get rate limiter statistics.\\\"\\\"\\\"\\n\",\n    \"        now = time.time()\\n\",\n    \"        recent_calls = [call for call in self.calls if now - call < self.time_window]\\n\",\n    \"        return {\\n\",\n    \"            \\\"current_calls\\\": len(recent_calls),\\n\",\n    \"            \\\"max_calls\\\": self.max_calls,\\n\",\n    \"            \\\"time_window\\\": self.time_window,\\n\",\n    \"            \\\"utilization\\\": len(recent_calls) / self.max_calls\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"class TokenBucketRateLimiter:\\n\",\n    \"    \\\"\\\"\\\"Token bucket rate limiter for smooth rate limiting.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, tokens_per_second: float, bucket_size: int):\\n\",\n    \"        self.tokens_per_second = tokens_per_second\\n\",\n    \"        self.bucket_size = bucket_size\\n\",\n    \"        self.tokens = bucket_size\\n\",\n    \"        self.last_refill = time.time()\\n\",\n    \"        self._lock = asyncio.Lock()\\n\",\n    \"    \\n\",\n    \"    async def acquire(self, tokens_needed: int = 1) -> bool:\\n\",\n    \"        \\\"\\\"\\\"Try to acquire tokens from the bucket.\\\"\\\"\\\"\\n\",\n    \"        async with self._lock:\\n\",\n    \"            now = time.time()\\n\",\n    \"            \\n\",\n    \"            # Refill tokens based on time passed\\n\",\n    \"            time_passed = now - self.last_refill\\n\",\n    \"            tokens_to_add = time_passed * self.tokens_per_second\\n\",\n    \"            self.tokens = min(self.bucket_size, self.tokens + tokens_to_add)\\n\",\n    \"            self.last_refill = now\\n\",\n    \"            \\n\",\n    \"            # Check if we have enough tokens\\n\",\n    \"            if self.tokens >= tokens_needed:\\n\",\n    \"                self.tokens -= tokens_needed\\n\",\n    \"                return True\\n\",\n    \"            else:\\n\",\n    \"                # Calculate wait time for next token\\n\",\n    \"                tokens_deficit = tokens_needed - self.tokens\\n\",\n    \"                wait_time = tokens_deficit / self.tokens_per_second\\n\",\n    \"                print(f\\\"🪣 Token bucket empty, waiting {wait_time:.2f}s\\\")\\n\",\n    \"                await asyncio.sleep(wait_time)\\n\",\n    \"                return await self.acquire(tokens_needed)\\n\",\n    \"    \\n\",\n    \"    def get_stats(self) -> Dict[str, Any]:\\n\",\n    \"        return {\\n\",\n    \"            \\\"tokens\\\": self.tokens,\\n\",\n    \"            \\\"bucket_size\\\": self.bucket_size,\\n\",\n    \"            \\\"tokens_per_second\\\": self.tokens_per_second,\\n\",\n    \"            \\\"fill_percentage\\\": self.tokens / self.bucket_size * 100\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"async def demonstrate_rate_limiting():\\n\",\n    \"    \\\"\\\"\\\"Show rate limiting patterns.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    console.print(Panel(\\\"🚦 Rate Limiting\\\", style=\\\"bold green\\\"))\\n\",\n    \"    \\n\",\n    \"    # Test sliding window rate limiter\\n\",\n    \"    print(\\\"📊 Sliding window rate limiter (5 calls per 2 seconds):\\\")\\n\",\n    \"    \\n\",\n    \"    rate_limiter = AsyncRateLimiter(max_calls=5, time_window=2.0)\\n\",\n    \"    \\n\",\n    \"    async def make_api_call(call_id: int) -> str:\\n\",\n    \"        \\\"\\\"\\\"Simulate API call with rate limiting.\\\"\\\"\\\"\\n\",\n    \"        await rate_limiter.acquire()\\n\",\n    \"        # Simulate API processing time\\n\",\n    \"        await asyncio.sleep(0.1)\\n\",\n    \"        return f\\\"API call {call_id} completed\\\"\\n\",\n    \"    \\n\",\n    \"    start_time = time.time()\\n\",\n    \"    \\n\",\n    \"    # Create 10 rapid calls\\n\",\n    \"    tasks = [make_api_call(i) for i in range(10)]\\n\",\n    \"    \\n\",\n    \"    # Execute with progress tracking\\n\",\n    \"    results = []\\n\",\n    \"    for i, task in enumerate(asyncio.as_completed(tasks)):\\n\",\n    \"        result = await task\\n\",\n    \"        elapsed = time.time() - start_time\\n\",\n    \"        stats = rate_limiter.get_stats()\\n\",\n    \"        print(f\\\"  {elapsed:.2f}s: {result} (utilization: {stats['utilization']:.1%})\\\")\\n\",\n    \"        results.append(result)\\n\",\n    \"    \\n\",\n    \"    total_time = time.time() - start_time\\n\",\n    \"    print(f\\\"\\\\n📈 Rate limiting summary:\\\")\\n\",\n    \"    print(f\\\"  Total time: {total_time:.2f}s\\\")\\n\",\n    \"    print(f\\\"  Rate limiter stats: {rate_limiter.get_stats()}\\\")\\n\",\n    \"    \\n\",\n    \"    # Test token bucket rate limiter\\n\",\n    \"    print(f\\\"\\\\n🪣 Token bucket rate limiter (3 tokens/sec, bucket size 5):\\\")\\n\",\n    \"    \\n\",\n    \"    token_limiter = TokenBucketRateLimiter(tokens_per_second=3.0, bucket_size=5)\\n\",\n    \"    \\n\",\n    \"    async def make_weighted_call(call_id: int, tokens_needed: int = 1) -> str:\\n\",\n    \"        \\\"\\\"\\\"API call that may need multiple tokens.\\\"\\\"\\\"\\n\",\n    \"        await token_limiter.acquire(tokens_needed)\\n\",\n    \"        await asyncio.sleep(0.05)  # Simulate processing\\n\",\n    \"        return f\\\"Weighted call {call_id} (cost: {tokens_needed} tokens)\\\"\\n\",\n    \"    \\n\",\n    \"    # Different cost operations\\n\",\n    \"    operations = [\\n\",\n    \"        (1, 1),  # Light operation\\n\",\n    \"        (2, 2),  # Medium operation\\n\",\n    \"        (3, 1),  # Light operation\\n\",\n    \"        (4, 3),  # Heavy operation\\n\",\n    \"        (5, 1),  # Light operation\\n\",\n    \"        (6, 2),  # Medium operation\\n\",\n    \"    ]\\n\",\n    \"    \\n\",\n    \"    start_time = time.time()\\n\",\n    \"    \\n\",\n    \"    for call_id, tokens in operations:\\n\",\n    \"        result = await make_weighted_call(call_id, tokens)\\n\",\n    \"        elapsed = time.time() - start_time\\n\",\n    \"        stats = token_limiter.get_stats()\\n\",\n    \"        print(f\\\"  {elapsed:.2f}s: {result} (tokens left: {stats['tokens']:.1f})\\\")\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n📊 Final token bucket stats: {token_limiter.get_stats()}\\\")\\n\",\n    \"\\n\",\n    \"# Advanced rate limiting with priority queues\\n\",\n    \"class PriorityRateLimiter:\\n\",\n    \"    \\\"\\\"\\\"Rate limiter with priority queue support.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, max_calls: int, time_window: float):\\n\",\n    \"        self.base_limiter = AsyncRateLimiter(max_calls, time_window)\\n\",\n    \"        self.priority_queues = {\\n\",\n    \"            \\\"high\\\": asyncio.Queue(),\\n\",\n    \"            \\\"medium\\\": asyncio.Queue(),\\n\",\n    \"            \\\"low\\\": asyncio.Queue()\\n\",\n    \"        }\\n\",\n    \"        self._processing = False\\n\",\n    \"    \\n\",\n    \"    async def acquire(self, priority: str = \\\"medium\\\") -> None:\\n\",\n    \"        \\\"\\\"\\\"Acquire with priority.\\\"\\\"\\\"\\n\",\n    \"        if priority not in self.priority_queues:\\n\",\n    \"            priority = \\\"medium\\\"\\n\",\n    \"        \\n\",\n    \"        # Add request to appropriate queue\\n\",\n    \"        future = asyncio.Future()\\n\",\n    \"        await self.priority_queues[priority].put(future)\\n\",\n    \"        \\n\",\n    \"        # Start processing if not already running\\n\",\n    \"        if not self._processing:\\n\",\n    \"            asyncio.create_task(self._process_queues())\\n\",\n    \"        \\n\",\n    \"        # Wait for our turn\\n\",\n    \"        await future\\n\",\n    \"    \\n\",\n    \"    async def _process_queues(self):\\n\",\n    \"        \\\"\\\"\\\"Process requests in priority order.\\\"\\\"\\\"\\n\",\n    \"        self._processing = True\\n\",\n    \"        \\n\",\n    \"        try:\\n\",\n    \"            while True:\\n\",\n    \"                # Check queues in priority order\\n\",\n    \"                future = None\\n\",\n    \"                \\n\",\n    \"                for priority in [\\\"high\\\", \\\"medium\\\", \\\"low\\\"]:\\n\",\n    \"                    queue = self.priority_queues[priority]\\n\",\n    \"                    if not queue.empty():\\n\",\n    \"                        future = await queue.get()\\n\",\n    \"                        break\\n\",\n    \"                \\n\",\n    \"                if future is None:\\n\",\n    \"                    # No more requests\\n\",\n    \"                    break\\n\",\n    \"                \\n\",\n    \"                # Acquire from base rate limiter\\n\",\n    \"                await self.base_limiter.acquire()\\n\",\n    \"                \\n\",\n    \"                # Signal that request can proceed\\n\",\n    \"                if not future.cancelled():\\n\",\n    \"                    future.set_result(None)\\n\",\n    \"        \\n\",\n    \"        finally:\\n\",\n    \"            self._processing = False\\n\",\n    \"\\n\",\n    \"async def demonstrate_priority_rate_limiting():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate priority-based rate limiting.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n🎯 Priority rate limiting:\\\")\\n\",\n    \"    \\n\",\n    \"    priority_limiter = PriorityRateLimiter(max_calls=3, time_window=1.0)\\n\",\n    \"    \\n\",\n    \"    async def priority_task(task_id: int, priority: str, delay: float = 0.1):\\n\",\n    \"        \\\"\\\"\\\"Task with specific priority.\\\"\\\"\\\"\\n\",\n    \"        print(f\\\"🔄 Task {task_id} ({priority}) waiting...\\\")\\n\",\n    \"        await priority_limiter.acquire(priority)\\n\",\n    \"        print(f\\\"✅ Task {task_id} ({priority}) executing\\\")\\n\",\n    \"        await asyncio.sleep(delay)\\n\",\n    \"        return f\\\"Task {task_id} ({priority}) completed\\\"\\n\",\n    \"    \\n\",\n    \"    # Submit tasks with different priorities\\n\",\n    \"    tasks = [\\n\",\n    \"        priority_task(1, \\\"low\\\"),\\n\",\n    \"        priority_task(2, \\\"high\\\"),\\n\",\n    \"        priority_task(3, \\\"medium\\\"),\\n\",\n    \"        priority_task(4, \\\"low\\\"),\\n\",\n    \"        priority_task(5, \\\"high\\\"),\\n\",\n    \"        priority_task(6, \\\"medium\\\"),\\n\",\n    \"    ]\\n\",\n    \"    \\n\",\n    \"    results = await asyncio.gather(*tasks)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n📋 Execution order shows priority handling:\\\")\\n\",\n    \"    for result in results:\\n\",\n    \"        print(f\\\"  {result}\\\")\\n\",\n    \"\\n\",\n    \"# Run rate limiting demonstrations\\n\",\n    \"await demonstrate_rate_limiting()\\n\",\n    \"await demonstrate_priority_rate_limiting()\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Rate Limiting Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Prevents API quota exhaustion\\\")\\n\",\n    \"print(f\\\"  ✅ Ensures fair resource usage\\\")\\n\",\n    \"print(f\\\"  ✅ Protects against request bursts\\\")\\n\",\n    \"print(f\\\"  ✅ Enables priority-based processing\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 4: Connection Pooling and Resource Management\\n\",\n    \"\\n\",\n    \"**First Principle**: Connection pooling reuses expensive resources like database connections and HTTP sessions.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `asyncio.Queue` for resource pools and async context managers for automatic cleanup.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class AsyncConnectionPool:\\n\",\n    \"    \\\"\\\"\\\"Connection pool for managing async resources.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, create_connection: Callable, max_size: int = 10):\\n\",\n    \"        self.create_connection = create_connection\\n\",\n    \"        self.max_size = max_size\\n\",\n    \"        self.pool: asyncio.Queue = asyncio.Queue(maxsize=max_size)\\n\",\n    \"        self.created_count = 0\\n\",\n    \"        self.active_connections = 0\\n\",\n    \"        self._lock = asyncio.Lock()\\n\",\n    \"    \\n\",\n    \"    async def get_connection(self):\\n\",\n    \"        \\\"\\\"\\\"Get a connection from the pool.\\\"\\\"\\\"\\n\",\n    \"        try:\\n\",\n    \"            # Try to get existing connection with timeout\\n\",\n    \"            connection = await asyncio.wait_for(self.pool.get(), timeout=0.1)\\n\",\n    \"            self.active_connections += 1\\n\",\n    \"            return connection\\n\",\n    \"        except asyncio.TimeoutError:\\n\",\n    \"            # Create new connection if under limit\\n\",\n    \"            async with self._lock:\\n\",\n    \"                if self.created_count < self.max_size:\\n\",\n    \"                    connection = await self.create_connection()\\n\",\n    \"                    self.created_count += 1\\n\",\n    \"                    self.active_connections += 1\\n\",\n    \"                    return connection\\n\",\n    \"            \\n\",\n    \"            # Wait for available connection\\n\",\n    \"            connection = await self.pool.get()\\n\",\n    \"            self.active_connections += 1\\n\",\n    \"            return connection\\n\",\n    \"    \\n\",\n    \"    async def return_connection(self, connection):\\n\",\n    \"        \\\"\\\"\\\"Return connection to pool.\\\"\\\"\\\"\\n\",\n    \"        self.active_connections -= 1\\n\",\n    \"        await self.pool.put(connection)\\n\",\n    \"    \\n\",\n    \"    @asynccontextmanager\\n\",\n    \"    async def connection(self):\\n\",\n    \"        \\\"\\\"\\\"Context manager for automatic connection management.\\\"\\\"\\\"\\n\",\n    \"        conn = await self.get_connection()\\n\",\n    \"        try:\\n\",\n    \"            yield conn\\n\",\n    \"        finally:\\n\",\n    \"            await self.return_connection(conn)\\n\",\n    \"    \\n\",\n    \"    def get_stats(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get pool statistics.\\\"\\\"\\\"\\n\",\n    \"        return {\\n\",\n    \"            \\\"pool_size\\\": self.pool.qsize(),\\n\",\n    \"            \\\"created_count\\\": self.created_count,\\n\",\n    \"            \\\"active_connections\\\": self.active_connections,\\n\",\n    \"            \\\"max_size\\\": self.max_size,\\n\",\n    \"            \\\"utilization\\\": self.active_connections / self.max_size\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"# Mock connection class\\n\",\n    \"class MockConnection:\\n\",\n    \"    \\\"\\\"\\\"Mock database/API connection.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, connection_id: str):\\n\",\n    \"        self.id = connection_id\\n\",\n    \"        self.created_at = time.time()\\n\",\n    \"        self.request_count = 0\\n\",\n    \"        self.is_healthy = True\\n\",\n    \"    \\n\",\n    \"    async def execute_query(self, query: str) -> str:\\n\",\n    \"        \\\"\\\"\\\"Execute a mock query.\\\"\\\"\\\"\\n\",\n    \"        if not self.is_healthy:\\n\",\n    \"            raise ConnectionError(f\\\"Connection {self.id} is unhealthy\\\")\\n\",\n    \"        \\n\",\n    \"        self.request_count += 1\\n\",\n    \"        await asyncio.sleep(0.1)  # Simulate query time\\n\",\n    \"        return f\\\"Result for '{query}' via connection {self.id}\\\"\\n\",\n    \"    \\n\",\n    \"    def get_info(self) -> Dict[str, Any]:\\n\",\n    \"        return {\\n\",\n    \"            \\\"id\\\": self.id,\\n\",\n    \"            \\\"created_at\\\": self.created_at,\\n\",\n    \"            \\\"request_count\\\": self.request_count,\\n\",\n    \"            \\\"age_seconds\\\": time.time() - self.created_at\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"async def demonstrate_connection_pooling():\\n\",\n    \"    \\\"\\\"\\\"Show connection pooling patterns.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    console.print(Panel(\\\"🏊 Connection Pooling\\\", style=\\\"bold magenta\\\"))\\n\",\n    \"    \\n\",\n    \"    async def create_mock_connection():\\n\",\n    \"        \\\"\\\"\\\"Create a mock database connection.\\\"\\\"\\\"\\n\",\n    \"        connection_id = f\\\"conn_{int(time.time() * 1000) % 10000}\\\"\\n\",\n    \"        await asyncio.sleep(0.1)  # Simulate connection setup\\n\",\n    \"        print(f\\\"🔧 Created new connection: {connection_id}\\\")\\n\",\n    \"        return MockConnection(connection_id)\\n\",\n    \"    \\n\",\n    \"    # Create connection pool\\n\",\n    \"    pool = AsyncConnectionPool(create_mock_connection, max_size=3)\\n\",\n    \"    \\n\",\n    \"    async def database_operation(operation_id: int, query: str):\\n\",\n    \"        \\\"\\\"\\\"Simulate database operation using connection pool.\\\"\\\"\\\"\\n\",\n    \"        async with pool.connection() as conn:\\n\",\n    \"            result = await conn.execute_query(query)\\n\",\n    \"            return f\\\"Operation {operation_id}: {result}\\\"\\n\",\n    \"    \\n\",\n    \"    print(\\\"📊 Running concurrent database operations:\\\")\\n\",\n    \"    \\n\",\n    \"    # Run 8 concurrent operations with pool of 3 connections\\n\",\n    \"    queries = [\\n\",\n    \"        \\\"SELECT * FROM users\\\",\\n\",\n    \"        \\\"SELECT * FROM products\\\",\\n\",\n    \"        \\\"UPDATE inventory SET count=count-1\\\",\\n\",\n    \"        \\\"INSERT INTO logs VALUES (...)\\\",\\n\",\n    \"        \\\"SELECT AVG(price) FROM products\\\",\\n\",\n    \"        \\\"DELETE FROM cache WHERE expired=true\\\",\\n\",\n    \"        \\\"SELECT * FROM orders WHERE status='pending'\\\",\\n\",\n    \"        \\\"UPDATE users SET last_login=NOW()\\\"\\n\",\n    \"    ]\\n\",\n    \"    \\n\",\n    \"    start_time = time.time()\\n\",\n    \"    \\n\",\n    \"    tasks = [database_operation(i, query) for i, query in enumerate(queries)]\\n\",\n    \"    \\n\",\n    \"    for task in asyncio.as_completed(tasks):\\n\",\n    \"        result = await task\\n\",\n    \"        elapsed = time.time() - start_time\\n\",\n    \"        stats = pool.get_stats()\\n\",\n    \"        print(f\\\"  {elapsed:.2f}s: {result[:50]}...\\\")\\n\",\n    \"        print(f\\\"    Pool: {stats['active_connections']}/{stats['max_size']} active, {stats['pool_size']} available\\\")\\n\",\n    \"    \\n\",\n    \"    final_stats = pool.get_stats()\\n\",\n    \"    print(f\\\"\\\\n📈 Final Pool Stats:\\\")\\n\",\n    \"    print(f\\\"  Created connections: {final_stats['created_count']}\\\")\\n\",\n    \"    print(f\\\"  Active connections: {final_stats['active_connections']}\\\")\\n\",\n    \"    print(f\\\"  Pool utilization: {final_stats['utilization']:.1%}\\\")\\n\",\n    \"\\n\",\n    \"# Advanced connection pool with health checking\\n\",\n    \"class HealthAwareConnectionPool(AsyncConnectionPool):\\n\",\n    \"    \\\"\\\"\\\"Connection pool with health checking.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, create_connection: Callable, max_size: int = 10, health_check_interval: float = 30.0):\\n\",\n    \"        super().__init__(create_connection, max_size)\\n\",\n    \"        self.health_check_interval = health_check_interval\\n\",\n    \"        self.unhealthy_connections = set()\\n\",\n    \"        self._health_check_task = None\\n\",\n    \"    \\n\",\n    \"    async def start_health_checks(self):\\n\",\n    \"        \\\"\\\"\\\"Start background health checking.\\\"\\\"\\\"\\n\",\n    \"        if self._health_check_task is None:\\n\",\n    \"            self._health_check_task = asyncio.create_task(self._health_check_loop())\\n\",\n    \"    \\n\",\n    \"    async def stop_health_checks(self):\\n\",\n    \"        \\\"\\\"\\\"Stop background health checking.\\\"\\\"\\\"\\n\",\n    \"        if self._health_check_task:\\n\",\n    \"            self._health_check_task.cancel()\\n\",\n    \"            try:\\n\",\n    \"                await self._health_check_task\\n\",\n    \"            except asyncio.CancelledError:\\n\",\n    \"                pass\\n\",\n    \"            self._health_check_task = None\\n\",\n    \"    \\n\",\n    \"    async def _health_check_loop(self):\\n\",\n    \"        \\\"\\\"\\\"Background health checking loop.\\\"\\\"\\\"\\n\",\n    \"        while True:\\n\",\n    \"            try:\\n\",\n    \"                await asyncio.sleep(self.health_check_interval)\\n\",\n    \"                await self._check_pool_health()\\n\",\n    \"            except asyncio.CancelledError:\\n\",\n    \"                break\\n\",\n    \"            except Exception as e:\\n\",\n    \"                print(f\\\"⚠️  Health check error: {e}\\\")\\n\",\n    \"    \\n\",\n    \"    async def _check_pool_health(self):\\n\",\n    \"        \\\"\\\"\\\"Check health of pooled connections.\\\"\\\"\\\"\\n\",\n    \"        # This is a simplified health check\\n\",\n    \"        # In practice, you'd check connections more thoroughly\\n\",\n    \"        print(f\\\"🏥 Performing health check on {self.pool.qsize()} pooled connections\\\")\\n\",\n    \"        \\n\",\n    \"        # Remove old unhealthy connections from tracking\\n\",\n    \"        self.unhealthy_connections.clear()\\n\",\n    \"    \\n\",\n    \"    async def get_connection(self):\\n\",\n    \"        \\\"\\\"\\\"Get a healthy connection from the pool.\\\"\\\"\\\"\\n\",\n    \"        connection = await super().get_connection()\\n\",\n    \"        \\n\",\n    \"        # Check if connection is healthy\\n\",\n    \"        if hasattr(connection, 'is_healthy') and not connection.is_healthy:\\n\",\n    \"            print(f\\\"🚫 Connection {connection.id} is unhealthy, creating new one\\\")\\n\",\n    \"            # Create a replacement connection\\n\",\n    \"            new_connection = await self.create_connection()\\n\",\n    \"            return new_connection\\n\",\n    \"        \\n\",\n    \"        return connection\\n\",\n    \"\\n\",\n    \"async def demonstrate_health_aware_pooling():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate health-aware connection pooling.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n🏥 Health-aware connection pooling:\\\")\\n\",\n    \"    \\n\",\n    \"    async def create_connection_with_random_health():\\n\",\n    \"        \\\"\\\"\\\"Create connection that might become unhealthy.\\\"\\\"\\\"\\n\",\n    \"        import random\\n\",\n    \"        connection = await create_mock_connection()\\n\",\n    \"        # Simulate some connections becoming unhealthy\\n\",\n    \"        connection.is_healthy = random.random() > 0.3  # 30% chance of being unhealthy\\n\",\n    \"        return connection\\n\",\n    \"    \\n\",\n    \"    health_pool = HealthAwareConnectionPool(\\n\",\n    \"        create_connection_with_random_health, \\n\",\n    \"        max_size=2, \\n\",\n    \"        health_check_interval=2.0\\n\",\n    \"    )\\n\",\n    \"    \\n\",\n    \"    # Start health checks\\n\",\n    \"    await health_pool.start_health_checks()\\n\",\n    \"    \\n\",\n    \"    try:\\n\",\n    \"        # Use the pool\\n\",\n    \"        for i in range(5):\\n\",\n    \"            async with health_pool.connection() as conn:\\n\",\n    \"                try:\\n\",\n    \"                    result = await conn.execute_query(f\\\"Query {i}\\\")\\n\",\n    \"                    print(f\\\"✅ {result[:40]}...\\\")\\n\",\n    \"                except ConnectionError as e:\\n\",\n    \"                    print(f\\\"❌ {e}\\\")\\n\",\n    \"            \\n\",\n    \"            await asyncio.sleep(0.5)\\n\",\n    \"    \\n\",\n    \"    finally:\\n\",\n    \"        # Stop health checks\\n\",\n    \"        await health_pool.stop_health_checks()\\n\",\n    \"    \\n\",\n    \"    print(f\\\"📊 Health-aware pool stats: {health_pool.get_stats()}\\\")\\n\",\n    \"\\n\",\n    \"# Resource manager with lifecycle\\n\",\n    \"@asynccontextmanager\\n\",\n    \"async def managed_ai_service(service_config: Dict[str, Any]):\\n\",\n    \"    \\\"\\\"\\\"Context manager for AI service with full lifecycle.\\\"\\\"\\\"\\n\",\n    \"    print(f\\\"🚀 Starting AI service with config: {service_config}\\\")\\n\",\n    \"    \\n\",\n    \"    # Setup phase\\n\",\n    \"    service = {\\n\",\n    \"        \\\"id\\\": f\\\"service_{int(time.time())}\\\",\\n\",\n    \"        \\\"config\\\": service_config,\\n\",\n    \"        \\\"started_at\\\": time.time(),\\n\",\n    \"        \\\"request_count\\\": 0\\n\",\n    \"    }\\n\",\n    \"    \\n\",\n    \"    try:\\n\",\n    \"        # Simulate service initialization\\n\",\n    \"        await asyncio.sleep(0.1)\\n\",\n    \"        print(f\\\"✅ AI service {service['id']} ready\\\")\\n\",\n    \"        \\n\",\n    \"        yield service\\n\",\n    \"        \\n\",\n    \"    finally:\\n\",\n    \"        # Cleanup phase\\n\",\n    \"        uptime = time.time() - service['started_at']\\n\",\n    \"        print(f\\\"🧹 Shutting down service {service['id']} (uptime: {uptime:.2f}s, requests: {service['request_count']})\\\")\\n\",\n    \"        await asyncio.sleep(0.05)  # Simulate cleanup\\n\",\n    \"\\n\",\n    \"async def demonstrate_resource_lifecycle():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate resource lifecycle management.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n🔄 Resource lifecycle management:\\\")\\n\",\n    \"    \\n\",\n    \"    config = {\\\"model\\\": \\\"gpt-4\\\", \\\"temperature\\\": 0.7, \\\"max_workers\\\": 5}\\n\",\n    \"    \\n\",\n    \"    async with managed_ai_service(config) as service:\\n\",\n    \"        print(f\\\"📝 Using service: {service['id']}\\\")\\n\",\n    \"        \\n\",\n    \"        # Simulate some work\\n\",\n    \"        for i in range(3):\\n\",\n    \"            service['request_count'] += 1\\n\",\n    \"            await asyncio.sleep(0.1)\\n\",\n    \"            print(f\\\"  Processed request {i+1}\\\")\\n\",\n    \"    \\n\",\n    \"    print(f\\\"✅ Service lifecycle completed cleanly\\\")\\n\",\n    \"\\n\",\n    \"# Run connection pooling demonstrations\\n\",\n    \"await demonstrate_connection_pooling()\\n\",\n    \"await demonstrate_health_aware_pooling()\\n\",\n    \"await demonstrate_resource_lifecycle()\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Connection Pooling Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Reuses expensive resources\\\")\\n\",\n    \"print(f\\\"  ✅ Reduces connection overhead\\\")\\n\",\n    \"print(f\\\"  ✅ Controls resource usage\\\")\\n\",\n    \"print(f\\\"  ✅ Handles resource failures gracefully\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 5: Concurrent Processing and Task Management\\n\",\n    \"\\n\",\n    \"**First Principle**: Concurrent processing enables parallel execution of independent tasks, dramatically improving throughput.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `asyncio.gather()`, `asyncio.as_completed()`, and `asyncio.Semaphore` for managing concurrent operations.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class ConcurrentInferenceEngine:\\n\",\n    \"    \\\"\\\"\\\"Engine for managing concurrent AI inference requests.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, max_concurrent: int = 5):\\n\",\n    \"        self.max_concurrent = max_concurrent\\n\",\n    \"        self.semaphore = asyncio.Semaphore(max_concurrent)\\n\",\n    \"        self.active_tasks: Dict[str, asyncio.Task] = {}\\n\",\n    \"        self.completed_tasks: List[Dict[str, Any]] = []\\n\",\n    \"        self.task_counter = 0\\n\",\n    \"    \\n\",\n    \"    async def submit_task(\\n\",\n    \"        self, \\n\",\n    \"        task_id: str, \\n\",\n    \"        coro: Callable,\\n\",\n    \"        *args, \\n\",\n    \"        **kwargs\\n\",\n    \"    ) -> str:\\n\",\n    \"        \\\"\\\"\\\"Submit a task for concurrent execution.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        async def wrapped_task():\\n\",\n    \"            async with self.semaphore:\\n\",\n    \"                start_time = time.time()\\n\",\n    \"                try:\\n\",\n    \"                    result = await coro(*args, **kwargs)\\n\",\n    \"                    end_time = time.time()\\n\",\n    \"                    \\n\",\n    \"                    self.completed_tasks.append({\\n\",\n    \"                        \\\"task_id\\\": task_id,\\n\",\n    \"                        \\\"result\\\": result,\\n\",\n    \"                        \\\"duration\\\": end_time - start_time,\\n\",\n    \"                        \\\"status\\\": \\\"success\\\",\\n\",\n    \"                        \\\"error\\\": None\\n\",\n    \"                    })\\n\",\n    \"                    \\n\",\n    \"                    return result\\n\",\n    \"                    \\n\",\n    \"                except Exception as e:\\n\",\n    \"                    end_time = time.time()\\n\",\n    \"                    \\n\",\n    \"                    self.completed_tasks.append({\\n\",\n    \"                        \\\"task_id\\\": task_id,\\n\",\n    \"                        \\\"result\\\": None,\\n\",\n    \"                        \\\"duration\\\": end_time - start_time,\\n\",\n    \"                        \\\"status\\\": \\\"error\\\",\\n\",\n    \"                        \\\"error\\\": str(e)\\n\",\n    \"                    })\\n\",\n    \"                    \\n\",\n    \"                    raise\\n\",\n    \"                finally:\\n\",\n    \"                    # Remove from active tasks\\n\",\n    \"                    if task_id in self.active_tasks:\\n\",\n    \"                        del self.active_tasks[task_id]\\n\",\n    \"        \\n\",\n    \"        # Create and store task\\n\",\n    \"        task = asyncio.create_task(wrapped_task())\\n\",\n    \"        self.active_tasks[task_id] = task\\n\",\n    \"        self.task_counter += 1\\n\",\n    \"        \\n\",\n    \"        return task_id\\n\",\n    \"    \\n\",\n    \"    async def wait_for_task(self, task_id: str) -> Any:\\n\",\n    \"        \\\"\\\"\\\"Wait for specific task to complete.\\\"\\\"\\\"\\n\",\n    \"        if task_id in self.active_tasks:\\n\",\n    \"            return await self.active_tasks[task_id]\\n\",\n    \"        \\n\",\n    \"        # Check completed tasks\\n\",\n    \"        for completed in self.completed_tasks:\\n\",\n    \"            if completed[\\\"task_id\\\"] == task_id:\\n\",\n    \"                if completed[\\\"status\\\"] == \\\"error\\\":\\n\",\n    \"                    raise Exception(completed[\\\"error\\\"])\\n\",\n    \"                return completed[\\\"result\\\"]\\n\",\n    \"        \\n\",\n    \"        raise ValueError(f\\\"Task {task_id} not found\\\")\\n\",\n    \"    \\n\",\n    \"    async def wait_for_all(self) -> List[Any]:\\n\",\n    \"        \\\"\\\"\\\"Wait for all active tasks to complete.\\\"\\\"\\\"\\n\",\n    \"        if not self.active_tasks:\\n\",\n    \"            return []\\n\",\n    \"        \\n\",\n    \"        results = await asyncio.gather(*self.active_tasks.values(), return_exceptions=True)\\n\",\n    \"        return results\\n\",\n    \"    \\n\",\n    \"    async def cancel_task(self, task_id: str) -> bool:\\n\",\n    \"        \\\"\\\"\\\"Cancel a specific task.\\\"\\\"\\\"\\n\",\n    \"        if task_id in self.active_tasks:\\n\",\n    \"            task = self.active_tasks[task_id]\\n\",\n    \"            task.cancel()\\n\",\n    \"            del self.active_tasks[task_id]\\n\",\n    \"            return True\\n\",\n    \"        return False\\n\",\n    \"    \\n\",\n    \"    def get_stats(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get engine statistics.\\\"\\\"\\\"\\n\",\n    \"        completed_success = sum(1 for t in self.completed_tasks if t[\\\"status\\\"] == \\\"success\\\")\\n\",\n    \"        completed_error = sum(1 for t in self.completed_tasks if t[\\\"status\\\"] == \\\"error\\\")\\n\",\n    \"        \\n\",\n    \"        if self.completed_tasks:\\n\",\n    \"            avg_duration = sum(t[\\\"duration\\\"] for t in self.completed_tasks) / len(self.completed_tasks)\\n\",\n    \"        else:\\n\",\n    \"            avg_duration = 0.0\\n\",\n    \"        \\n\",\n    \"        return {\\n\",\n    \"            \\\"active_tasks\\\": len(self.active_tasks),\\n\",\n    \"            \\\"completed_tasks\\\": len(self.completed_tasks),\\n\",\n    \"            \\\"completed_success\\\": completed_success,\\n\",\n    \"            \\\"completed_error\\\": completed_error,\\n\",\n    \"            \\\"max_concurrent\\\": self.max_concurrent,\\n\",\n    \"            \\\"available_slots\\\": self.semaphore._value,\\n\",\n    \"            \\\"total_submitted\\\": self.task_counter,\\n\",\n    \"            \\\"avg_duration\\\": avg_duration\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"async def demonstrate_concurrent_processing():\\n\",\n    \"    \\\"\\\"\\\"Show concurrent processing patterns.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    console.print(Panel(\\\"⚡ Concurrent Processing\\\", style=\\\"bold cyan\\\"))\\n\",\n    \"    \\n\",\n    \"    # Create inference engine\\n\",\n    \"    engine = ConcurrentInferenceEngine(max_concurrent=3)\\n\",\n    \"    \\n\",\n    \"    async def mock_inference(text: str, delay: float = 0.5, fail_rate: float = 0.0) -> str:\\n\",\n    \"        \\\"\\\"\\\"Mock AI inference with variable delay and failure rate.\\\"\\\"\\\"\\n\",\n    \"        import random\\n\",\n    \"        \\n\",\n    \"        # Simulate random failure\\n\",\n    \"        if random.random() < fail_rate:\\n\",\n    \"            raise Exception(f\\\"Inference failed for: {text[:20]}...\\\")\\n\",\n    \"        \\n\",\n    \"        await asyncio.sleep(delay)\\n\",\n    \"        return f\\\"Processed: {text.upper()}\\\"\\n\",\n    \"    \\n\",\n    \"    print(\\\"🤖 Submitting concurrent inference tasks:\\\")\\n\",\n    \"    \\n\",\n    \"    # Submit multiple tasks with different characteristics\\n\",\n    \"    tasks_data = [\\n\",\n    \"        (\\\"task_1\\\", \\\"Analyze sentiment\\\", 0.3, 0.0),\\n\",\n    \"        (\\\"task_2\\\", \\\"Summarize document\\\", 0.8, 0.0),\\n\",\n    \"        (\\\"task_3\\\", \\\"Extract entities\\\", 0.5, 0.2),  # May fail\\n\",\n    \"        (\\\"task_4\\\", \\\"Classify text\\\", 0.4, 0.0),\\n\",\n    \"        (\\\"task_5\\\", \\\"Generate response\\\", 0.6, 0.1),  # May fail\\n\",\n    \"        (\\\"task_6\\\", \\\"Translate text\\\", 0.3, 0.0),\\n\",\n    \"    ]\\n\",\n    \"    \\n\",\n    \"    submitted_tasks = []\\n\",\n    \"    for task_id, text, delay, fail_rate in tasks_data:\\n\",\n    \"        await engine.submit_task(task_id, mock_inference, text, delay, fail_rate)\\n\",\n    \"        submitted_tasks.append(task_id)\\n\",\n    \"        print(f\\\"  ✅ Submitted: {task_id}\\\")\\n\",\n    \"    \\n\",\n    \"    # Monitor progress\\n\",\n    \"    print(f\\\"\\\\n📊 Monitoring task execution:\\\")\\n\",\n    \"    \\n\",\n    \"    while engine.active_tasks:\\n\",\n    \"        stats = engine.get_stats()\\n\",\n    \"        print(f\\\"  Active: {stats['active_tasks']}, Completed: {stats['completed_tasks']}, Available slots: {stats['available_slots']}\\\")\\n\",\n    \"        await asyncio.sleep(0.2)\\n\",\n    \"    \\n\",\n    \"    # Show final results\\n\",\n    \"    print(f\\\"\\\\n📋 Task Results:\\\")\\n\",\n    \"    for completed in engine.completed_tasks:\\n\",\n    \"        status_icon = \\\"✅\\\" if completed[\\\"status\\\"] == \\\"success\\\" else \\\"❌\\\"\\n\",\n    \"        result_preview = completed[\\\"result\\\"][:30] if completed[\\\"result\\\"] else completed[\\\"error\\\"][:30]\\n\",\n    \"        print(f\\\"  {status_icon} {completed['task_id']}: {completed['duration']:.2f}s - {result_preview}...\\\")\\n\",\n    \"    \\n\",\n    \"    final_stats = engine.get_stats()\\n\",\n    \"    print(f\\\"\\\\n📈 Final Statistics:\\\")\\n\",\n    \"    print(f\\\"  Total tasks: {final_stats['total_submitted']}\\\")\\n\",\n    \"    print(f\\\"  Successful: {final_stats['completed_success']}\\\")\\n\",\n    \"    print(f\\\"  Failed: {final_stats['completed_error']}\\\")\\n\",\n    \"    print(f\\\"  Average duration: {final_stats['avg_duration']:.2f}s\\\")\\n\",\n    \"\\n\",\n    \"# Advanced concurrent patterns\\n\",\n    \"class BatchProcessor:\\n\",\n    \"    \\\"\\\"\\\"Process items in batches with concurrency control.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, batch_size: int = 10, max_concurrent_batches: int = 3):\\n\",\n    \"        self.batch_size = batch_size\\n\",\n    \"        self.max_concurrent_batches = max_concurrent_batches\\n\",\n    \"        self.semaphore = asyncio.Semaphore(max_concurrent_batches)\\n\",\n    \"    \\n\",\n    \"    async def process_batch(\\n\",\n    \"        self,\\n\",\n    \"        items: List[Any],\\n\",\n    \"        processor: Callable,\\n\",\n    \"        **kwargs\\n\",\n    \"    ) -> List[Any]:\\n\",\n    \"        \\\"\\\"\\\"Process items in concurrent batches.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        async def process_single_batch(batch_items: List[Any], batch_id: int) -> List[Any]:\\n\",\n    \"            \\\"\\\"\\\"Process a single batch.\\\"\\\"\\\"\\n\",\n    \"            async with self.semaphore:\\n\",\n    \"                print(f\\\"🔄 Processing batch {batch_id} ({len(batch_items)} items)\\\")\\n\",\n    \"                \\n\",\n    \"                # Process items in batch concurrently\\n\",\n    \"                tasks = [processor(item, **kwargs) for item in batch_items]\\n\",\n    \"                results = await asyncio.gather(*tasks, return_exceptions=True)\\n\",\n    \"                \\n\",\n    \"                print(f\\\"✅ Completed batch {batch_id}\\\")\\n\",\n    \"                return results\\n\",\n    \"        \\n\",\n    \"        # Split items into batches\\n\",\n    \"        batches = [\\n\",\n    \"            items[i:i + self.batch_size] \\n\",\n    \"            for i in range(0, len(items), self.batch_size)\\n\",\n    \"        ]\\n\",\n    \"        \\n\",\n    \"        print(f\\\"📦 Processing {len(items)} items in {len(batches)} batches\\\")\\n\",\n    \"        \\n\",\n    \"        # Process batches concurrently\\n\",\n    \"        batch_tasks = [\\n\",\n    \"            process_single_batch(batch, i) \\n\",\n    \"            for i, batch in enumerate(batches)\\n\",\n    \"        ]\\n\",\n    \"        \\n\",\n    \"        batch_results = await asyncio.gather(*batch_tasks)\\n\",\n    \"        \\n\",\n    \"        # Flatten results\\n\",\n    \"        all_results = []\\n\",\n    \"        for batch_result in batch_results:\\n\",\n    \"            all_results.extend(batch_result)\\n\",\n    \"        \\n\",\n    \"        return all_results\\n\",\n    \"\\n\",\n    \"async def demonstrate_batch_processing():\\n\",\n    \"    \\\"\\\"\\\"Show batch processing patterns.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n📦 Batch Processing:\\\")\\n\",\n    \"    \\n\",\n    \"    async def process_text_item(text: str, operation: str = \\\"uppercase\\\") -> str:\\n\",\n    \"        \\\"\\\"\\\"Process a single text item.\\\"\\\"\\\"\\n\",\n    \"        await asyncio.sleep(0.1)  # Simulate processing\\n\",\n    \"        \\n\",\n    \"        if operation == \\\"uppercase\\\":\\n\",\n    \"            return text.upper()\\n\",\n    \"        elif operation == \\\"reverse\\\":\\n\",\n    \"            return text[::-1]\\n\",\n    \"        else:\\n\",\n    \"            return f\\\"PROCESSED: {text}\\\"\\n\",\n    \"    \\n\",\n    \"    # Create test data\\n\",\n    \"    texts = [f\\\"text item {i}\\\" for i in range(25)]\\n\",\n    \"    \\n\",\n    \"    processor = BatchProcessor(batch_size=5, max_concurrent_batches=2)\\n\",\n    \"    \\n\",\n    \"    start_time = time.time()\\n\",\n    \"    \\n\",\n    \"    results = await processor.process_batch(\\n\",\n    \"        texts, \\n\",\n    \"        process_text_item, \\n\",\n    \"        operation=\\\"uppercase\\\"\\n\",\n    \"    )\\n\",\n    \"    \\n\",\n    \"    processing_time = time.time() - start_time\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n📊 Batch Processing Results:\\\")\\n\",\n    \"    print(f\\\"  Total items: {len(texts)}\\\")\\n\",\n    \"    print(f\\\"  Processing time: {processing_time:.2f}s\\\")\\n\",\n    \"    print(f\\\"  Items per second: {len(texts) / processing_time:.1f}\\\")\\n\",\n    \"    print(f\\\"  Sample results: {results[:3]}\\\")\\n\",\n    \"    \\n\",\n    \"    # Count errors\\n\",\n    \"    errors = [r for r in results if isinstance(r, Exception)]\\n\",\n    \"    print(f\\\"  Errors: {len(errors)}\\\")\\n\",\n    \"\\n\",\n    \"# Progress tracking for concurrent operations\\n\",\n    \"class ProgressTracker:\\n\",\n    \"    \\\"\\\"\\\"Track progress of concurrent operations.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, total_tasks: int):\\n\",\n    \"        self.total_tasks = total_tasks\\n\",\n    \"        self.completed_tasks = 0\\n\",\n    \"        self.failed_tasks = 0\\n\",\n    \"        self.start_time = time.time()\\n\",\n    \"        self._lock = asyncio.Lock()\\n\",\n    \"    \\n\",\n    \"    async def task_completed(self, success: bool = True):\\n\",\n    \"        \\\"\\\"\\\"Mark a task as completed.\\\"\\\"\\\"\\n\",\n    \"        async with self._lock:\\n\",\n    \"            if success:\\n\",\n    \"                self.completed_tasks += 1\\n\",\n    \"            else:\\n\",\n    \"                self.failed_tasks += 1\\n\",\n    \"    \\n\",\n    \"    def get_progress(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get current progress.\\\"\\\"\\\"\\n\",\n    \"        total_finished = self.completed_tasks + self.failed_tasks\\n\",\n    \"        progress_pct = (total_finished / self.total_tasks) * 100 if self.total_tasks > 0 else 0\\n\",\n    \"        elapsed_time = time.time() - self.start_time\\n\",\n    \"        \\n\",\n    \"        if total_finished > 0:\\n\",\n    \"            estimated_total_time = elapsed_time * (self.total_tasks / total_finished)\\n\",\n    \"            eta = estimated_total_time - elapsed_time\\n\",\n    \"        else:\\n\",\n    \"            eta = 0\\n\",\n    \"        \\n\",\n    \"        return {\\n\",\n    \"            \\\"completed\\\": self.completed_tasks,\\n\",\n    \"            \\\"failed\\\": self.failed_tasks,\\n\",\n    \"            \\\"total\\\": self.total_tasks,\\n\",\n    \"            \\\"progress_pct\\\": progress_pct,\\n\",\n    \"            \\\"elapsed_time\\\": elapsed_time,\\n\",\n    \"            \\\"eta\\\": max(0, eta)\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"async def demonstrate_progress_tracking():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate progress tracking for concurrent tasks.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n📈 Progress Tracking:\\\")\\n\",\n    \"    \\n\",\n    \"    total_tasks = 20\\n\",\n    \"    tracker = ProgressTracker(total_tasks)\\n\",\n    \"    \\n\",\n    \"    async def tracked_task(task_id: int, delay: float, fail_rate: float = 0.1):\\n\",\n    \"        \\\"\\\"\\\"Task with progress tracking.\\\"\\\"\\\"\\n\",\n    \"        import random\\n\",\n    \"        \\n\",\n    \"        try:\\n\",\n    \"            await asyncio.sleep(delay)\\n\",\n    \"            \\n\",\n    \"            if random.random() < fail_rate:\\n\",\n    \"                raise Exception(f\\\"Task {task_id} failed\\\")\\n\",\n    \"            \\n\",\n    \"            await tracker.task_completed(success=True)\\n\",\n    \"            return f\\\"Task {task_id} completed\\\"\\n\",\n    \"            \\n\",\n    \"        except Exception as e:\\n\",\n    \"            await tracker.task_completed(success=False)\\n\",\n    \"            raise\\n\",\n    \"    \\n\",\n    \"    # Start all tasks\\n\",\n    \"    tasks = [\\n\",\n    \"        asyncio.create_task(tracked_task(i, random.uniform(0.1, 0.5), 0.15))\\n\",\n    \"        for i in range(total_tasks)\\n\",\n    \"    ]\\n\",\n    \"    \\n\",\n    \"    # Monitor progress\\n\",\n    \"    while True:\\n\",\n    \"        progress = tracker.get_progress()\\n\",\n    \"        finished = progress[\\\"completed\\\"] + progress[\\\"failed\\\"]\\n\",\n    \"        \\n\",\n    \"        print(f\\\"\\\\r📊 Progress: {finished}/{total_tasks} ({progress['progress_pct']:.1f}%) - \\\" +\\n\",\n    \"              f\\\"✅ {progress['completed']} success, ❌ {progress['failed']} failed - \\\" +\\n\",\n    \"              f\\\"ETA: {progress['eta']:.1f}s\\\", end=\\\"\\\")\\n\",\n    \"        \\n\",\n    \"        if finished >= total_tasks:\\n\",\n    \"            break\\n\",\n    \"        \\n\",\n    \"        await asyncio.sleep(0.1)\\n\",\n    \"    \\n\",\n    \"    print()  # New line\\n\",\n    \"    \\n\",\n    \"    # Wait for all tasks to complete\\n\",\n    \"    results = await asyncio.gather(*tasks, return_exceptions=True)\\n\",\n    \"    \\n\",\n    \"    success_count = sum(1 for r in results if not isinstance(r, Exception))\\n\",\n    \"    error_count = sum(1 for r in results if isinstance(r, Exception))\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n✅ All tasks completed: {success_count} success, {error_count} errors\\\")\\n\",\n    \"\\n\",\n    \"# Run concurrent processing demonstrations\\n\",\n    \"await demonstrate_concurrent_processing()\\n\",\n    \"await demonstrate_batch_processing()\\n\",\n    \"await demonstrate_progress_tracking()\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Concurrent Processing Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Dramatically improves throughput\\\")\\n\",\n    \"print(f\\\"  ✅ Better resource utilization\\\")\\n\",\n    \"print(f\\\"  ✅ Handles mixed workloads efficiently\\\")\\n\",\n    \"print(f\\\"  ✅ Provides failure isolation\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 6: Production-Ready Async AI System\\n\",\n    \"\\n\",\n    \"**First Principle**: Combine all async patterns to create a robust, scalable AI processing system.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use composition of async components to build complex, maintainable systems.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Complete async AI processing system\\n\",\n    \"from dataclasses import dataclass, field\\n\",\n    \"from typing import Protocol\\n\",\n    \"import json\\n\",\n    \"\\n\",\n    \"@dataclass\\n\",\n    \"class AIRequest:\\n\",\n    \"    \\\"\\\"\\\"AI processing request.\\\"\\\"\\\"\\n\",\n    \"    request_id: str\\n\",\n    \"    text: str\\n\",\n    \"    operation: str  # \\\"classify\\\", \\\"summarize\\\", \\\"translate\\\", etc.\\n\",\n    \"    priority: str = \\\"medium\\\"  # \\\"high\\\", \\\"medium\\\", \\\"low\\\"\\n\",\n    \"    metadata: Dict[str, Any] = field(default_factory=dict)\\n\",\n    \"    created_at: float = field(default_factory=time.time)\\n\",\n    \"\\n\",\n    \"@dataclass\\n\",\n    \"class AIResponse:\\n\",\n    \"    \\\"\\\"\\\"AI processing response.\\\"\\\"\\\"\\n\",\n    \"    request_id: str\\n\",\n    \"    result: Any\\n\",\n    \"    status: str  # \\\"success\\\", \\\"error\\\", \\\"timeout\\\"\\n\",\n    \"    processing_time: float\\n\",\n    \"    model_used: str\\n\",\n    \"    error_message: Optional[str] = None\\n\",\n    \"    completed_at: float = field(default_factory=time.time)\\n\",\n    \"\\n\",\n    \"class AsyncAISystem:\\n\",\n    \"    \\\"\\\"\\\"Production-ready async AI processing system.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(\\n\",\n    \"        self,\\n\",\n    \"        max_concurrent: int = 10,\\n\",\n    \"        rate_limit_per_second: float = 5.0,\\n\",\n    \"        connection_pool_size: int = 5,\\n\",\n    \"        request_timeout: float = 30.0\\n\",\n    \"    ):\\n\",\n    \"        self.max_concurrent = max_concurrent\\n\",\n    \"        self.request_timeout = request_timeout\\n\",\n    \"        \\n\",\n    \"        # Core components\\n\",\n    \"        self.inference_engine = ConcurrentInferenceEngine(max_concurrent)\\n\",\n    \"        self.rate_limiter = TokenBucketRateLimiter(rate_limit_per_second, bucket_size=10)\\n\",\n    \"        self.connection_pool = None  # Will be initialized with mock connections\\n\",\n    \"        \\n\",\n    \"        # Request tracking\\n\",\n    \"        self.active_requests: Dict[str, AIRequest] = {}\\n\",\n    \"        self.completed_requests: List[AIResponse] = []\\n\",\n    \"        \\n\",\n    \"        # Metrics\\n\",\n    \"        self.metrics = {\\n\",\n    \"            \\\"total_requests\\\": 0,\\n\",\n    \"            \\\"successful_requests\\\": 0,\\n\",\n    \"            \\\"failed_requests\\\": 0,\\n\",\n    \"            \\\"timeout_requests\\\": 0,\\n\",\n    \"            \\\"total_processing_time\\\": 0.0\\n\",\n    \"        }\\n\",\n    \"        \\n\",\n    \"        # Background tasks\\n\",\n    \"        self._background_tasks = set()\\n\",\n    \"    \\n\",\n    \"    async def start(self):\\n\",\n    \"        \\\"\\\"\\\"Start the AI system.\\\"\\\"\\\"\\n\",\n    \"        print(\\\"🚀 Starting Async AI System...\\\")\\n\",\n    \"        \\n\",\n    \"        # Initialize connection pool\\n\",\n    \"        async def create_ai_connection():\\n\",\n    \"            await asyncio.sleep(0.1)  # Simulate connection setup\\n\",\n    \"            return MockConnection(f\\\"ai_conn_{int(time.time() * 1000) % 1000}\\\")\\n\",\n    \"        \\n\",\n    \"        self.connection_pool = AsyncConnectionPool(\\n\",\n    \"            create_ai_connection, \\n\",\n    \"            max_size=5\\n\",\n    \"        )\\n\",\n    \"        \\n\",\n    \"        # Start background monitoring\\n\",\n    \"        monitor_task = asyncio.create_task(self._monitor_system())\\n\",\n    \"        self._background_tasks.add(monitor_task)\\n\",\n    \"        \\n\",\n    \"        print(\\\"✅ AI System started successfully\\\")\\n\",\n    \"    \\n\",\n    \"    async def stop(self):\\n\",\n    \"        \\\"\\\"\\\"Stop the AI system gracefully.\\\"\\\"\\\"\\n\",\n    \"        print(\\\"🛑 Stopping Async AI System...\\\")\\n\",\n    \"        \\n\",\n    \"        # Cancel background tasks\\n\",\n    \"        for task in self._background_tasks:\\n\",\n    \"            task.cancel()\\n\",\n    \"        \\n\",\n    \"        # Wait for active requests to complete\\n\",\n    \"        if self.active_requests:\\n\",\n    \"            print(f\\\"⏳ Waiting for {len(self.active_requests)} active requests...\\\")\\n\",\n    \"            # In practice, you'd set a timeout here\\n\",\n    \"            await asyncio.sleep(1.0)\\n\",\n    \"        \\n\",\n    \"        print(\\\"✅ AI System stopped\\\")\\n\",\n    \"    \\n\",\n    \"    async def process_request(self, request: AIRequest) -> AIResponse:\\n\",\n    \"        \\\"\\\"\\\"Process a single AI request.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        # Rate limiting\\n\",\n    \"        await self.rate_limiter.acquire(tokens_needed=1)\\n\",\n    \"        \\n\",\n    \"        # Track request\\n\",\n    \"        self.active_requests[request.request_id] = request\\n\",\n    \"        self.metrics[\\\"total_requests\\\"] += 1\\n\",\n    \"        \\n\",\n    \"        try:\\n\",\n    \"            # Process with timeout\\n\",\n    \"            response = await asyncio.wait_for(\\n\",\n    \"                self._execute_request(request),\\n\",\n    \"                timeout=self.request_timeout\\n\",\n    \"            )\\n\",\n    \"            \\n\",\n    \"            self.metrics[\\\"successful_requests\\\"] += 1\\n\",\n    \"            \\n\",\n    \"        except asyncio.TimeoutError:\\n\",\n    \"            response = AIResponse(\\n\",\n    \"                request_id=request.request_id,\\n\",\n    \"                result=None,\\n\",\n    \"                status=\\\"timeout\\\",\\n\",\n    \"                processing_time=self.request_timeout,\\n\",\n    \"                model_used=\\\"none\\\",\\n\",\n    \"                error_message=\\\"Request timeout\\\"\\n\",\n    \"            )\\n\",\n    \"            self.metrics[\\\"timeout_requests\\\"] += 1\\n\",\n    \"            \\n\",\n    \"        except Exception as e:\\n\",\n    \"            response = AIResponse(\\n\",\n    \"                request_id=request.request_id,\\n\",\n    \"                result=None,\\n\",\n    \"                status=\\\"error\\\",\\n\",\n    \"                processing_time=0.0,\\n\",\n    \"                model_used=\\\"none\\\",\\n\",\n    \"                error_message=str(e)\\n\",\n    \"            )\\n\",\n    \"            self.metrics[\\\"failed_requests\\\"] += 1\\n\",\n    \"        \\n\",\n    \"        finally:\\n\",\n    \"            # Clean up\\n\",\n    \"            if request.request_id in self.active_requests:\\n\",\n    \"                del self.active_requests[request.request_id]\\n\",\n    \"            \\n\",\n    \"            self.completed_requests.append(response)\\n\",\n    \"            self.metrics[\\\"total_processing_time\\\"] += response.processing_time\\n\",\n    \"        \\n\",\n    \"        return response\\n\",\n    \"    \\n\",\n    \"    async def _execute_request(self, request: AIRequest) -> AIResponse:\\n\",\n    \"        \\\"\\\"\\\"Execute the actual AI processing.\\\"\\\"\\\"\\n\",\n    \"        start_time = time.time()\\n\",\n    \"        \\n\",\n    \"        async with self.connection_pool.connection() as conn:\\n\",\n    \"            # Simulate different AI operations\\n\",\n    \"            if request.operation == \\\"classify\\\":\\n\",\n    \"                await asyncio.sleep(0.2)  # Simulate classification\\n\",\n    \"                result = {\\\"category\\\": \\\"positive\\\", \\\"confidence\\\": 0.85}\\n\",\n    \"                model = \\\"classifier-v1\\\"\\n\",\n    \"                \\n\",\n    \"            elif request.operation == \\\"summarize\\\":\\n\",\n    \"                await asyncio.sleep(0.5)  # Simulate summarization\\n\",\n    \"                result = {\\\"summary\\\": f\\\"Summary of: {request.text[:30]}...\\\"}\\n\",\n    \"                model = \\\"summarizer-v2\\\"\\n\",\n    \"                \\n\",\n    \"            elif request.operation == \\\"translate\\\":\\n\",\n    \"                await asyncio.sleep(0.3)  # Simulate translation\\n\",\n    \"                result = {\\\"translated_text\\\": f\\\"TRANSLATED: {request.text}\\\"}\\n\",\n    \"                model = \\\"translator-v1\\\"\\n\",\n    \"                \\n\",\n    \"            else:\\n\",\n    \"                raise ValueError(f\\\"Unknown operation: {request.operation}\\\")\\n\",\n    \"            \\n\",\n    \"            processing_time = time.time() - start_time\\n\",\n    \"            \\n\",\n    \"            return AIResponse(\\n\",\n    \"                request_id=request.request_id,\\n\",\n    \"                result=result,\\n\",\n    \"                status=\\\"success\\\",\\n\",\n    \"                processing_time=processing_time,\\n\",\n    \"                model_used=model\\n\",\n    \"            )\\n\",\n    \"    \\n\",\n    \"    async def process_batch(self, requests: List[AIRequest]) -> List[AIResponse]:\\n\",\n    \"        \\\"\\\"\\\"Process multiple requests concurrently.\\\"\\\"\\\"\\n\",\n    \"        print(f\\\"📦 Processing batch of {len(requests)} requests\\\")\\n\",\n    \"        \\n\",\n    \"        # Group by priority\\n\",\n    \"        priority_groups = {\\\"high\\\": [], \\\"medium\\\": [], \\\"low\\\": []}\\n\",\n    \"        for request in requests:\\n\",\n    \"            priority_groups[request.priority].append(request)\\n\",\n    \"        \\n\",\n    \"        # Process high priority first\\n\",\n    \"        all_responses = []\\n\",\n    \"        for priority in [\\\"high\\\", \\\"medium\\\", \\\"low\\\"]:\\n\",\n    \"            if priority_groups[priority]:\\n\",\n    \"                print(f\\\"🎯 Processing {len(priority_groups[priority])} {priority} priority requests\\\")\\n\",\n    \"                \\n\",\n    \"                tasks = [\\n\",\n    \"                    self.process_request(request) \\n\",\n    \"                    for request in priority_groups[priority]\\n\",\n    \"                ]\\n\",\n    \"                \\n\",\n    \"                responses = await asyncio.gather(*tasks, return_exceptions=True)\\n\",\n    \"                \\n\",\n    \"                # Handle any exceptions\\n\",\n    \"                for i, response in enumerate(responses):\\n\",\n    \"                    if isinstance(response, Exception):\\n\",\n    \"                        # Create error response\\n\",\n    \"                        request = priority_groups[priority][i]\\n\",\n    \"                        response = AIResponse(\\n\",\n    \"                            request_id=request.request_id,\\n\",\n    \"                            result=None,\\n\",\n    \"                            status=\\\"error\\\",\\n\",\n    \"                            processing_time=0.0,\\n\",\n    \"                            model_used=\\\"none\\\",\\n\",\n    \"                            error_message=str(response)\\n\",\n    \"                        )\\n\",\n    \"                \\n\",\n    \"                all_responses.extend(responses)\\n\",\n    \"        \\n\",\n    \"        return all_responses\\n\",\n    \"    \\n\",\n    \"    async def _monitor_system(self):\\n\",\n    \"        \\\"\\\"\\\"Background monitoring task.\\\"\\\"\\\"\\n\",\n    \"        while True:\\n\",\n    \"            try:\\n\",\n    \"                await asyncio.sleep(5.0)  # Monitor every 5 seconds\\n\",\n    \"                \\n\",\n    \"                stats = self.get_system_stats()\\n\",\n    \"                print(f\\\"📊 System Monitor: {stats['active_requests']} active, \\\"\\n\",\n    \"                      f\\\"{stats['total_requests']} total, \\\"\\n\",\n    \"                      f\\\"{stats['success_rate']:.1%} success rate\\\")\\n\",\n    \"                \\n\",\n    \"            except asyncio.CancelledError:\\n\",\n    \"                break\\n\",\n    \"            except Exception as e:\\n\",\n    \"                print(f\\\"⚠️  Monitor error: {e}\\\")\\n\",\n    \"    \\n\",\n    \"    def get_system_stats(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get comprehensive system statistics.\\\"\\\"\\\"\\n\",\n    \"        total_requests = self.metrics[\\\"total_requests\\\"]\\n\",\n    \"        success_rate = (self.metrics[\\\"successful_requests\\\"] / total_requests) if total_requests > 0 else 0\\n\",\n    \"        avg_processing_time = (self.metrics[\\\"total_processing_time\\\"] / self.metrics[\\\"successful_requests\\\"]) if self.metrics[\\\"successful_requests\\\"] > 0 else 0\\n\",\n    \"        \\n\",\n    \"        pool_stats = self.connection_pool.get_stats() if self.connection_pool else {}\\n\",\n    \"        rate_limiter_stats = self.rate_limiter.get_stats()\\n\",\n    \"        \\n\",\n    \"        return {\\n\",\n    \"            \\\"active_requests\\\": len(self.active_requests),\\n\",\n    \"            \\\"total_requests\\\": total_requests,\\n\",\n    \"            \\\"successful_requests\\\": self.metrics[\\\"successful_requests\\\"],\\n\",\n    \"            \\\"failed_requests\\\": self.metrics[\\\"failed_requests\\\"],\\n\",\n    \"            \\\"timeout_requests\\\": self.metrics[\\\"timeout_requests\\\"],\\n\",\n    \"            \\\"success_rate\\\": success_rate,\\n\",\n    \"            \\\"avg_processing_time\\\": avg_processing_time,\\n\",\n    \"            \\\"connection_pool\\\": pool_stats,\\n\",\n    \"            \\\"rate_limiter\\\": rate_limiter_stats\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"async def demonstrate_production_system():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate the complete production async AI system.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    console.print(Panel(\\\"🏭 Production Async AI System\\\", style=\\\"bold green\\\"))\\n\",\n    \"    \\n\",\n    \"    # Create and start the system\\n\",\n    \"    ai_system = AsyncAISystem(\\n\",\n    \"        max_concurrent=5,\\n\",\n    \"        rate_limit_per_second=3.0,\\n\",\n    \"        connection_pool_size=3,\\n\",\n    \"        request_timeout=10.0\\n\",\n    \"    )\\n\",\n    \"    \\n\",\n    \"    await ai_system.start()\\n\",\n    \"    \\n\",\n    \"    try:\\n\",\n    \"        # Create diverse test requests\\n\",\n    \"        requests = [\\n\",\n    \"            AIRequest(\\\"req_001\\\", \\\"Analyze this positive sentiment\\\", \\\"classify\\\", \\\"high\\\"),\\n\",\n    \"            AIRequest(\\\"req_002\\\", \\\"Long document that needs summarization...\\\", \\\"summarize\\\", \\\"medium\\\"),\\n\",\n    \"            AIRequest(\\\"req_003\\\", \\\"Hello world\\\", \\\"translate\\\", \\\"low\\\"),\\n\",\n    \"            AIRequest(\\\"req_004\\\", \\\"Another classification task\\\", \\\"classify\\\", \\\"medium\\\"),\\n\",\n    \"            AIRequest(\\\"req_005\\\", \\\"Important urgent request\\\", \\\"classify\\\", \\\"high\\\"),\\n\",\n    \"            AIRequest(\\\"req_006\\\", \\\"Text to translate\\\", \\\"translate\\\", \\\"low\\\"),\\n\",\n    \"            AIRequest(\\\"req_007\\\", \\\"Document for summary\\\", \\\"summarize\\\", \\\"medium\\\"),\\n\",\n    \"            AIRequest(\\\"req_008\\\", \\\"Final classification\\\", \\\"classify\\\", \\\"low\\\"),\\n\",\n    \"        ]\\n\",\n    \"        \\n\",\n    \"        print(f\\\"\\\\n🚀 Processing {len(requests)} requests through production system:\\\")\\n\",\n    \"        \\n\",\n    \"        # Process requests in batch\\n\",\n    \"        start_time = time.time()\\n\",\n    \"        responses = await ai_system.process_batch(requests)\\n\",\n    \"        total_time = time.time() - start_time\\n\",\n    \"        \\n\",\n    \"        print(f\\\"\\\\n📋 Processing Results:\\\")\\n\",\n    \"        for response in responses:\\n\",\n    \"            status_icon = \\\"✅\\\" if response.status == \\\"success\\\" else \\\"❌\\\" if response.status == \\\"error\\\" else \\\"⏰\\\"\\n\",\n    \"            result_preview = str(response.result)[:40] if response.result else response.error_message[:40]\\n\",\n    \"            print(f\\\"  {status_icon} {response.request_id}: {response.processing_time:.3f}s - {response.model_used} - {result_preview}...\\\")\\n\",\n    \"        \\n\",\n    \"        # Show comprehensive statistics\\n\",\n    \"        stats = ai_system.get_system_stats()\\n\",\n    \"        \\n\",\n    \"        print(f\\\"\\\\n📊 System Performance:\\\")\\n\",\n    \"        print(f\\\"  Total processing time: {total_time:.2f}s\\\")\\n\",\n    \"        print(f\\\"  Average per request: {total_time / len(requests):.3f}s\\\")\\n\",\n    \"        print(f\\\"  Success rate: {stats['success_rate']:.1%}\\\")\\n\",\n    \"        print(f\\\"  Average AI processing time: {stats['avg_processing_time']:.3f}s\\\")\\n\",\n    \"        \\n\",\n    \"        print(f\\\"\\\\n🔧 Resource Utilization:\\\")\\n\",\n    \"        print(f\\\"  Connection pool: {stats['connection_pool']}\\\")\\n\",\n    \"        print(f\\\"  Rate limiter: {stats['rate_limiter']}\\\")\\n\",\n    \"        \\n\",\n    \"        # Test streaming capabilities\\n\",\n    \"        print(f\\\"\\\\n🌊 Testing streaming response:\\\")\\n\",\n    \"        \\n\",\n    \"        provider = StreamingAIProvider(response_delay=0.05)\\n\",\n    \"        messages = [Message(role=\\\"user\\\", content=\\\"Stream a response about async programming\\\")]\\n\",\n    \"        \\n\",\n    \"        full_response = \\\"\\\"\\n\",\n    \"        chunk_count = 0\\n\",\n    \"        \\n\",\n    \"        async for chunk in provider.stream_completion(\\\"gpt-4\\\", messages):\\n\",\n    \"            full_response += chunk.content\\n\",\n    \"            chunk_count += 1\\n\",\n    \"            \\n\",\n    \"            if chunk.is_final:\\n\",\n    \"                print(f\\\"  📡 Streamed {chunk_count} chunks: '{full_response}'\\\")\\n\",\n    \"        \\n\",\n    \"        print(f\\\"\\\\n🎯 Production System Features Demonstrated:\\\")\\n\",\n    \"        print(f\\\"  ✅ Concurrent request processing\\\")\\n\",\n    \"        print(f\\\"  ✅ Priority-based scheduling\\\")\\n\",\n    \"        print(f\\\"  ✅ Rate limiting and resource control\\\")\\n\",\n    \"        print(f\\\"  ✅ Connection pooling\\\")\\n\",\n    \"        print(f\\\"  ✅ Timeout handling\\\")\\n\",\n    \"        print(f\\\"  ✅ Comprehensive monitoring\\\")\\n\",\n    \"        print(f\\\"  ✅ Graceful error handling\\\")\\n\",\n    \"        print(f\\\"  ✅ Streaming capabilities\\\")\\n\",\n    \"        \\n\",\n    \"    finally:\\n\",\n    \"        await ai_system.stop()\\n\",\n    \"\\n\",\n    \"# Run the production system demonstration\\n\",\n    \"await demonstrate_production_system()\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🏆 Async Patterns Mastery Complete!\\\")\\n\",\n    \"print(f\\\"\\\\n💡 Key Async Benefits for AI Systems:\\\")\\n\",\n    \"print(f\\\"  ⚡ 10-100x performance improvement for I/O-bound operations\\\")\\n\",\n    \"print(f\\\"  🔄 Real-time streaming and user feedback\\\")\\n\",\n    \"print(f\\\"  📈 Scales to thousands of concurrent requests\\\")\\n\",\n    \"print(f\\\"  💾 Efficient resource utilization\\\")\\n\",\n    \"print(f\\\"  🛡️  Built-in error handling and timeout management\\\")\\n\",\n    \"print(f\\\"  📊 Comprehensive monitoring and metrics\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Summary: Async Patterns Mastery\\n\",\n    \"\\n\",\n    \"**🎯 Key Takeaways:**\\n\",\n    \"\\n\",\n    \"1. **Streaming** enables real-time user feedback and memory efficiency\\n\",\n    \"2. **Rate Limiting** prevents resource exhaustion and ensures fair usage\\n\",\n    \"3. **Connection Pooling** reuses expensive resources efficiently\\n\",\n    \"4. **Concurrent Processing** dramatically improves throughput\\n\",\n    \"5. **Batch Processing** optimizes resource usage for bulk operations\\n\",\n    \"6. **Async Context Managers** ensure proper resource cleanup\\n\",\n    \"7. **Progress Tracking** provides visibility into long-running operations\\n\",\n    \"\\n\",\n    \"**🚀 Production Considerations:**\\n\",\n    \"- Always use timeouts to prevent hanging operations\\n\",\n    \"- Implement proper error handling and retry logic\\n\",\n    \"- Monitor resource usage and performance metrics\\n\",\n    \"- Use priority queues for important requests\\n\",\n    \"- Plan for graceful shutdown and cleanup\\n\",\n    \"\\n\",\n    \"**💡 Remember:** Async programming is essential for building scalable AI systems that can handle real-world load and provide responsive user experiences!\"\n   ]\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"Python 3\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.11.0\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 4\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":113147,"cache_read_input_tokens":0,"output_tokens":25883}},"requestId":"req_vrtx_011CRhS6YnSYL32R2dyM71Md","type":"assistant","uuid":"8fad791d-0b7e-4004-a8bd-65dc114d2b48","timestamp":"2025-08-01T18:11:43.069Z"}
{"parentUuid":"8fad791d-0b7e-4004-a8bd-65dc114d2b48","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_vrtx_01Sr2ysBL8ApSp79gBgJR1My","type":"tool_result","content":"File created successfully at: /home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/notebooks/02_async_patterns_learning.ipynb"}]},"uuid":"10310621-d474-403e-ae1d-d2cded1290b0","timestamp":"2025-08-01T18:11:43.101Z","toolUseResult":{"type":"create","filePath":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/notebooks/02_async_patterns_learning.ipynb","content":"{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Async Patterns for High-Performance AI Systems\\n\",\n    \"\\n\",\n    \"This notebook teaches advanced asyncio patterns for building high-performance AI systems with concurrent processing, streaming, and resource management. You'll learn:\\n\",\n    \"\\n\",\n    \"1. **Streaming Patterns** - Real-time AI response streaming\\n\",\n    \"2. **Rate Limiting** - Controlling API usage and preventing overload\\n\",\n    \"3. **Connection Pooling** - Efficient resource management\\n\",\n    \"4. **Concurrent Processing** - Parallel AI inference\\n\",\n    \"5. **Batch Processing** - Optimizing throughput\\n\",\n    \"6. **Async Context Managers** - Proper resource cleanup\\n\",\n    \"7. **Async Generators** - Memory-efficient data processing\\n\",\n    \"8. **Error Handling** - Robust async error management\\n\",\n    \"\\n\",\n    \"## Prerequisites\\n\",\n    \"```bash\\n\",\n    \"pip install rich asyncio\\n\",\n    \"```\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 1: Async Fundamentals and Setup\\n\",\n    \"\\n\",\n    \"**First Principle**: Async programming enables concurrent execution without blocking, essential for I/O-bound AI applications.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `async def` for coroutines, `await` for async operations, and `asyncio.create_task()` for concurrent execution.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Essential imports for async programming\\n\",\n    \"import asyncio\\n\",\n    \"from typing import AsyncGenerator, AsyncIterator, Callable, Any, Optional, List, Dict\\n\",\n    \"from dataclasses import dataclass\\n\",\n    \"from contextlib import asynccontextmanager\\n\",\n    \"import time\\n\",\n    \"from rich.console import Console\\n\",\n    \"from rich.panel import Panel\\n\",\n    \"from rich.table import Table\\n\",\n    \"\\n\",\n    \"console = Console()\\n\",\n    \"\\n\",\n    \"# Basic data structures for AI processing\\n\",\n    \"@dataclass\\n\",\n    \"class StreamingChunk:\\n\",\n    \"    \\\"\\\"\\\"Represents a chunk of streaming data.\\\"\\\"\\\"\\n\",\n    \"    content: str\\n\",\n    \"    chunk_id: int\\n\",\n    \"    is_final: bool\\n\",\n    \"    metadata: Dict[str, Any] = None\\n\",\n    \"    \\n\",\n    \"    def __post_init__(self):\\n\",\n    \"        if self.metadata is None:\\n\",\n    \"            self.metadata = {}\\n\",\n    \"\\n\",\n    \"@dataclass\\n\",\n    \"class Message:\\n\",\n    \"    \\\"\\\"\\\"Chat message structure.\\\"\\\"\\\"\\n\",\n    \"    role: str\\n\",\n    \"    content: str\\n\",\n    \"    timestamp: float = None\\n\",\n    \"    \\n\",\n    \"    def __post_init__(self):\\n\",\n    \"        if self.timestamp is None:\\n\",\n    \"            self.timestamp = time.time()\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"⚡ Async Programming Fundamentals\\\", style=\\\"bold blue\\\"))\\n\",\n    \"\\n\",\n    \"print(\\\"\\\"\\\"\\n\",\n    \"🔑 Key Async Concepts:\\n\",\n    \"\\n\",\n    \"1. **Coroutines**: Functions defined with 'async def'\\n\",\n    \"2. **Awaitable**: Objects that can be used with 'await'\\n\",\n    \"3. **Event Loop**: Manages and executes async operations\\n\",\n    \"4. **Tasks**: Concurrent execution of coroutines\\n\",\n    \"5. **Futures**: Placeholders for future results\\n\",\n    \"\\n\",\n    \"🎯 Benefits for AI Systems:\\n\",\n    \"• Handle multiple API calls concurrently\\n\",\n    \"• Stream responses in real-time\\n\",\n    \"• Manage resources efficiently\\n\",\n    \"• Scale to thousands of connections\\n\",\n    \"• Non-blocking I/O operations\\n\",\n    \"\\\"\\\"\\\")\\n\",\n    \"\\n\",\n    \"# Simple async demonstration\\n\",\n    \"async def simple_async_demo():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate basic async concepts.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    async def fetch_data(source: str, delay: float) -> str:\\n\",\n    \"        \\\"\\\"\\\"Simulate fetching data from different sources.\\\"\\\"\\\"\\n\",\n    \"        print(f\\\"🔄 Starting to fetch from {source}...\\\")\\n\",\n    \"        await asyncio.sleep(delay)  # Simulate I/O delay\\n\",\n    \"        result = f\\\"Data from {source}\\\"\\n\",\n    \"        print(f\\\"✅ Finished fetching from {source}\\\")\\n\",\n    \"        return result\\n\",\n    \"    \\n\",\n    \"    # Sequential execution (blocking)\\n\",\n    \"    print(\\\"📊 Sequential execution:\\\")\\n\",\n    \"    start_time = time.time()\\n\",\n    \"    \\n\",\n    \"    result1 = await fetch_data(\\\"API-1\\\", 0.5)\\n\",\n    \"    result2 = await fetch_data(\\\"API-2\\\", 0.3)\\n\",\n    \"    result3 = await fetch_data(\\\"API-3\\\", 0.4)\\n\",\n    \"    \\n\",\n    \"    sequential_time = time.time() - start_time\\n\",\n    \"    print(f\\\"Sequential results: {[result1, result2, result3]}\\\")\\n\",\n    \"    print(f\\\"Sequential time: {sequential_time:.2f}s\\\")\\n\",\n    \"    \\n\",\n    \"    # Concurrent execution (non-blocking)\\n\",\n    \"    print(f\\\"\\\\n🚀 Concurrent execution:\\\")\\n\",\n    \"    start_time = time.time()\\n\",\n    \"    \\n\",\n    \"    # Create tasks for concurrent execution\\n\",\n    \"    task1 = asyncio.create_task(fetch_data(\\\"API-1\\\", 0.5))\\n\",\n    \"    task2 = asyncio.create_task(fetch_data(\\\"API-2\\\", 0.3))\\n\",\n    \"    task3 = asyncio.create_task(fetch_data(\\\"API-3\\\", 0.4))\\n\",\n    \"    \\n\",\n    \"    # Wait for all tasks to complete\\n\",\n    \"    concurrent_results = await asyncio.gather(task1, task2, task3)\\n\",\n    \"    \\n\",\n    \"    concurrent_time = time.time() - start_time\\n\",\n    \"    print(f\\\"Concurrent results: {concurrent_results}\\\")\\n\",\n    \"    print(f\\\"Concurrent time: {concurrent_time:.2f}s\\\")\\n\",\n    \"    \\n\",\n    \"    speedup = sequential_time / concurrent_time\\n\",\n    \"    print(f\\\"\\\\n⚡ Speedup: {speedup:.1f}x faster with async!\\\")\\n\",\n    \"\\n\",\n    \"# Run the demo\\n\",\n    \"await simple_async_demo()\\n\",\n    \"\\n\",\n    \"print(\\\"\\\\n💡 Key Takeaway: Async shines with I/O-bound operations!\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 2: Streaming Patterns for Real-Time AI\\n\",\n    \"\\n\",\n    \"**First Principle**: Streaming enables real-time user feedback and better resource utilization in AI applications.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `async def` with `yield` to create async generators for streaming data.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class StreamingAIProvider:\\n\",\n    \"    \\\"\\\"\\\"AI provider that supports streaming responses.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, response_delay: float = 0.1):\\n\",\n    \"        self.response_delay = response_delay\\n\",\n    \"        self.call_count = 0\\n\",\n    \"    \\n\",\n    \"    async def stream_completion(\\n\",\n    \"        self, \\n\",\n    \"        model_id: str, \\n\",\n    \"        messages: List[Message]\\n\",\n    \"    ) -> AsyncGenerator[StreamingChunk, None]:\\n\",\n    \"        \\\"\\\"\\\"Stream chat completion chunks.\\\"\\\"\\\"\\n\",\n    \"        self.call_count += 1\\n\",\n    \"        \\n\",\n    \"        # Simulate streaming response\\n\",\n    \"        response_text = f\\\"This is a streaming response to: {messages[-1].content}\\\"\\n\",\n    \"        words = response_text.split()\\n\",\n    \"        \\n\",\n    \"        for i, word in enumerate(words):\\n\",\n    \"            await asyncio.sleep(self.response_delay)\\n\",\n    \"            \\n\",\n    \"            chunk = StreamingChunk(\\n\",\n    \"                content=word + (\\\" \\\" if i < len(words) - 1 else \\\"\\\"),\\n\",\n    \"                chunk_id=i,\\n\",\n    \"                is_final=i == len(words) - 1,\\n\",\n    \"                metadata={\\n\",\n    \"                    \\\"model\\\": model_id,\\n\",\n    \"                    \\\"total_chunks\\\": len(words),\\n\",\n    \"                    \\\"call_id\\\": self.call_count\\n\",\n    \"                }\\n\",\n    \"            )\\n\",\n    \"            \\n\",\n    \"            yield chunk\\n\",\n    \"    \\n\",\n    \"    async def stream_multiple_responses(\\n\",\n    \"        self,\\n\",\n    \"        queries: List[str]\\n\",\n    \"    ) -> AsyncGenerator[Dict[str, Any], None]:\\n\",\n    \"        \\\"\\\"\\\"Stream responses for multiple queries concurrently.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        async def process_query(query_id: int, query: str):\\n\",\n    \"            \\\"\\\"\\\"Process a single query and yield results.\\\"\\\"\\\"\\n\",\n    \"            messages = [Message(role=\\\"user\\\", content=query)]\\n\",\n    \"            \\n\",\n    \"            async for chunk in self.stream_completion(\\\"gpt-4\\\", messages):\\n\",\n    \"                yield {\\n\",\n    \"                    \\\"query_id\\\": query_id,\\n\",\n    \"                    \\\"query\\\": query,\\n\",\n    \"                    \\\"chunk\\\": chunk\\n\",\n    \"                }\\n\",\n    \"        \\n\",\n    \"        # Create tasks for all queries\\n\",\n    \"        tasks = [\\n\",\n    \"            process_query(i, query) \\n\",\n    \"            for i, query in enumerate(queries)\\n\",\n    \"        ]\\n\",\n    \"        \\n\",\n    \"        # Use async generators concurrently\\n\",\n    \"        async def merge_streams():\\n\",\n    \"            \\\"\\\"\\\"Merge multiple async generators.\\\"\\\"\\\"\\n\",\n    \"            active_tasks = [task.__aiter__() for task in tasks]\\n\",\n    \"            \\n\",\n    \"            while active_tasks:\\n\",\n    \"                # Try to get next item from each active stream\\n\",\n    \"                for i, stream in enumerate(active_tasks[:]):\\n\",\n    \"                    try:\\n\",\n    \"                        result = await stream.__anext__()\\n\",\n    \"                        yield result\\n\",\n    \"                    except StopAsyncIteration:\\n\",\n    \"                        active_tasks.remove(stream)\\n\",\n    \"                \\n\",\n    \"                # Small delay to prevent tight loop\\n\",\n    \"                if active_tasks:\\n\",\n    \"                    await asyncio.sleep(0.01)\\n\",\n    \"        \\n\",\n    \"        async for result in merge_streams():\\n\",\n    \"            yield result\\n\",\n    \"\\n\",\n    \"async def demonstrate_streaming():\\n\",\n    \"    \\\"\\\"\\\"Show streaming patterns.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    console.print(Panel(\\\"🌊 Streaming Patterns\\\", style=\\\"bold blue\\\"))\\n\",\n    \"    \\n\",\n    \"    provider = StreamingAIProvider(response_delay=0.15)\\n\",\n    \"    \\n\",\n    \"    print(\\\"📡 Single streaming completion:\\\")\\n\",\n    \"    \\n\",\n    \"    messages = [Message(role=\\\"user\\\", content=\\\"Tell me about async programming\\\")]\\n\",\n    \"    \\n\",\n    \"    # Collect streaming chunks\\n\",\n    \"    chunks = []\\n\",\n    \"    full_response = \\\"\\\"\\n\",\n    \"    \\n\",\n    \"    async for chunk in provider.stream_completion(\\\"gpt-4\\\", messages):\\n\",\n    \"        chunks.append(chunk)\\n\",\n    \"        full_response += chunk.content\\n\",\n    \"        \\n\",\n    \"        # Show real-time progress\\n\",\n    \"        if chunk.is_final:\\n\",\n    \"            print(f\\\"  Chunk {chunk.chunk_id}: '{chunk.content.strip()}' [FINAL]\\\")\\n\",\n    \"        else:\\n\",\n    \"            print(f\\\"  Chunk {chunk.chunk_id}: '{chunk.content.strip()}'\\\")\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n📊 Streaming Summary:\\\")\\n\",\n    \"    print(f\\\"  Total chunks: {len(chunks)}\\\")\\n\",\n    \"    print(f\\\"  Full response: {full_response}\\\")\\n\",\n    \"    print(f\\\"  Final chunk metadata: {chunks[-1].metadata}\\\")\\n\",\n    \"    \\n\",\n    \"    # Multiple concurrent streams\\n\",\n    \"    print(f\\\"\\\\n🔀 Multiple concurrent streams:\\\")\\n\",\n    \"    \\n\",\n    \"    queries = [\\n\",\n    \"        \\\"What is machine learning?\\\",\\n\",\n    \"        \\\"Explain neural networks\\\",\\n\",\n    \"        \\\"How does AI work?\\\"\\n\",\n    \"    ]\\n\",\n    \"    \\n\",\n    \"    query_responses = {i: \\\"\\\" for i in range(len(queries))}\\n\",\n    \"    \\n\",\n    \"    async for result in provider.stream_multiple_responses(queries):\\n\",\n    \"        query_id = result[\\\"query_id\\\"]\\n\",\n    \"        chunk = result[\\\"chunk\\\"]\\n\",\n    \"        query_responses[query_id] += chunk.content\\n\",\n    \"        \\n\",\n    \"        status = \\\"[FINAL]\\\" if chunk.is_final else \\\"\\\"\\n\",\n    \"        print(f\\\"  Query {query_id}: chunk {chunk.chunk_id} '{chunk.content.strip()}' {status}\\\")\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n📋 Final responses:\\\")\\n\",\n    \"    for i, response in query_responses.items():\\n\",\n    \"        print(f\\\"  Query {i}: {response}\\\")\\n\",\n    \"\\n\",\n    \"# Real-time streaming with buffer management\\n\",\n    \"class StreamBuffer:\\n\",\n    \"    \\\"\\\"\\\"Buffer for managing streaming data.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, max_size: int = 100):\\n\",\n    \"        self.buffer = []\\n\",\n    \"        self.max_size = max_size\\n\",\n    \"        self.overflow_count = 0\\n\",\n    \"    \\n\",\n    \"    async def add_chunk(self, chunk: StreamingChunk) -> bool:\\n\",\n    \"        \\\"\\\"\\\"Add chunk to buffer, return True if successful.\\\"\\\"\\\"\\n\",\n    \"        if len(self.buffer) >= self.max_size:\\n\",\n    \"            self.overflow_count += 1\\n\",\n    \"            return False\\n\",\n    \"        \\n\",\n    \"        self.buffer.append(chunk)\\n\",\n    \"        return True\\n\",\n    \"    \\n\",\n    \"    async def get_chunks(self, count: int = None) -> List[StreamingChunk]:\\n\",\n    \"        \\\"\\\"\\\"Get chunks from buffer.\\\"\\\"\\\"\\n\",\n    \"        if count is None:\\n\",\n    \"            chunks = self.buffer.copy()\\n\",\n    \"            self.buffer.clear()\\n\",\n    \"        else:\\n\",\n    \"            chunks = self.buffer[:count]\\n\",\n    \"            self.buffer = self.buffer[count:]\\n\",\n    \"        \\n\",\n    \"        return chunks\\n\",\n    \"    \\n\",\n    \"    def get_stats(self) -> Dict[str, int]:\\n\",\n    \"        return {\\n\",\n    \"            \\\"buffer_size\\\": len(self.buffer),\\n\",\n    \"            \\\"max_size\\\": self.max_size,\\n\",\n    \"            \\\"overflow_count\\\": self.overflow_count\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"async def demonstrate_buffered_streaming():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate streaming with buffer management.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n💾 Buffered streaming demonstration:\\\")\\n\",\n    \"    \\n\",\n    \"    provider = StreamingAIProvider(response_delay=0.05)\\n\",\n    \"    buffer = StreamBuffer(max_size=5)\\n\",\n    \"    \\n\",\n    \"    messages = [Message(role=\\\"user\\\", content=\\\"Generate a long response about AI benefits\\\")]\\n\",\n    \"    \\n\",\n    \"    # Producer: Add chunks to buffer\\n\",\n    \"    async def producer():\\n\",\n    \"        async for chunk in provider.stream_completion(\\\"gpt-4\\\", messages):\\n\",\n    \"            success = await buffer.add_chunk(chunk)\\n\",\n    \"            if not success:\\n\",\n    \"                print(f\\\"⚠️  Buffer overflow! Chunk {chunk.chunk_id} dropped\\\")\\n\",\n    \"    \\n\",\n    \"    # Consumer: Process chunks from buffer\\n\",\n    \"    async def consumer():\\n\",\n    \"        processed_count = 0\\n\",\n    \"        while True:\\n\",\n    \"            chunks = await buffer.get_chunks(2)  # Process 2 at a time\\n\",\n    \"            if not chunks:\\n\",\n    \"                await asyncio.sleep(0.1)  # Wait for more data\\n\",\n    \"                continue\\n\",\n    \"            \\n\",\n    \"            for chunk in chunks:\\n\",\n    \"                processed_count += 1\\n\",\n    \"                print(f\\\"🔧 Processed chunk {chunk.chunk_id}: '{chunk.content.strip()}'\\\")\\n\",\n    \"                \\n\",\n    \"                if chunk.is_final:\\n\",\n    \"                    print(f\\\"✅ Processing complete! Total chunks: {processed_count}\\\")\\n\",\n    \"                    return\\n\",\n    \"            \\n\",\n    \"            await asyncio.sleep(0.1)  # Simulate processing time\\n\",\n    \"    \\n\",\n    \"    # Run producer and consumer concurrently\\n\",\n    \"    await asyncio.gather(producer(), consumer())\\n\",\n    \"    \\n\",\n    \"    stats = buffer.get_stats()\\n\",\n    \"    print(f\\\"📊 Buffer stats: {stats}\\\")\\n\",\n    \"\\n\",\n    \"# Run streaming demonstrations\\n\",\n    \"await demonstrate_streaming()\\n\",\n    \"await demonstrate_buffered_streaming()\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Streaming Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Real-time user feedback\\\")\\n\",\n    \"print(f\\\"  ✅ Lower perceived latency\\\")\\n\",\n    \"print(f\\\"  ✅ Memory efficiency for large responses\\\")\\n\",\n    \"print(f\\\"  ✅ Better resource utilization\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 3: Rate Limiting and Resource Control\\n\",\n    \"\\n\",\n    \"**First Principle**: Rate limiting prevents resource exhaustion and ensures fair usage across multiple clients.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `asyncio.Semaphore` and `asyncio.Lock` for controlling concurrent access to resources.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class AsyncRateLimiter:\\n\",\n    \"    \\\"\\\"\\\"Async rate limiter for API calls.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, max_calls: int, time_window: float):\\n\",\n    \"        self.max_calls = max_calls\\n\",\n    \"        self.time_window = time_window\\n\",\n    \"        self.calls: List[float] = []\\n\",\n    \"        self._lock = asyncio.Lock()\\n\",\n    \"    \\n\",\n    \"    async def acquire(self) -> None:\\n\",\n    \"        \\\"\\\"\\\"Acquire permission to make a call.\\\"\\\"\\\"\\n\",\n    \"        async with self._lock:\\n\",\n    \"            now = time.time()\\n\",\n    \"            \\n\",\n    \"            # Remove old calls outside the window\\n\",\n    \"            self.calls = [call_time for call_time in self.calls \\n\",\n    \"                         if now - call_time < self.time_window]\\n\",\n    \"            \\n\",\n    \"            # If we're at the limit, wait\\n\",\n    \"            if len(self.calls) >= self.max_calls:\\n\",\n    \"                oldest_call = min(self.calls)\\n\",\n    \"                wait_time = self.time_window - (now - oldest_call)\\n\",\n    \"                if wait_time > 0:\\n\",\n    \"                    print(f\\\"🚦 Rate limit reached, waiting {wait_time:.2f}s\\\")\\n\",\n    \"                    await asyncio.sleep(wait_time)\\n\",\n    \"                    # Recursive call to try again\\n\",\n    \"                    return await self.acquire()\\n\",\n    \"            \\n\",\n    \"            # Record this call\\n\",\n    \"            self.calls.append(now)\\n\",\n    \"    \\n\",\n    \"    def get_stats(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get rate limiter statistics.\\\"\\\"\\\"\\n\",\n    \"        now = time.time()\\n\",\n    \"        recent_calls = [call for call in self.calls if now - call < self.time_window]\\n\",\n    \"        return {\\n\",\n    \"            \\\"current_calls\\\": len(recent_calls),\\n\",\n    \"            \\\"max_calls\\\": self.max_calls,\\n\",\n    \"            \\\"time_window\\\": self.time_window,\\n\",\n    \"            \\\"utilization\\\": len(recent_calls) / self.max_calls\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"class TokenBucketRateLimiter:\\n\",\n    \"    \\\"\\\"\\\"Token bucket rate limiter for smooth rate limiting.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, tokens_per_second: float, bucket_size: int):\\n\",\n    \"        self.tokens_per_second = tokens_per_second\\n\",\n    \"        self.bucket_size = bucket_size\\n\",\n    \"        self.tokens = bucket_size\\n\",\n    \"        self.last_refill = time.time()\\n\",\n    \"        self._lock = asyncio.Lock()\\n\",\n    \"    \\n\",\n    \"    async def acquire(self, tokens_needed: int = 1) -> bool:\\n\",\n    \"        \\\"\\\"\\\"Try to acquire tokens from the bucket.\\\"\\\"\\\"\\n\",\n    \"        async with self._lock:\\n\",\n    \"            now = time.time()\\n\",\n    \"            \\n\",\n    \"            # Refill tokens based on time passed\\n\",\n    \"            time_passed = now - self.last_refill\\n\",\n    \"            tokens_to_add = time_passed * self.tokens_per_second\\n\",\n    \"            self.tokens = min(self.bucket_size, self.tokens + tokens_to_add)\\n\",\n    \"            self.last_refill = now\\n\",\n    \"            \\n\",\n    \"            # Check if we have enough tokens\\n\",\n    \"            if self.tokens >= tokens_needed:\\n\",\n    \"                self.tokens -= tokens_needed\\n\",\n    \"                return True\\n\",\n    \"            else:\\n\",\n    \"                # Calculate wait time for next token\\n\",\n    \"                tokens_deficit = tokens_needed - self.tokens\\n\",\n    \"                wait_time = tokens_deficit / self.tokens_per_second\\n\",\n    \"                print(f\\\"🪣 Token bucket empty, waiting {wait_time:.2f}s\\\")\\n\",\n    \"                await asyncio.sleep(wait_time)\\n\",\n    \"                return await self.acquire(tokens_needed)\\n\",\n    \"    \\n\",\n    \"    def get_stats(self) -> Dict[str, Any]:\\n\",\n    \"        return {\\n\",\n    \"            \\\"tokens\\\": self.tokens,\\n\",\n    \"            \\\"bucket_size\\\": self.bucket_size,\\n\",\n    \"            \\\"tokens_per_second\\\": self.tokens_per_second,\\n\",\n    \"            \\\"fill_percentage\\\": self.tokens / self.bucket_size * 100\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"async def demonstrate_rate_limiting():\\n\",\n    \"    \\\"\\\"\\\"Show rate limiting patterns.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    console.print(Panel(\\\"🚦 Rate Limiting\\\", style=\\\"bold green\\\"))\\n\",\n    \"    \\n\",\n    \"    # Test sliding window rate limiter\\n\",\n    \"    print(\\\"📊 Sliding window rate limiter (5 calls per 2 seconds):\\\")\\n\",\n    \"    \\n\",\n    \"    rate_limiter = AsyncRateLimiter(max_calls=5, time_window=2.0)\\n\",\n    \"    \\n\",\n    \"    async def make_api_call(call_id: int) -> str:\\n\",\n    \"        \\\"\\\"\\\"Simulate API call with rate limiting.\\\"\\\"\\\"\\n\",\n    \"        await rate_limiter.acquire()\\n\",\n    \"        # Simulate API processing time\\n\",\n    \"        await asyncio.sleep(0.1)\\n\",\n    \"        return f\\\"API call {call_id} completed\\\"\\n\",\n    \"    \\n\",\n    \"    start_time = time.time()\\n\",\n    \"    \\n\",\n    \"    # Create 10 rapid calls\\n\",\n    \"    tasks = [make_api_call(i) for i in range(10)]\\n\",\n    \"    \\n\",\n    \"    # Execute with progress tracking\\n\",\n    \"    results = []\\n\",\n    \"    for i, task in enumerate(asyncio.as_completed(tasks)):\\n\",\n    \"        result = await task\\n\",\n    \"        elapsed = time.time() - start_time\\n\",\n    \"        stats = rate_limiter.get_stats()\\n\",\n    \"        print(f\\\"  {elapsed:.2f}s: {result} (utilization: {stats['utilization']:.1%})\\\")\\n\",\n    \"        results.append(result)\\n\",\n    \"    \\n\",\n    \"    total_time = time.time() - start_time\\n\",\n    \"    print(f\\\"\\\\n📈 Rate limiting summary:\\\")\\n\",\n    \"    print(f\\\"  Total time: {total_time:.2f}s\\\")\\n\",\n    \"    print(f\\\"  Rate limiter stats: {rate_limiter.get_stats()}\\\")\\n\",\n    \"    \\n\",\n    \"    # Test token bucket rate limiter\\n\",\n    \"    print(f\\\"\\\\n🪣 Token bucket rate limiter (3 tokens/sec, bucket size 5):\\\")\\n\",\n    \"    \\n\",\n    \"    token_limiter = TokenBucketRateLimiter(tokens_per_second=3.0, bucket_size=5)\\n\",\n    \"    \\n\",\n    \"    async def make_weighted_call(call_id: int, tokens_needed: int = 1) -> str:\\n\",\n    \"        \\\"\\\"\\\"API call that may need multiple tokens.\\\"\\\"\\\"\\n\",\n    \"        await token_limiter.acquire(tokens_needed)\\n\",\n    \"        await asyncio.sleep(0.05)  # Simulate processing\\n\",\n    \"        return f\\\"Weighted call {call_id} (cost: {tokens_needed} tokens)\\\"\\n\",\n    \"    \\n\",\n    \"    # Different cost operations\\n\",\n    \"    operations = [\\n\",\n    \"        (1, 1),  # Light operation\\n\",\n    \"        (2, 2),  # Medium operation\\n\",\n    \"        (3, 1),  # Light operation\\n\",\n    \"        (4, 3),  # Heavy operation\\n\",\n    \"        (5, 1),  # Light operation\\n\",\n    \"        (6, 2),  # Medium operation\\n\",\n    \"    ]\\n\",\n    \"    \\n\",\n    \"    start_time = time.time()\\n\",\n    \"    \\n\",\n    \"    for call_id, tokens in operations:\\n\",\n    \"        result = await make_weighted_call(call_id, tokens)\\n\",\n    \"        elapsed = time.time() - start_time\\n\",\n    \"        stats = token_limiter.get_stats()\\n\",\n    \"        print(f\\\"  {elapsed:.2f}s: {result} (tokens left: {stats['tokens']:.1f})\\\")\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n📊 Final token bucket stats: {token_limiter.get_stats()}\\\")\\n\",\n    \"\\n\",\n    \"# Advanced rate limiting with priority queues\\n\",\n    \"class PriorityRateLimiter:\\n\",\n    \"    \\\"\\\"\\\"Rate limiter with priority queue support.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, max_calls: int, time_window: float):\\n\",\n    \"        self.base_limiter = AsyncRateLimiter(max_calls, time_window)\\n\",\n    \"        self.priority_queues = {\\n\",\n    \"            \\\"high\\\": asyncio.Queue(),\\n\",\n    \"            \\\"medium\\\": asyncio.Queue(),\\n\",\n    \"            \\\"low\\\": asyncio.Queue()\\n\",\n    \"        }\\n\",\n    \"        self._processing = False\\n\",\n    \"    \\n\",\n    \"    async def acquire(self, priority: str = \\\"medium\\\") -> None:\\n\",\n    \"        \\\"\\\"\\\"Acquire with priority.\\\"\\\"\\\"\\n\",\n    \"        if priority not in self.priority_queues:\\n\",\n    \"            priority = \\\"medium\\\"\\n\",\n    \"        \\n\",\n    \"        # Add request to appropriate queue\\n\",\n    \"        future = asyncio.Future()\\n\",\n    \"        await self.priority_queues[priority].put(future)\\n\",\n    \"        \\n\",\n    \"        # Start processing if not already running\\n\",\n    \"        if not self._processing:\\n\",\n    \"            asyncio.create_task(self._process_queues())\\n\",\n    \"        \\n\",\n    \"        # Wait for our turn\\n\",\n    \"        await future\\n\",\n    \"    \\n\",\n    \"    async def _process_queues(self):\\n\",\n    \"        \\\"\\\"\\\"Process requests in priority order.\\\"\\\"\\\"\\n\",\n    \"        self._processing = True\\n\",\n    \"        \\n\",\n    \"        try:\\n\",\n    \"            while True:\\n\",\n    \"                # Check queues in priority order\\n\",\n    \"                future = None\\n\",\n    \"                \\n\",\n    \"                for priority in [\\\"high\\\", \\\"medium\\\", \\\"low\\\"]:\\n\",\n    \"                    queue = self.priority_queues[priority]\\n\",\n    \"                    if not queue.empty():\\n\",\n    \"                        future = await queue.get()\\n\",\n    \"                        break\\n\",\n    \"                \\n\",\n    \"                if future is None:\\n\",\n    \"                    # No more requests\\n\",\n    \"                    break\\n\",\n    \"                \\n\",\n    \"                # Acquire from base rate limiter\\n\",\n    \"                await self.base_limiter.acquire()\\n\",\n    \"                \\n\",\n    \"                # Signal that request can proceed\\n\",\n    \"                if not future.cancelled():\\n\",\n    \"                    future.set_result(None)\\n\",\n    \"        \\n\",\n    \"        finally:\\n\",\n    \"            self._processing = False\\n\",\n    \"\\n\",\n    \"async def demonstrate_priority_rate_limiting():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate priority-based rate limiting.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n🎯 Priority rate limiting:\\\")\\n\",\n    \"    \\n\",\n    \"    priority_limiter = PriorityRateLimiter(max_calls=3, time_window=1.0)\\n\",\n    \"    \\n\",\n    \"    async def priority_task(task_id: int, priority: str, delay: float = 0.1):\\n\",\n    \"        \\\"\\\"\\\"Task with specific priority.\\\"\\\"\\\"\\n\",\n    \"        print(f\\\"🔄 Task {task_id} ({priority}) waiting...\\\")\\n\",\n    \"        await priority_limiter.acquire(priority)\\n\",\n    \"        print(f\\\"✅ Task {task_id} ({priority}) executing\\\")\\n\",\n    \"        await asyncio.sleep(delay)\\n\",\n    \"        return f\\\"Task {task_id} ({priority}) completed\\\"\\n\",\n    \"    \\n\",\n    \"    # Submit tasks with different priorities\\n\",\n    \"    tasks = [\\n\",\n    \"        priority_task(1, \\\"low\\\"),\\n\",\n    \"        priority_task(2, \\\"high\\\"),\\n\",\n    \"        priority_task(3, \\\"medium\\\"),\\n\",\n    \"        priority_task(4, \\\"low\\\"),\\n\",\n    \"        priority_task(5, \\\"high\\\"),\\n\",\n    \"        priority_task(6, \\\"medium\\\"),\\n\",\n    \"    ]\\n\",\n    \"    \\n\",\n    \"    results = await asyncio.gather(*tasks)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n📋 Execution order shows priority handling:\\\")\\n\",\n    \"    for result in results:\\n\",\n    \"        print(f\\\"  {result}\\\")\\n\",\n    \"\\n\",\n    \"# Run rate limiting demonstrations\\n\",\n    \"await demonstrate_rate_limiting()\\n\",\n    \"await demonstrate_priority_rate_limiting()\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Rate Limiting Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Prevents API quota exhaustion\\\")\\n\",\n    \"print(f\\\"  ✅ Ensures fair resource usage\\\")\\n\",\n    \"print(f\\\"  ✅ Protects against request bursts\\\")\\n\",\n    \"print(f\\\"  ✅ Enables priority-based processing\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 4: Connection Pooling and Resource Management\\n\",\n    \"\\n\",\n    \"**First Principle**: Connection pooling reuses expensive resources like database connections and HTTP sessions.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `asyncio.Queue` for resource pools and async context managers for automatic cleanup.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class AsyncConnectionPool:\\n\",\n    \"    \\\"\\\"\\\"Connection pool for managing async resources.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, create_connection: Callable, max_size: int = 10):\\n\",\n    \"        self.create_connection = create_connection\\n\",\n    \"        self.max_size = max_size\\n\",\n    \"        self.pool: asyncio.Queue = asyncio.Queue(maxsize=max_size)\\n\",\n    \"        self.created_count = 0\\n\",\n    \"        self.active_connections = 0\\n\",\n    \"        self._lock = asyncio.Lock()\\n\",\n    \"    \\n\",\n    \"    async def get_connection(self):\\n\",\n    \"        \\\"\\\"\\\"Get a connection from the pool.\\\"\\\"\\\"\\n\",\n    \"        try:\\n\",\n    \"            # Try to get existing connection with timeout\\n\",\n    \"            connection = await asyncio.wait_for(self.pool.get(), timeout=0.1)\\n\",\n    \"            self.active_connections += 1\\n\",\n    \"            return connection\\n\",\n    \"        except asyncio.TimeoutError:\\n\",\n    \"            # Create new connection if under limit\\n\",\n    \"            async with self._lock:\\n\",\n    \"                if self.created_count < self.max_size:\\n\",\n    \"                    connection = await self.create_connection()\\n\",\n    \"                    self.created_count += 1\\n\",\n    \"                    self.active_connections += 1\\n\",\n    \"                    return connection\\n\",\n    \"            \\n\",\n    \"            # Wait for available connection\\n\",\n    \"            connection = await self.pool.get()\\n\",\n    \"            self.active_connections += 1\\n\",\n    \"            return connection\\n\",\n    \"    \\n\",\n    \"    async def return_connection(self, connection):\\n\",\n    \"        \\\"\\\"\\\"Return connection to pool.\\\"\\\"\\\"\\n\",\n    \"        self.active_connections -= 1\\n\",\n    \"        await self.pool.put(connection)\\n\",\n    \"    \\n\",\n    \"    @asynccontextmanager\\n\",\n    \"    async def connection(self):\\n\",\n    \"        \\\"\\\"\\\"Context manager for automatic connection management.\\\"\\\"\\\"\\n\",\n    \"        conn = await self.get_connection()\\n\",\n    \"        try:\\n\",\n    \"            yield conn\\n\",\n    \"        finally:\\n\",\n    \"            await self.return_connection(conn)\\n\",\n    \"    \\n\",\n    \"    def get_stats(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get pool statistics.\\\"\\\"\\\"\\n\",\n    \"        return {\\n\",\n    \"            \\\"pool_size\\\": self.pool.qsize(),\\n\",\n    \"            \\\"created_count\\\": self.created_count,\\n\",\n    \"            \\\"active_connections\\\": self.active_connections,\\n\",\n    \"            \\\"max_size\\\": self.max_size,\\n\",\n    \"            \\\"utilization\\\": self.active_connections / self.max_size\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"# Mock connection class\\n\",\n    \"class MockConnection:\\n\",\n    \"    \\\"\\\"\\\"Mock database/API connection.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, connection_id: str):\\n\",\n    \"        self.id = connection_id\\n\",\n    \"        self.created_at = time.time()\\n\",\n    \"        self.request_count = 0\\n\",\n    \"        self.is_healthy = True\\n\",\n    \"    \\n\",\n    \"    async def execute_query(self, query: str) -> str:\\n\",\n    \"        \\\"\\\"\\\"Execute a mock query.\\\"\\\"\\\"\\n\",\n    \"        if not self.is_healthy:\\n\",\n    \"            raise ConnectionError(f\\\"Connection {self.id} is unhealthy\\\")\\n\",\n    \"        \\n\",\n    \"        self.request_count += 1\\n\",\n    \"        await asyncio.sleep(0.1)  # Simulate query time\\n\",\n    \"        return f\\\"Result for '{query}' via connection {self.id}\\\"\\n\",\n    \"    \\n\",\n    \"    def get_info(self) -> Dict[str, Any]:\\n\",\n    \"        return {\\n\",\n    \"            \\\"id\\\": self.id,\\n\",\n    \"            \\\"created_at\\\": self.created_at,\\n\",\n    \"            \\\"request_count\\\": self.request_count,\\n\",\n    \"            \\\"age_seconds\\\": time.time() - self.created_at\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"async def demonstrate_connection_pooling():\\n\",\n    \"    \\\"\\\"\\\"Show connection pooling patterns.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    console.print(Panel(\\\"🏊 Connection Pooling\\\", style=\\\"bold magenta\\\"))\\n\",\n    \"    \\n\",\n    \"    async def create_mock_connection():\\n\",\n    \"        \\\"\\\"\\\"Create a mock database connection.\\\"\\\"\\\"\\n\",\n    \"        connection_id = f\\\"conn_{int(time.time() * 1000) % 10000}\\\"\\n\",\n    \"        await asyncio.sleep(0.1)  # Simulate connection setup\\n\",\n    \"        print(f\\\"🔧 Created new connection: {connection_id}\\\")\\n\",\n    \"        return MockConnection(connection_id)\\n\",\n    \"    \\n\",\n    \"    # Create connection pool\\n\",\n    \"    pool = AsyncConnectionPool(create_mock_connection, max_size=3)\\n\",\n    \"    \\n\",\n    \"    async def database_operation(operation_id: int, query: str):\\n\",\n    \"        \\\"\\\"\\\"Simulate database operation using connection pool.\\\"\\\"\\\"\\n\",\n    \"        async with pool.connection() as conn:\\n\",\n    \"            result = await conn.execute_query(query)\\n\",\n    \"            return f\\\"Operation {operation_id}: {result}\\\"\\n\",\n    \"    \\n\",\n    \"    print(\\\"📊 Running concurrent database operations:\\\")\\n\",\n    \"    \\n\",\n    \"    # Run 8 concurrent operations with pool of 3 connections\\n\",\n    \"    queries = [\\n\",\n    \"        \\\"SELECT * FROM users\\\",\\n\",\n    \"        \\\"SELECT * FROM products\\\",\\n\",\n    \"        \\\"UPDATE inventory SET count=count-1\\\",\\n\",\n    \"        \\\"INSERT INTO logs VALUES (...)\\\",\\n\",\n    \"        \\\"SELECT AVG(price) FROM products\\\",\\n\",\n    \"        \\\"DELETE FROM cache WHERE expired=true\\\",\\n\",\n    \"        \\\"SELECT * FROM orders WHERE status='pending'\\\",\\n\",\n    \"        \\\"UPDATE users SET last_login=NOW()\\\"\\n\",\n    \"    ]\\n\",\n    \"    \\n\",\n    \"    start_time = time.time()\\n\",\n    \"    \\n\",\n    \"    tasks = [database_operation(i, query) for i, query in enumerate(queries)]\\n\",\n    \"    \\n\",\n    \"    for task in asyncio.as_completed(tasks):\\n\",\n    \"        result = await task\\n\",\n    \"        elapsed = time.time() - start_time\\n\",\n    \"        stats = pool.get_stats()\\n\",\n    \"        print(f\\\"  {elapsed:.2f}s: {result[:50]}...\\\")\\n\",\n    \"        print(f\\\"    Pool: {stats['active_connections']}/{stats['max_size']} active, {stats['pool_size']} available\\\")\\n\",\n    \"    \\n\",\n    \"    final_stats = pool.get_stats()\\n\",\n    \"    print(f\\\"\\\\n📈 Final Pool Stats:\\\")\\n\",\n    \"    print(f\\\"  Created connections: {final_stats['created_count']}\\\")\\n\",\n    \"    print(f\\\"  Active connections: {final_stats['active_connections']}\\\")\\n\",\n    \"    print(f\\\"  Pool utilization: {final_stats['utilization']:.1%}\\\")\\n\",\n    \"\\n\",\n    \"# Advanced connection pool with health checking\\n\",\n    \"class HealthAwareConnectionPool(AsyncConnectionPool):\\n\",\n    \"    \\\"\\\"\\\"Connection pool with health checking.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, create_connection: Callable, max_size: int = 10, health_check_interval: float = 30.0):\\n\",\n    \"        super().__init__(create_connection, max_size)\\n\",\n    \"        self.health_check_interval = health_check_interval\\n\",\n    \"        self.unhealthy_connections = set()\\n\",\n    \"        self._health_check_task = None\\n\",\n    \"    \\n\",\n    \"    async def start_health_checks(self):\\n\",\n    \"        \\\"\\\"\\\"Start background health checking.\\\"\\\"\\\"\\n\",\n    \"        if self._health_check_task is None:\\n\",\n    \"            self._health_check_task = asyncio.create_task(self._health_check_loop())\\n\",\n    \"    \\n\",\n    \"    async def stop_health_checks(self):\\n\",\n    \"        \\\"\\\"\\\"Stop background health checking.\\\"\\\"\\\"\\n\",\n    \"        if self._health_check_task:\\n\",\n    \"            self._health_check_task.cancel()\\n\",\n    \"            try:\\n\",\n    \"                await self._health_check_task\\n\",\n    \"            except asyncio.CancelledError:\\n\",\n    \"                pass\\n\",\n    \"            self._health_check_task = None\\n\",\n    \"    \\n\",\n    \"    async def _health_check_loop(self):\\n\",\n    \"        \\\"\\\"\\\"Background health checking loop.\\\"\\\"\\\"\\n\",\n    \"        while True:\\n\",\n    \"            try:\\n\",\n    \"                await asyncio.sleep(self.health_check_interval)\\n\",\n    \"                await self._check_pool_health()\\n\",\n    \"            except asyncio.CancelledError:\\n\",\n    \"                break\\n\",\n    \"            except Exception as e:\\n\",\n    \"                print(f\\\"⚠️  Health check error: {e}\\\")\\n\",\n    \"    \\n\",\n    \"    async def _check_pool_health(self):\\n\",\n    \"        \\\"\\\"\\\"Check health of pooled connections.\\\"\\\"\\\"\\n\",\n    \"        # This is a simplified health check\\n\",\n    \"        # In practice, you'd check connections more thoroughly\\n\",\n    \"        print(f\\\"🏥 Performing health check on {self.pool.qsize()} pooled connections\\\")\\n\",\n    \"        \\n\",\n    \"        # Remove old unhealthy connections from tracking\\n\",\n    \"        self.unhealthy_connections.clear()\\n\",\n    \"    \\n\",\n    \"    async def get_connection(self):\\n\",\n    \"        \\\"\\\"\\\"Get a healthy connection from the pool.\\\"\\\"\\\"\\n\",\n    \"        connection = await super().get_connection()\\n\",\n    \"        \\n\",\n    \"        # Check if connection is healthy\\n\",\n    \"        if hasattr(connection, 'is_healthy') and not connection.is_healthy:\\n\",\n    \"            print(f\\\"🚫 Connection {connection.id} is unhealthy, creating new one\\\")\\n\",\n    \"            # Create a replacement connection\\n\",\n    \"            new_connection = await self.create_connection()\\n\",\n    \"            return new_connection\\n\",\n    \"        \\n\",\n    \"        return connection\\n\",\n    \"\\n\",\n    \"async def demonstrate_health_aware_pooling():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate health-aware connection pooling.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n🏥 Health-aware connection pooling:\\\")\\n\",\n    \"    \\n\",\n    \"    async def create_connection_with_random_health():\\n\",\n    \"        \\\"\\\"\\\"Create connection that might become unhealthy.\\\"\\\"\\\"\\n\",\n    \"        import random\\n\",\n    \"        connection = await create_mock_connection()\\n\",\n    \"        # Simulate some connections becoming unhealthy\\n\",\n    \"        connection.is_healthy = random.random() > 0.3  # 30% chance of being unhealthy\\n\",\n    \"        return connection\\n\",\n    \"    \\n\",\n    \"    health_pool = HealthAwareConnectionPool(\\n\",\n    \"        create_connection_with_random_health, \\n\",\n    \"        max_size=2, \\n\",\n    \"        health_check_interval=2.0\\n\",\n    \"    )\\n\",\n    \"    \\n\",\n    \"    # Start health checks\\n\",\n    \"    await health_pool.start_health_checks()\\n\",\n    \"    \\n\",\n    \"    try:\\n\",\n    \"        # Use the pool\\n\",\n    \"        for i in range(5):\\n\",\n    \"            async with health_pool.connection() as conn:\\n\",\n    \"                try:\\n\",\n    \"                    result = await conn.execute_query(f\\\"Query {i}\\\")\\n\",\n    \"                    print(f\\\"✅ {result[:40]}...\\\")\\n\",\n    \"                except ConnectionError as e:\\n\",\n    \"                    print(f\\\"❌ {e}\\\")\\n\",\n    \"            \\n\",\n    \"            await asyncio.sleep(0.5)\\n\",\n    \"    \\n\",\n    \"    finally:\\n\",\n    \"        # Stop health checks\\n\",\n    \"        await health_pool.stop_health_checks()\\n\",\n    \"    \\n\",\n    \"    print(f\\\"📊 Health-aware pool stats: {health_pool.get_stats()}\\\")\\n\",\n    \"\\n\",\n    \"# Resource manager with lifecycle\\n\",\n    \"@asynccontextmanager\\n\",\n    \"async def managed_ai_service(service_config: Dict[str, Any]):\\n\",\n    \"    \\\"\\\"\\\"Context manager for AI service with full lifecycle.\\\"\\\"\\\"\\n\",\n    \"    print(f\\\"🚀 Starting AI service with config: {service_config}\\\")\\n\",\n    \"    \\n\",\n    \"    # Setup phase\\n\",\n    \"    service = {\\n\",\n    \"        \\\"id\\\": f\\\"service_{int(time.time())}\\\",\\n\",\n    \"        \\\"config\\\": service_config,\\n\",\n    \"        \\\"started_at\\\": time.time(),\\n\",\n    \"        \\\"request_count\\\": 0\\n\",\n    \"    }\\n\",\n    \"    \\n\",\n    \"    try:\\n\",\n    \"        # Simulate service initialization\\n\",\n    \"        await asyncio.sleep(0.1)\\n\",\n    \"        print(f\\\"✅ AI service {service['id']} ready\\\")\\n\",\n    \"        \\n\",\n    \"        yield service\\n\",\n    \"        \\n\",\n    \"    finally:\\n\",\n    \"        # Cleanup phase\\n\",\n    \"        uptime = time.time() - service['started_at']\\n\",\n    \"        print(f\\\"🧹 Shutting down service {service['id']} (uptime: {uptime:.2f}s, requests: {service['request_count']})\\\")\\n\",\n    \"        await asyncio.sleep(0.05)  # Simulate cleanup\\n\",\n    \"\\n\",\n    \"async def demonstrate_resource_lifecycle():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate resource lifecycle management.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n🔄 Resource lifecycle management:\\\")\\n\",\n    \"    \\n\",\n    \"    config = {\\\"model\\\": \\\"gpt-4\\\", \\\"temperature\\\": 0.7, \\\"max_workers\\\": 5}\\n\",\n    \"    \\n\",\n    \"    async with managed_ai_service(config) as service:\\n\",\n    \"        print(f\\\"📝 Using service: {service['id']}\\\")\\n\",\n    \"        \\n\",\n    \"        # Simulate some work\\n\",\n    \"        for i in range(3):\\n\",\n    \"            service['request_count'] += 1\\n\",\n    \"            await asyncio.sleep(0.1)\\n\",\n    \"            print(f\\\"  Processed request {i+1}\\\")\\n\",\n    \"    \\n\",\n    \"    print(f\\\"✅ Service lifecycle completed cleanly\\\")\\n\",\n    \"\\n\",\n    \"# Run connection pooling demonstrations\\n\",\n    \"await demonstrate_connection_pooling()\\n\",\n    \"await demonstrate_health_aware_pooling()\\n\",\n    \"await demonstrate_resource_lifecycle()\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Connection Pooling Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Reuses expensive resources\\\")\\n\",\n    \"print(f\\\"  ✅ Reduces connection overhead\\\")\\n\",\n    \"print(f\\\"  ✅ Controls resource usage\\\")\\n\",\n    \"print(f\\\"  ✅ Handles resource failures gracefully\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 5: Concurrent Processing and Task Management\\n\",\n    \"\\n\",\n    \"**First Principle**: Concurrent processing enables parallel execution of independent tasks, dramatically improving throughput.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `asyncio.gather()`, `asyncio.as_completed()`, and `asyncio.Semaphore` for managing concurrent operations.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class ConcurrentInferenceEngine:\\n\",\n    \"    \\\"\\\"\\\"Engine for managing concurrent AI inference requests.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, max_concurrent: int = 5):\\n\",\n    \"        self.max_concurrent = max_concurrent\\n\",\n    \"        self.semaphore = asyncio.Semaphore(max_concurrent)\\n\",\n    \"        self.active_tasks: Dict[str, asyncio.Task] = {}\\n\",\n    \"        self.completed_tasks: List[Dict[str, Any]] = []\\n\",\n    \"        self.task_counter = 0\\n\",\n    \"    \\n\",\n    \"    async def submit_task(\\n\",\n    \"        self, \\n\",\n    \"        task_id: str, \\n\",\n    \"        coro: Callable,\\n\",\n    \"        *args, \\n\",\n    \"        **kwargs\\n\",\n    \"    ) -> str:\\n\",\n    \"        \\\"\\\"\\\"Submit a task for concurrent execution.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        async def wrapped_task():\\n\",\n    \"            async with self.semaphore:\\n\",\n    \"                start_time = time.time()\\n\",\n    \"                try:\\n\",\n    \"                    result = await coro(*args, **kwargs)\\n\",\n    \"                    end_time = time.time()\\n\",\n    \"                    \\n\",\n    \"                    self.completed_tasks.append({\\n\",\n    \"                        \\\"task_id\\\": task_id,\\n\",\n    \"                        \\\"result\\\": result,\\n\",\n    \"                        \\\"duration\\\": end_time - start_time,\\n\",\n    \"                        \\\"status\\\": \\\"success\\\",\\n\",\n    \"                        \\\"error\\\": None\\n\",\n    \"                    })\\n\",\n    \"                    \\n\",\n    \"                    return result\\n\",\n    \"                    \\n\",\n    \"                except Exception as e:\\n\",\n    \"                    end_time = time.time()\\n\",\n    \"                    \\n\",\n    \"                    self.completed_tasks.append({\\n\",\n    \"                        \\\"task_id\\\": task_id,\\n\",\n    \"                        \\\"result\\\": None,\\n\",\n    \"                        \\\"duration\\\": end_time - start_time,\\n\",\n    \"                        \\\"status\\\": \\\"error\\\",\\n\",\n    \"                        \\\"error\\\": str(e)\\n\",\n    \"                    })\\n\",\n    \"                    \\n\",\n    \"                    raise\\n\",\n    \"                finally:\\n\",\n    \"                    # Remove from active tasks\\n\",\n    \"                    if task_id in self.active_tasks:\\n\",\n    \"                        del self.active_tasks[task_id]\\n\",\n    \"        \\n\",\n    \"        # Create and store task\\n\",\n    \"        task = asyncio.create_task(wrapped_task())\\n\",\n    \"        self.active_tasks[task_id] = task\\n\",\n    \"        self.task_counter += 1\\n\",\n    \"        \\n\",\n    \"        return task_id\\n\",\n    \"    \\n\",\n    \"    async def wait_for_task(self, task_id: str) -> Any:\\n\",\n    \"        \\\"\\\"\\\"Wait for specific task to complete.\\\"\\\"\\\"\\n\",\n    \"        if task_id in self.active_tasks:\\n\",\n    \"            return await self.active_tasks[task_id]\\n\",\n    \"        \\n\",\n    \"        # Check completed tasks\\n\",\n    \"        for completed in self.completed_tasks:\\n\",\n    \"            if completed[\\\"task_id\\\"] == task_id:\\n\",\n    \"                if completed[\\\"status\\\"] == \\\"error\\\":\\n\",\n    \"                    raise Exception(completed[\\\"error\\\"])\\n\",\n    \"                return completed[\\\"result\\\"]\\n\",\n    \"        \\n\",\n    \"        raise ValueError(f\\\"Task {task_id} not found\\\")\\n\",\n    \"    \\n\",\n    \"    async def wait_for_all(self) -> List[Any]:\\n\",\n    \"        \\\"\\\"\\\"Wait for all active tasks to complete.\\\"\\\"\\\"\\n\",\n    \"        if not self.active_tasks:\\n\",\n    \"            return []\\n\",\n    \"        \\n\",\n    \"        results = await asyncio.gather(*self.active_tasks.values(), return_exceptions=True)\\n\",\n    \"        return results\\n\",\n    \"    \\n\",\n    \"    async def cancel_task(self, task_id: str) -> bool:\\n\",\n    \"        \\\"\\\"\\\"Cancel a specific task.\\\"\\\"\\\"\\n\",\n    \"        if task_id in self.active_tasks:\\n\",\n    \"            task = self.active_tasks[task_id]\\n\",\n    \"            task.cancel()\\n\",\n    \"            del self.active_tasks[task_id]\\n\",\n    \"            return True\\n\",\n    \"        return False\\n\",\n    \"    \\n\",\n    \"    def get_stats(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get engine statistics.\\\"\\\"\\\"\\n\",\n    \"        completed_success = sum(1 for t in self.completed_tasks if t[\\\"status\\\"] == \\\"success\\\")\\n\",\n    \"        completed_error = sum(1 for t in self.completed_tasks if t[\\\"status\\\"] == \\\"error\\\")\\n\",\n    \"        \\n\",\n    \"        if self.completed_tasks:\\n\",\n    \"            avg_duration = sum(t[\\\"duration\\\"] for t in self.completed_tasks) / len(self.completed_tasks)\\n\",\n    \"        else:\\n\",\n    \"            avg_duration = 0.0\\n\",\n    \"        \\n\",\n    \"        return {\\n\",\n    \"            \\\"active_tasks\\\": len(self.active_tasks),\\n\",\n    \"            \\\"completed_tasks\\\": len(self.completed_tasks),\\n\",\n    \"            \\\"completed_success\\\": completed_success,\\n\",\n    \"            \\\"completed_error\\\": completed_error,\\n\",\n    \"            \\\"max_concurrent\\\": self.max_concurrent,\\n\",\n    \"            \\\"available_slots\\\": self.semaphore._value,\\n\",\n    \"            \\\"total_submitted\\\": self.task_counter,\\n\",\n    \"            \\\"avg_duration\\\": avg_duration\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"async def demonstrate_concurrent_processing():\\n\",\n    \"    \\\"\\\"\\\"Show concurrent processing patterns.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    console.print(Panel(\\\"⚡ Concurrent Processing\\\", style=\\\"bold cyan\\\"))\\n\",\n    \"    \\n\",\n    \"    # Create inference engine\\n\",\n    \"    engine = ConcurrentInferenceEngine(max_concurrent=3)\\n\",\n    \"    \\n\",\n    \"    async def mock_inference(text: str, delay: float = 0.5, fail_rate: float = 0.0) -> str:\\n\",\n    \"        \\\"\\\"\\\"Mock AI inference with variable delay and failure rate.\\\"\\\"\\\"\\n\",\n    \"        import random\\n\",\n    \"        \\n\",\n    \"        # Simulate random failure\\n\",\n    \"        if random.random() < fail_rate:\\n\",\n    \"            raise Exception(f\\\"Inference failed for: {text[:20]}...\\\")\\n\",\n    \"        \\n\",\n    \"        await asyncio.sleep(delay)\\n\",\n    \"        return f\\\"Processed: {text.upper()}\\\"\\n\",\n    \"    \\n\",\n    \"    print(\\\"🤖 Submitting concurrent inference tasks:\\\")\\n\",\n    \"    \\n\",\n    \"    # Submit multiple tasks with different characteristics\\n\",\n    \"    tasks_data = [\\n\",\n    \"        (\\\"task_1\\\", \\\"Analyze sentiment\\\", 0.3, 0.0),\\n\",\n    \"        (\\\"task_2\\\", \\\"Summarize document\\\", 0.8, 0.0),\\n\",\n    \"        (\\\"task_3\\\", \\\"Extract entities\\\", 0.5, 0.2),  # May fail\\n\",\n    \"        (\\\"task_4\\\", \\\"Classify text\\\", 0.4, 0.0),\\n\",\n    \"        (\\\"task_5\\\", \\\"Generate response\\\", 0.6, 0.1),  # May fail\\n\",\n    \"        (\\\"task_6\\\", \\\"Translate text\\\", 0.3, 0.0),\\n\",\n    \"    ]\\n\",\n    \"    \\n\",\n    \"    submitted_tasks = []\\n\",\n    \"    for task_id, text, delay, fail_rate in tasks_data:\\n\",\n    \"        await engine.submit_task(task_id, mock_inference, text, delay, fail_rate)\\n\",\n    \"        submitted_tasks.append(task_id)\\n\",\n    \"        print(f\\\"  ✅ Submitted: {task_id}\\\")\\n\",\n    \"    \\n\",\n    \"    # Monitor progress\\n\",\n    \"    print(f\\\"\\\\n📊 Monitoring task execution:\\\")\\n\",\n    \"    \\n\",\n    \"    while engine.active_tasks:\\n\",\n    \"        stats = engine.get_stats()\\n\",\n    \"        print(f\\\"  Active: {stats['active_tasks']}, Completed: {stats['completed_tasks']}, Available slots: {stats['available_slots']}\\\")\\n\",\n    \"        await asyncio.sleep(0.2)\\n\",\n    \"    \\n\",\n    \"    # Show final results\\n\",\n    \"    print(f\\\"\\\\n📋 Task Results:\\\")\\n\",\n    \"    for completed in engine.completed_tasks:\\n\",\n    \"        status_icon = \\\"✅\\\" if completed[\\\"status\\\"] == \\\"success\\\" else \\\"❌\\\"\\n\",\n    \"        result_preview = completed[\\\"result\\\"][:30] if completed[\\\"result\\\"] else completed[\\\"error\\\"][:30]\\n\",\n    \"        print(f\\\"  {status_icon} {completed['task_id']}: {completed['duration']:.2f}s - {result_preview}...\\\")\\n\",\n    \"    \\n\",\n    \"    final_stats = engine.get_stats()\\n\",\n    \"    print(f\\\"\\\\n📈 Final Statistics:\\\")\\n\",\n    \"    print(f\\\"  Total tasks: {final_stats['total_submitted']}\\\")\\n\",\n    \"    print(f\\\"  Successful: {final_stats['completed_success']}\\\")\\n\",\n    \"    print(f\\\"  Failed: {final_stats['completed_error']}\\\")\\n\",\n    \"    print(f\\\"  Average duration: {final_stats['avg_duration']:.2f}s\\\")\\n\",\n    \"\\n\",\n    \"# Advanced concurrent patterns\\n\",\n    \"class BatchProcessor:\\n\",\n    \"    \\\"\\\"\\\"Process items in batches with concurrency control.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, batch_size: int = 10, max_concurrent_batches: int = 3):\\n\",\n    \"        self.batch_size = batch_size\\n\",\n    \"        self.max_concurrent_batches = max_concurrent_batches\\n\",\n    \"        self.semaphore = asyncio.Semaphore(max_concurrent_batches)\\n\",\n    \"    \\n\",\n    \"    async def process_batch(\\n\",\n    \"        self,\\n\",\n    \"        items: List[Any],\\n\",\n    \"        processor: Callable,\\n\",\n    \"        **kwargs\\n\",\n    \"    ) -> List[Any]:\\n\",\n    \"        \\\"\\\"\\\"Process items in concurrent batches.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        async def process_single_batch(batch_items: List[Any], batch_id: int) -> List[Any]:\\n\",\n    \"            \\\"\\\"\\\"Process a single batch.\\\"\\\"\\\"\\n\",\n    \"            async with self.semaphore:\\n\",\n    \"                print(f\\\"🔄 Processing batch {batch_id} ({len(batch_items)} items)\\\")\\n\",\n    \"                \\n\",\n    \"                # Process items in batch concurrently\\n\",\n    \"                tasks = [processor(item, **kwargs) for item in batch_items]\\n\",\n    \"                results = await asyncio.gather(*tasks, return_exceptions=True)\\n\",\n    \"                \\n\",\n    \"                print(f\\\"✅ Completed batch {batch_id}\\\")\\n\",\n    \"                return results\\n\",\n    \"        \\n\",\n    \"        # Split items into batches\\n\",\n    \"        batches = [\\n\",\n    \"            items[i:i + self.batch_size] \\n\",\n    \"            for i in range(0, len(items), self.batch_size)\\n\",\n    \"        ]\\n\",\n    \"        \\n\",\n    \"        print(f\\\"📦 Processing {len(items)} items in {len(batches)} batches\\\")\\n\",\n    \"        \\n\",\n    \"        # Process batches concurrently\\n\",\n    \"        batch_tasks = [\\n\",\n    \"            process_single_batch(batch, i) \\n\",\n    \"            for i, batch in enumerate(batches)\\n\",\n    \"        ]\\n\",\n    \"        \\n\",\n    \"        batch_results = await asyncio.gather(*batch_tasks)\\n\",\n    \"        \\n\",\n    \"        # Flatten results\\n\",\n    \"        all_results = []\\n\",\n    \"        for batch_result in batch_results:\\n\",\n    \"            all_results.extend(batch_result)\\n\",\n    \"        \\n\",\n    \"        return all_results\\n\",\n    \"\\n\",\n    \"async def demonstrate_batch_processing():\\n\",\n    \"    \\\"\\\"\\\"Show batch processing patterns.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n📦 Batch Processing:\\\")\\n\",\n    \"    \\n\",\n    \"    async def process_text_item(text: str, operation: str = \\\"uppercase\\\") -> str:\\n\",\n    \"        \\\"\\\"\\\"Process a single text item.\\\"\\\"\\\"\\n\",\n    \"        await asyncio.sleep(0.1)  # Simulate processing\\n\",\n    \"        \\n\",\n    \"        if operation == \\\"uppercase\\\":\\n\",\n    \"            return text.upper()\\n\",\n    \"        elif operation == \\\"reverse\\\":\\n\",\n    \"            return text[::-1]\\n\",\n    \"        else:\\n\",\n    \"            return f\\\"PROCESSED: {text}\\\"\\n\",\n    \"    \\n\",\n    \"    # Create test data\\n\",\n    \"    texts = [f\\\"text item {i}\\\" for i in range(25)]\\n\",\n    \"    \\n\",\n    \"    processor = BatchProcessor(batch_size=5, max_concurrent_batches=2)\\n\",\n    \"    \\n\",\n    \"    start_time = time.time()\\n\",\n    \"    \\n\",\n    \"    results = await processor.process_batch(\\n\",\n    \"        texts, \\n\",\n    \"        process_text_item, \\n\",\n    \"        operation=\\\"uppercase\\\"\\n\",\n    \"    )\\n\",\n    \"    \\n\",\n    \"    processing_time = time.time() - start_time\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n📊 Batch Processing Results:\\\")\\n\",\n    \"    print(f\\\"  Total items: {len(texts)}\\\")\\n\",\n    \"    print(f\\\"  Processing time: {processing_time:.2f}s\\\")\\n\",\n    \"    print(f\\\"  Items per second: {len(texts) / processing_time:.1f}\\\")\\n\",\n    \"    print(f\\\"  Sample results: {results[:3]}\\\")\\n\",\n    \"    \\n\",\n    \"    # Count errors\\n\",\n    \"    errors = [r for r in results if isinstance(r, Exception)]\\n\",\n    \"    print(f\\\"  Errors: {len(errors)}\\\")\\n\",\n    \"\\n\",\n    \"# Progress tracking for concurrent operations\\n\",\n    \"class ProgressTracker:\\n\",\n    \"    \\\"\\\"\\\"Track progress of concurrent operations.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, total_tasks: int):\\n\",\n    \"        self.total_tasks = total_tasks\\n\",\n    \"        self.completed_tasks = 0\\n\",\n    \"        self.failed_tasks = 0\\n\",\n    \"        self.start_time = time.time()\\n\",\n    \"        self._lock = asyncio.Lock()\\n\",\n    \"    \\n\",\n    \"    async def task_completed(self, success: bool = True):\\n\",\n    \"        \\\"\\\"\\\"Mark a task as completed.\\\"\\\"\\\"\\n\",\n    \"        async with self._lock:\\n\",\n    \"            if success:\\n\",\n    \"                self.completed_tasks += 1\\n\",\n    \"            else:\\n\",\n    \"                self.failed_tasks += 1\\n\",\n    \"    \\n\",\n    \"    def get_progress(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get current progress.\\\"\\\"\\\"\\n\",\n    \"        total_finished = self.completed_tasks + self.failed_tasks\\n\",\n    \"        progress_pct = (total_finished / self.total_tasks) * 100 if self.total_tasks > 0 else 0\\n\",\n    \"        elapsed_time = time.time() - self.start_time\\n\",\n    \"        \\n\",\n    \"        if total_finished > 0:\\n\",\n    \"            estimated_total_time = elapsed_time * (self.total_tasks / total_finished)\\n\",\n    \"            eta = estimated_total_time - elapsed_time\\n\",\n    \"        else:\\n\",\n    \"            eta = 0\\n\",\n    \"        \\n\",\n    \"        return {\\n\",\n    \"            \\\"completed\\\": self.completed_tasks,\\n\",\n    \"            \\\"failed\\\": self.failed_tasks,\\n\",\n    \"            \\\"total\\\": self.total_tasks,\\n\",\n    \"            \\\"progress_pct\\\": progress_pct,\\n\",\n    \"            \\\"elapsed_time\\\": elapsed_time,\\n\",\n    \"            \\\"eta\\\": max(0, eta)\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"async def demonstrate_progress_tracking():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate progress tracking for concurrent tasks.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n📈 Progress Tracking:\\\")\\n\",\n    \"    \\n\",\n    \"    total_tasks = 20\\n\",\n    \"    tracker = ProgressTracker(total_tasks)\\n\",\n    \"    \\n\",\n    \"    async def tracked_task(task_id: int, delay: float, fail_rate: float = 0.1):\\n\",\n    \"        \\\"\\\"\\\"Task with progress tracking.\\\"\\\"\\\"\\n\",\n    \"        import random\\n\",\n    \"        \\n\",\n    \"        try:\\n\",\n    \"            await asyncio.sleep(delay)\\n\",\n    \"            \\n\",\n    \"            if random.random() < fail_rate:\\n\",\n    \"                raise Exception(f\\\"Task {task_id} failed\\\")\\n\",\n    \"            \\n\",\n    \"            await tracker.task_completed(success=True)\\n\",\n    \"            return f\\\"Task {task_id} completed\\\"\\n\",\n    \"            \\n\",\n    \"        except Exception as e:\\n\",\n    \"            await tracker.task_completed(success=False)\\n\",\n    \"            raise\\n\",\n    \"    \\n\",\n    \"    # Start all tasks\\n\",\n    \"    tasks = [\\n\",\n    \"        asyncio.create_task(tracked_task(i, random.uniform(0.1, 0.5), 0.15))\\n\",\n    \"        for i in range(total_tasks)\\n\",\n    \"    ]\\n\",\n    \"    \\n\",\n    \"    # Monitor progress\\n\",\n    \"    while True:\\n\",\n    \"        progress = tracker.get_progress()\\n\",\n    \"        finished = progress[\\\"completed\\\"] + progress[\\\"failed\\\"]\\n\",\n    \"        \\n\",\n    \"        print(f\\\"\\\\r📊 Progress: {finished}/{total_tasks} ({progress['progress_pct']:.1f}%) - \\\" +\\n\",\n    \"              f\\\"✅ {progress['completed']} success, ❌ {progress['failed']} failed - \\\" +\\n\",\n    \"              f\\\"ETA: {progress['eta']:.1f}s\\\", end=\\\"\\\")\\n\",\n    \"        \\n\",\n    \"        if finished >= total_tasks:\\n\",\n    \"            break\\n\",\n    \"        \\n\",\n    \"        await asyncio.sleep(0.1)\\n\",\n    \"    \\n\",\n    \"    print()  # New line\\n\",\n    \"    \\n\",\n    \"    # Wait for all tasks to complete\\n\",\n    \"    results = await asyncio.gather(*tasks, return_exceptions=True)\\n\",\n    \"    \\n\",\n    \"    success_count = sum(1 for r in results if not isinstance(r, Exception))\\n\",\n    \"    error_count = sum(1 for r in results if isinstance(r, Exception))\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n✅ All tasks completed: {success_count} success, {error_count} errors\\\")\\n\",\n    \"\\n\",\n    \"# Run concurrent processing demonstrations\\n\",\n    \"await demonstrate_concurrent_processing()\\n\",\n    \"await demonstrate_batch_processing()\\n\",\n    \"await demonstrate_progress_tracking()\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Concurrent Processing Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Dramatically improves throughput\\\")\\n\",\n    \"print(f\\\"  ✅ Better resource utilization\\\")\\n\",\n    \"print(f\\\"  ✅ Handles mixed workloads efficiently\\\")\\n\",\n    \"print(f\\\"  ✅ Provides failure isolation\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 6: Production-Ready Async AI System\\n\",\n    \"\\n\",\n    \"**First Principle**: Combine all async patterns to create a robust, scalable AI processing system.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use composition of async components to build complex, maintainable systems.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Complete async AI processing system\\n\",\n    \"from dataclasses import dataclass, field\\n\",\n    \"from typing import Protocol\\n\",\n    \"import json\\n\",\n    \"\\n\",\n    \"@dataclass\\n\",\n    \"class AIRequest:\\n\",\n    \"    \\\"\\\"\\\"AI processing request.\\\"\\\"\\\"\\n\",\n    \"    request_id: str\\n\",\n    \"    text: str\\n\",\n    \"    operation: str  # \\\"classify\\\", \\\"summarize\\\", \\\"translate\\\", etc.\\n\",\n    \"    priority: str = \\\"medium\\\"  # \\\"high\\\", \\\"medium\\\", \\\"low\\\"\\n\",\n    \"    metadata: Dict[str, Any] = field(default_factory=dict)\\n\",\n    \"    created_at: float = field(default_factory=time.time)\\n\",\n    \"\\n\",\n    \"@dataclass\\n\",\n    \"class AIResponse:\\n\",\n    \"    \\\"\\\"\\\"AI processing response.\\\"\\\"\\\"\\n\",\n    \"    request_id: str\\n\",\n    \"    result: Any\\n\",\n    \"    status: str  # \\\"success\\\", \\\"error\\\", \\\"timeout\\\"\\n\",\n    \"    processing_time: float\\n\",\n    \"    model_used: str\\n\",\n    \"    error_message: Optional[str] = None\\n\",\n    \"    completed_at: float = field(default_factory=time.time)\\n\",\n    \"\\n\",\n    \"class AsyncAISystem:\\n\",\n    \"    \\\"\\\"\\\"Production-ready async AI processing system.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(\\n\",\n    \"        self,\\n\",\n    \"        max_concurrent: int = 10,\\n\",\n    \"        rate_limit_per_second: float = 5.0,\\n\",\n    \"        connection_pool_size: int = 5,\\n\",\n    \"        request_timeout: float = 30.0\\n\",\n    \"    ):\\n\",\n    \"        self.max_concurrent = max_concurrent\\n\",\n    \"        self.request_timeout = request_timeout\\n\",\n    \"        \\n\",\n    \"        # Core components\\n\",\n    \"        self.inference_engine = ConcurrentInferenceEngine(max_concurrent)\\n\",\n    \"        self.rate_limiter = TokenBucketRateLimiter(rate_limit_per_second, bucket_size=10)\\n\",\n    \"        self.connection_pool = None  # Will be initialized with mock connections\\n\",\n    \"        \\n\",\n    \"        # Request tracking\\n\",\n    \"        self.active_requests: Dict[str, AIRequest] = {}\\n\",\n    \"        self.completed_requests: List[AIResponse] = []\\n\",\n    \"        \\n\",\n    \"        # Metrics\\n\",\n    \"        self.metrics = {\\n\",\n    \"            \\\"total_requests\\\": 0,\\n\",\n    \"            \\\"successful_requests\\\": 0,\\n\",\n    \"            \\\"failed_requests\\\": 0,\\n\",\n    \"            \\\"timeout_requests\\\": 0,\\n\",\n    \"            \\\"total_processing_time\\\": 0.0\\n\",\n    \"        }\\n\",\n    \"        \\n\",\n    \"        # Background tasks\\n\",\n    \"        self._background_tasks = set()\\n\",\n    \"    \\n\",\n    \"    async def start(self):\\n\",\n    \"        \\\"\\\"\\\"Start the AI system.\\\"\\\"\\\"\\n\",\n    \"        print(\\\"🚀 Starting Async AI System...\\\")\\n\",\n    \"        \\n\",\n    \"        # Initialize connection pool\\n\",\n    \"        async def create_ai_connection():\\n\",\n    \"            await asyncio.sleep(0.1)  # Simulate connection setup\\n\",\n    \"            return MockConnection(f\\\"ai_conn_{int(time.time() * 1000) % 1000}\\\")\\n\",\n    \"        \\n\",\n    \"        self.connection_pool = AsyncConnectionPool(\\n\",\n    \"            create_ai_connection, \\n\",\n    \"            max_size=5\\n\",\n    \"        )\\n\",\n    \"        \\n\",\n    \"        # Start background monitoring\\n\",\n    \"        monitor_task = asyncio.create_task(self._monitor_system())\\n\",\n    \"        self._background_tasks.add(monitor_task)\\n\",\n    \"        \\n\",\n    \"        print(\\\"✅ AI System started successfully\\\")\\n\",\n    \"    \\n\",\n    \"    async def stop(self):\\n\",\n    \"        \\\"\\\"\\\"Stop the AI system gracefully.\\\"\\\"\\\"\\n\",\n    \"        print(\\\"🛑 Stopping Async AI System...\\\")\\n\",\n    \"        \\n\",\n    \"        # Cancel background tasks\\n\",\n    \"        for task in self._background_tasks:\\n\",\n    \"            task.cancel()\\n\",\n    \"        \\n\",\n    \"        # Wait for active requests to complete\\n\",\n    \"        if self.active_requests:\\n\",\n    \"            print(f\\\"⏳ Waiting for {len(self.active_requests)} active requests...\\\")\\n\",\n    \"            # In practice, you'd set a timeout here\\n\",\n    \"            await asyncio.sleep(1.0)\\n\",\n    \"        \\n\",\n    \"        print(\\\"✅ AI System stopped\\\")\\n\",\n    \"    \\n\",\n    \"    async def process_request(self, request: AIRequest) -> AIResponse:\\n\",\n    \"        \\\"\\\"\\\"Process a single AI request.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        # Rate limiting\\n\",\n    \"        await self.rate_limiter.acquire(tokens_needed=1)\\n\",\n    \"        \\n\",\n    \"        # Track request\\n\",\n    \"        self.active_requests[request.request_id] = request\\n\",\n    \"        self.metrics[\\\"total_requests\\\"] += 1\\n\",\n    \"        \\n\",\n    \"        try:\\n\",\n    \"            # Process with timeout\\n\",\n    \"            response = await asyncio.wait_for(\\n\",\n    \"                self._execute_request(request),\\n\",\n    \"                timeout=self.request_timeout\\n\",\n    \"            )\\n\",\n    \"            \\n\",\n    \"            self.metrics[\\\"successful_requests\\\"] += 1\\n\",\n    \"            \\n\",\n    \"        except asyncio.TimeoutError:\\n\",\n    \"            response = AIResponse(\\n\",\n    \"                request_id=request.request_id,\\n\",\n    \"                result=None,\\n\",\n    \"                status=\\\"timeout\\\",\\n\",\n    \"                processing_time=self.request_timeout,\\n\",\n    \"                model_used=\\\"none\\\",\\n\",\n    \"                error_message=\\\"Request timeout\\\"\\n\",\n    \"            )\\n\",\n    \"            self.metrics[\\\"timeout_requests\\\"] += 1\\n\",\n    \"            \\n\",\n    \"        except Exception as e:\\n\",\n    \"            response = AIResponse(\\n\",\n    \"                request_id=request.request_id,\\n\",\n    \"                result=None,\\n\",\n    \"                status=\\\"error\\\",\\n\",\n    \"                processing_time=0.0,\\n\",\n    \"                model_used=\\\"none\\\",\\n\",\n    \"                error_message=str(e)\\n\",\n    \"            )\\n\",\n    \"            self.metrics[\\\"failed_requests\\\"] += 1\\n\",\n    \"        \\n\",\n    \"        finally:\\n\",\n    \"            # Clean up\\n\",\n    \"            if request.request_id in self.active_requests:\\n\",\n    \"                del self.active_requests[request.request_id]\\n\",\n    \"            \\n\",\n    \"            self.completed_requests.append(response)\\n\",\n    \"            self.metrics[\\\"total_processing_time\\\"] += response.processing_time\\n\",\n    \"        \\n\",\n    \"        return response\\n\",\n    \"    \\n\",\n    \"    async def _execute_request(self, request: AIRequest) -> AIResponse:\\n\",\n    \"        \\\"\\\"\\\"Execute the actual AI processing.\\\"\\\"\\\"\\n\",\n    \"        start_time = time.time()\\n\",\n    \"        \\n\",\n    \"        async with self.connection_pool.connection() as conn:\\n\",\n    \"            # Simulate different AI operations\\n\",\n    \"            if request.operation == \\\"classify\\\":\\n\",\n    \"                await asyncio.sleep(0.2)  # Simulate classification\\n\",\n    \"                result = {\\\"category\\\": \\\"positive\\\", \\\"confidence\\\": 0.85}\\n\",\n    \"                model = \\\"classifier-v1\\\"\\n\",\n    \"                \\n\",\n    \"            elif request.operation == \\\"summarize\\\":\\n\",\n    \"                await asyncio.sleep(0.5)  # Simulate summarization\\n\",\n    \"                result = {\\\"summary\\\": f\\\"Summary of: {request.text[:30]}...\\\"}\\n\",\n    \"                model = \\\"summarizer-v2\\\"\\n\",\n    \"                \\n\",\n    \"            elif request.operation == \\\"translate\\\":\\n\",\n    \"                await asyncio.sleep(0.3)  # Simulate translation\\n\",\n    \"                result = {\\\"translated_text\\\": f\\\"TRANSLATED: {request.text}\\\"}\\n\",\n    \"                model = \\\"translator-v1\\\"\\n\",\n    \"                \\n\",\n    \"            else:\\n\",\n    \"                raise ValueError(f\\\"Unknown operation: {request.operation}\\\")\\n\",\n    \"            \\n\",\n    \"            processing_time = time.time() - start_time\\n\",\n    \"            \\n\",\n    \"            return AIResponse(\\n\",\n    \"                request_id=request.request_id,\\n\",\n    \"                result=result,\\n\",\n    \"                status=\\\"success\\\",\\n\",\n    \"                processing_time=processing_time,\\n\",\n    \"                model_used=model\\n\",\n    \"            )\\n\",\n    \"    \\n\",\n    \"    async def process_batch(self, requests: List[AIRequest]) -> List[AIResponse]:\\n\",\n    \"        \\\"\\\"\\\"Process multiple requests concurrently.\\\"\\\"\\\"\\n\",\n    \"        print(f\\\"📦 Processing batch of {len(requests)} requests\\\")\\n\",\n    \"        \\n\",\n    \"        # Group by priority\\n\",\n    \"        priority_groups = {\\\"high\\\": [], \\\"medium\\\": [], \\\"low\\\": []}\\n\",\n    \"        for request in requests:\\n\",\n    \"            priority_groups[request.priority].append(request)\\n\",\n    \"        \\n\",\n    \"        # Process high priority first\\n\",\n    \"        all_responses = []\\n\",\n    \"        for priority in [\\\"high\\\", \\\"medium\\\", \\\"low\\\"]:\\n\",\n    \"            if priority_groups[priority]:\\n\",\n    \"                print(f\\\"🎯 Processing {len(priority_groups[priority])} {priority} priority requests\\\")\\n\",\n    \"                \\n\",\n    \"                tasks = [\\n\",\n    \"                    self.process_request(request) \\n\",\n    \"                    for request in priority_groups[priority]\\n\",\n    \"                ]\\n\",\n    \"                \\n\",\n    \"                responses = await asyncio.gather(*tasks, return_exceptions=True)\\n\",\n    \"                \\n\",\n    \"                # Handle any exceptions\\n\",\n    \"                for i, response in enumerate(responses):\\n\",\n    \"                    if isinstance(response, Exception):\\n\",\n    \"                        # Create error response\\n\",\n    \"                        request = priority_groups[priority][i]\\n\",\n    \"                        response = AIResponse(\\n\",\n    \"                            request_id=request.request_id,\\n\",\n    \"                            result=None,\\n\",\n    \"                            status=\\\"error\\\",\\n\",\n    \"                            processing_time=0.0,\\n\",\n    \"                            model_used=\\\"none\\\",\\n\",\n    \"                            error_message=str(response)\\n\",\n    \"                        )\\n\",\n    \"                \\n\",\n    \"                all_responses.extend(responses)\\n\",\n    \"        \\n\",\n    \"        return all_responses\\n\",\n    \"    \\n\",\n    \"    async def _monitor_system(self):\\n\",\n    \"        \\\"\\\"\\\"Background monitoring task.\\\"\\\"\\\"\\n\",\n    \"        while True:\\n\",\n    \"            try:\\n\",\n    \"                await asyncio.sleep(5.0)  # Monitor every 5 seconds\\n\",\n    \"                \\n\",\n    \"                stats = self.get_system_stats()\\n\",\n    \"                print(f\\\"📊 System Monitor: {stats['active_requests']} active, \\\"\\n\",\n    \"                      f\\\"{stats['total_requests']} total, \\\"\\n\",\n    \"                      f\\\"{stats['success_rate']:.1%} success rate\\\")\\n\",\n    \"                \\n\",\n    \"            except asyncio.CancelledError:\\n\",\n    \"                break\\n\",\n    \"            except Exception as e:\\n\",\n    \"                print(f\\\"⚠️  Monitor error: {e}\\\")\\n\",\n    \"    \\n\",\n    \"    def get_system_stats(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get comprehensive system statistics.\\\"\\\"\\\"\\n\",\n    \"        total_requests = self.metrics[\\\"total_requests\\\"]\\n\",\n    \"        success_rate = (self.metrics[\\\"successful_requests\\\"] / total_requests) if total_requests > 0 else 0\\n\",\n    \"        avg_processing_time = (self.metrics[\\\"total_processing_time\\\"] / self.metrics[\\\"successful_requests\\\"]) if self.metrics[\\\"successful_requests\\\"] > 0 else 0\\n\",\n    \"        \\n\",\n    \"        pool_stats = self.connection_pool.get_stats() if self.connection_pool else {}\\n\",\n    \"        rate_limiter_stats = self.rate_limiter.get_stats()\\n\",\n    \"        \\n\",\n    \"        return {\\n\",\n    \"            \\\"active_requests\\\": len(self.active_requests),\\n\",\n    \"            \\\"total_requests\\\": total_requests,\\n\",\n    \"            \\\"successful_requests\\\": self.metrics[\\\"successful_requests\\\"],\\n\",\n    \"            \\\"failed_requests\\\": self.metrics[\\\"failed_requests\\\"],\\n\",\n    \"            \\\"timeout_requests\\\": self.metrics[\\\"timeout_requests\\\"],\\n\",\n    \"            \\\"success_rate\\\": success_rate,\\n\",\n    \"            \\\"avg_processing_time\\\": avg_processing_time,\\n\",\n    \"            \\\"connection_pool\\\": pool_stats,\\n\",\n    \"            \\\"rate_limiter\\\": rate_limiter_stats\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"async def demonstrate_production_system():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate the complete production async AI system.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    console.print(Panel(\\\"🏭 Production Async AI System\\\", style=\\\"bold green\\\"))\\n\",\n    \"    \\n\",\n    \"    # Create and start the system\\n\",\n    \"    ai_system = AsyncAISystem(\\n\",\n    \"        max_concurrent=5,\\n\",\n    \"        rate_limit_per_second=3.0,\\n\",\n    \"        connection_pool_size=3,\\n\",\n    \"        request_timeout=10.0\\n\",\n    \"    )\\n\",\n    \"    \\n\",\n    \"    await ai_system.start()\\n\",\n    \"    \\n\",\n    \"    try:\\n\",\n    \"        # Create diverse test requests\\n\",\n    \"        requests = [\\n\",\n    \"            AIRequest(\\\"req_001\\\", \\\"Analyze this positive sentiment\\\", \\\"classify\\\", \\\"high\\\"),\\n\",\n    \"            AIRequest(\\\"req_002\\\", \\\"Long document that needs summarization...\\\", \\\"summarize\\\", \\\"medium\\\"),\\n\",\n    \"            AIRequest(\\\"req_003\\\", \\\"Hello world\\\", \\\"translate\\\", \\\"low\\\"),\\n\",\n    \"            AIRequest(\\\"req_004\\\", \\\"Another classification task\\\", \\\"classify\\\", \\\"medium\\\"),\\n\",\n    \"            AIRequest(\\\"req_005\\\", \\\"Important urgent request\\\", \\\"classify\\\", \\\"high\\\"),\\n\",\n    \"            AIRequest(\\\"req_006\\\", \\\"Text to translate\\\", \\\"translate\\\", \\\"low\\\"),\\n\",\n    \"            AIRequest(\\\"req_007\\\", \\\"Document for summary\\\", \\\"summarize\\\", \\\"medium\\\"),\\n\",\n    \"            AIRequest(\\\"req_008\\\", \\\"Final classification\\\", \\\"classify\\\", \\\"low\\\"),\\n\",\n    \"        ]\\n\",\n    \"        \\n\",\n    \"        print(f\\\"\\\\n🚀 Processing {len(requests)} requests through production system:\\\")\\n\",\n    \"        \\n\",\n    \"        # Process requests in batch\\n\",\n    \"        start_time = time.time()\\n\",\n    \"        responses = await ai_system.process_batch(requests)\\n\",\n    \"        total_time = time.time() - start_time\\n\",\n    \"        \\n\",\n    \"        print(f\\\"\\\\n📋 Processing Results:\\\")\\n\",\n    \"        for response in responses:\\n\",\n    \"            status_icon = \\\"✅\\\" if response.status == \\\"success\\\" else \\\"❌\\\" if response.status == \\\"error\\\" else \\\"⏰\\\"\\n\",\n    \"            result_preview = str(response.result)[:40] if response.result else response.error_message[:40]\\n\",\n    \"            print(f\\\"  {status_icon} {response.request_id}: {response.processing_time:.3f}s - {response.model_used} - {result_preview}...\\\")\\n\",\n    \"        \\n\",\n    \"        # Show comprehensive statistics\\n\",\n    \"        stats = ai_system.get_system_stats()\\n\",\n    \"        \\n\",\n    \"        print(f\\\"\\\\n📊 System Performance:\\\")\\n\",\n    \"        print(f\\\"  Total processing time: {total_time:.2f}s\\\")\\n\",\n    \"        print(f\\\"  Average per request: {total_time / len(requests):.3f}s\\\")\\n\",\n    \"        print(f\\\"  Success rate: {stats['success_rate']:.1%}\\\")\\n\",\n    \"        print(f\\\"  Average AI processing time: {stats['avg_processing_time']:.3f}s\\\")\\n\",\n    \"        \\n\",\n    \"        print(f\\\"\\\\n🔧 Resource Utilization:\\\")\\n\",\n    \"        print(f\\\"  Connection pool: {stats['connection_pool']}\\\")\\n\",\n    \"        print(f\\\"  Rate limiter: {stats['rate_limiter']}\\\")\\n\",\n    \"        \\n\",\n    \"        # Test streaming capabilities\\n\",\n    \"        print(f\\\"\\\\n🌊 Testing streaming response:\\\")\\n\",\n    \"        \\n\",\n    \"        provider = StreamingAIProvider(response_delay=0.05)\\n\",\n    \"        messages = [Message(role=\\\"user\\\", content=\\\"Stream a response about async programming\\\")]\\n\",\n    \"        \\n\",\n    \"        full_response = \\\"\\\"\\n\",\n    \"        chunk_count = 0\\n\",\n    \"        \\n\",\n    \"        async for chunk in provider.stream_completion(\\\"gpt-4\\\", messages):\\n\",\n    \"            full_response += chunk.content\\n\",\n    \"            chunk_count += 1\\n\",\n    \"            \\n\",\n    \"            if chunk.is_final:\\n\",\n    \"                print(f\\\"  📡 Streamed {chunk_count} chunks: '{full_response}'\\\")\\n\",\n    \"        \\n\",\n    \"        print(f\\\"\\\\n🎯 Production System Features Demonstrated:\\\")\\n\",\n    \"        print(f\\\"  ✅ Concurrent request processing\\\")\\n\",\n    \"        print(f\\\"  ✅ Priority-based scheduling\\\")\\n\",\n    \"        print(f\\\"  ✅ Rate limiting and resource control\\\")\\n\",\n    \"        print(f\\\"  ✅ Connection pooling\\\")\\n\",\n    \"        print(f\\\"  ✅ Timeout handling\\\")\\n\",\n    \"        print(f\\\"  ✅ Comprehensive monitoring\\\")\\n\",\n    \"        print(f\\\"  ✅ Graceful error handling\\\")\\n\",\n    \"        print(f\\\"  ✅ Streaming capabilities\\\")\\n\",\n    \"        \\n\",\n    \"    finally:\\n\",\n    \"        await ai_system.stop()\\n\",\n    \"\\n\",\n    \"# Run the production system demonstration\\n\",\n    \"await demonstrate_production_system()\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🏆 Async Patterns Mastery Complete!\\\")\\n\",\n    \"print(f\\\"\\\\n💡 Key Async Benefits for AI Systems:\\\")\\n\",\n    \"print(f\\\"  ⚡ 10-100x performance improvement for I/O-bound operations\\\")\\n\",\n    \"print(f\\\"  🔄 Real-time streaming and user feedback\\\")\\n\",\n    \"print(f\\\"  📈 Scales to thousands of concurrent requests\\\")\\n\",\n    \"print(f\\\"  💾 Efficient resource utilization\\\")\\n\",\n    \"print(f\\\"  🛡️  Built-in error handling and timeout management\\\")\\n\",\n    \"print(f\\\"  📊 Comprehensive monitoring and metrics\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Summary: Async Patterns Mastery\\n\",\n    \"\\n\",\n    \"**🎯 Key Takeaways:**\\n\",\n    \"\\n\",\n    \"1. **Streaming** enables real-time user feedback and memory efficiency\\n\",\n    \"2. **Rate Limiting** prevents resource exhaustion and ensures fair usage\\n\",\n    \"3. **Connection Pooling** reuses expensive resources efficiently\\n\",\n    \"4. **Concurrent Processing** dramatically improves throughput\\n\",\n    \"5. **Batch Processing** optimizes resource usage for bulk operations\\n\",\n    \"6. **Async Context Managers** ensure proper resource cleanup\\n\",\n    \"7. **Progress Tracking** provides visibility into long-running operations\\n\",\n    \"\\n\",\n    \"**🚀 Production Considerations:**\\n\",\n    \"- Always use timeouts to prevent hanging operations\\n\",\n    \"- Implement proper error handling and retry logic\\n\",\n    \"- Monitor resource usage and performance metrics\\n\",\n    \"- Use priority queues for important requests\\n\",\n    \"- Plan for graceful shutdown and cleanup\\n\",\n    \"\\n\",\n    \"**💡 Remember:** Async programming is essential for building scalable AI systems that can handle real-world load and provide responsive user experiences!\"\n   ]\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"Python 3\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.11.0\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 4\n}","structuredPatch":[]}}
{"parentUuid":"10310621-d474-403e-ae1d-d2cded1290b0","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_01FR5iqZqH3Da5iQfP4asyuU","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Now let me create the notebook for performance optimization (file 5):"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":139085,"cache_read_input_tokens":0,"output_tokens":3}},"requestId":"req_vrtx_011CRhSYczuuib9Tu6sh1g7f","type":"assistant","uuid":"78209563-7338-4e1a-a54f-9441f58f21a3","timestamp":"2025-08-01T18:11:47.372Z"}
{"parentUuid":"78209563-7338-4e1a-a54f-9441f58f21a3","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_01FR5iqZqH3Da5iQfP4asyuU","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_vrtx_01NqgAZAe2ajWivvFZ31rVm2","name":"Write","input":{"file_path":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/notebooks/05_performance_optimization_learning.ipynb","content":"{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Performance Optimization for AI Systems\\n\",\n    \"\\n\",\n    \"This notebook teaches performance optimization techniques for AI applications including profiling, memory management, vectorization, and parallel processing. You'll learn:\\n\",\n    \"\\n\",\n    \"1. **Memory-Efficient Data Structures** - Optimizing memory usage\\n\",\n    \"2. **Performance Profiling** - Identifying bottlenecks\\n\",\n    \"3. **Vectorized Operations** - NumPy and efficient computations\\n\",\n    \"4. **Parallel Processing** - CPU and I/O optimization\\n\",\n    \"5. **Lazy Loading** - Memory-efficient data processing\\n\",\n    \"6. **Batch Processing** - Optimizing throughput\\n\",\n    \"7. **Garbage Collection** - Memory management\\n\",\n    \"8. **Benchmarking** - Measuring and comparing performance\\n\",\n    \"\\n\",\n    \"## Prerequisites\\n\",\n    \"```bash\\n\",\n    \"pip install rich numpy\\n\",\n    \"```\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 1: Performance Fundamentals and Setup\\n\",\n    \"\\n\",\n    \"**First Principle**: Performance optimization starts with measurement - profile first, optimize second.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `time.perf_counter()` for precise timing, `sys.getsizeof()` for memory measurement.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Essential imports for performance optimization\\n\",\n    \"import sys\\n\",\n    \"import time\\n\",\n    \"import gc\\n\",\n    \"import weakref\\n\",\n    \"import threading\\n\",\n    \"import multiprocessing as mp\\n\",\n    \"from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, as_completed\\n\",\n    \"from typing import List, Dict, Any, Callable, Iterator, Optional, Tuple\\n\",\n    \"from dataclasses import dataclass\\n\",\n    \"from functools import lru_cache, partial\\n\",\n    \"import cProfile\\n\",\n    \"import pstats\\n\",\n    \"import tracemalloc\\n\",\n    \"from contextlib import contextmanager\\n\",\n    \"from collections import deque, defaultdict\\n\",\n    \"import numpy as np\\n\",\n    \"from rich.console import Console\\n\",\n    \"from rich.panel import Panel\\n\",\n    \"from rich.table import Table\\n\",\n    \"\\n\",\n    \"console = Console()\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"⚡ Performance Optimization Fundamentals\\\", style=\\\"bold blue\\\"))\\n\",\n    \"\\n\",\n    \"print(\\\"\\\"\\\"\\n\",\n    \"🔑 Key Performance Principles:\\n\",\n    \"\\n\",\n    \"1. **Measure First**: Profile before optimizing\\n\",\n    \"2. **Bottleneck Focus**: Optimize the slowest parts\\n\",\n    \"3. **Memory Efficiency**: Reduce allocations and copies\\n\",\n    \"4. **Vectorization**: Use NumPy for numerical operations\\n\",\n    \"5. **Parallelization**: Leverage multiple cores\\n\",\n    \"6. **Caching**: Avoid redundant computations\\n\",\n    \"7. **Lazy Evaluation**: Compute only when needed\\n\",\n    \"\\n\",\n    \"🎯 Performance Areas for AI:\\n\",\n    \"• Data loading and preprocessing\\n\",\n    \"• Model inference and training\\n\",\n    \"• Feature extraction and transformation\\n\",\n    \"• Batch processing and streaming\\n\",\n    \"• Memory management\\n\",\n    \"\\\"\\\"\\\")\\n\",\n    \"\\n\",\n    \"# Basic timing utilities\\n\",\n    \"@contextmanager\\n\",\n    \"def profile_time(operation_name: str = \\\"Operation\\\"):\\n\",\n    \"    \\\"\\\"\\\"Context manager for timing operations.\\\"\\\"\\\"\\n\",\n    \"    start_time = time.perf_counter()\\n\",\n    \"    yield\\n\",\n    \"    end_time = time.perf_counter()\\n\",\n    \"    duration = end_time - start_time\\n\",\n    \"    print(f\\\"⏱️  {operation_name}: {duration:.4f}s\\\")\\n\",\n    \"\\n\",\n    \"@contextmanager\\n\",\n    \"def profile_memory(operation_name: str = \\\"Operation\\\"):\\n\",\n    \"    \\\"\\\"\\\"Context manager for memory profiling.\\\"\\\"\\\"\\n\",\n    \"    tracemalloc.start()\\n\",\n    \"    start_memory = tracemalloc.get_traced_memory()[0]\\n\",\n    \"    \\n\",\n    \"    yield\\n\",\n    \"    \\n\",\n    \"    end_memory = tracemalloc.get_traced_memory()[0]\\n\",\n    \"    tracemalloc.stop()\\n\",\n    \"    \\n\",\n    \"    memory_used = (end_memory - start_memory) / (1024 * 1024)  # MB\\n\",\n    \"    print(f\\\"🧠 {operation_name} memory: {memory_used:.2f} MB\\\")\\n\",\n    \"\\n\",\n    \"def compare_performance(functions: List[Tuple[str, Callable]], *args, **kwargs):\\n\",\n    \"    \\\"\\\"\\\"Compare performance of multiple functions.\\\"\\\"\\\"\\n\",\n    \"    results = []\\n\",\n    \"    \\n\",\n    \"    for name, func in functions:\\n\",\n    \"        # Warm up\\n\",\n    \"        try:\\n\",\n    \"            func(*args, **kwargs)\\n\",\n    \"        except:\\n\",\n    \"            pass\\n\",\n    \"        \\n\",\n    \"        # Measure\\n\",\n    \"        start_time = time.perf_counter()\\n\",\n    \"        try:\\n\",\n    \"            result = func(*args, **kwargs)\\n\",\n    \"            end_time = time.perf_counter()\\n\",\n    \"            duration = end_time - start_time\\n\",\n    \"            results.append((name, duration, \\\"success\\\", result))\\n\",\n    \"        except Exception as e:\\n\",\n    \"            end_time = time.perf_counter()\\n\",\n    \"            duration = end_time - start_time\\n\",\n    \"            results.append((name, duration, \\\"error\\\", str(e)))\\n\",\n    \"    \\n\",\n    \"    # Display results\\n\",\n    \"    print(f\\\"\\\\n📊 Performance Comparison:\\\")\\n\",\n    \"    fastest_time = min(r[1] for r in results if r[2] == \\\"success\\\")\\n\",\n    \"    \\n\",\n    \"    for name, duration, status, result in results:\\n\",\n    \"        if status == \\\"success\\\":\\n\",\n    \"            speedup = fastest_time / duration\\n\",\n    \"            print(f\\\"  {name}: {duration:.4f}s ({speedup:.1f}x)\\\")\\n\",\n    \"        else:\\n\",\n    \"            print(f\\\"  {name}: ERROR - {result}\\\")\\n\",\n    \"    \\n\",\n    \"    return results\\n\",\n    \"\\n\",\n    \"# Simple demonstration\\n\",\n    \"def demo_timing():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate basic timing.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    # Inefficient way\\n\",\n    \"    def slow_sum(n: int) -> int:\\n\",\n    \"        result = 0\\n\",\n    \"        for i in range(n):\\n\",\n    \"            result += i\\n\",\n    \"        return result\\n\",\n    \"    \\n\",\n    \"    # Efficient way\\n\",\n    \"    def fast_sum(n: int) -> int:\\n\",\n    \"        return n * (n - 1) // 2\\n\",\n    \"    \\n\",\n    \"    n = 1000000\\n\",\n    \"    \\n\",\n    \"    compare_performance([\\n\",\n    \"        (\\\"Slow loop\\\", slow_sum),\\n\",\n    \"        (\\\"Fast formula\\\", fast_sum)\\n\",\n    \"    ], n)\\n\",\n    \"\\n\",\n    \"demo_timing()\\n\",\n    \"print(\\\"\\\\n✅ Performance toolkit ready!\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 2: Memory-Efficient Data Structures\\n\",\n    \"\\n\",\n    \"**First Principle**: Memory efficiency is crucial for AI systems that process large datasets.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `deque`, `__slots__`, and custom memory-aware containers to reduce memory overhead.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class MemoryEfficientCache:\\n\",\n    \"    \\\"\\\"\\\"Memory-efficient LRU cache with size limits.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, max_size: int = 1000, max_memory_mb: float = 100.0):\\n\",\n    \"        self.max_size = max_size\\n\",\n    \"        self.max_memory_bytes = max_memory_mb * 1024 * 1024\\n\",\n    \"        self.cache = {}\\n\",\n    \"        self.access_order = deque()\\n\",\n    \"        self.current_memory = 0\\n\",\n    \"        self.hits = 0\\n\",\n    \"        self.misses = 0\\n\",\n    \"    \\n\",\n    \"    def _estimate_size(self, obj: Any) -> int:\\n\",\n    \"        \\\"\\\"\\\"Estimate object size in bytes.\\\"\\\"\\\"\\n\",\n    \"        return sys.getsizeof(obj)\\n\",\n    \"    \\n\",\n    \"    def _evict_if_needed(self):\\n\",\n    \"        \\\"\\\"\\\"Evict items if cache is too large.\\\"\\\"\\\"\\n\",\n    \"        while (len(self.cache) > self.max_size or \\n\",\n    \"               self.current_memory > self.max_memory_bytes):\\n\",\n    \"            if not self.access_order:\\n\",\n    \"                break\\n\",\n    \"            \\n\",\n    \"            key = self.access_order.popleft()\\n\",\n    \"            if key in self.cache:\\n\",\n    \"                value = self.cache.pop(key)\\n\",\n    \"                self.current_memory -= self._estimate_size(value)\\n\",\n    \"    \\n\",\n    \"    def get(self, key: str) -> Optional[Any]:\\n\",\n    \"        \\\"\\\"\\\"Get item from cache.\\\"\\\"\\\"\\n\",\n    \"        if key in self.cache:\\n\",\n    \"            # Move to end (most recent)\\n\",\n    \"            self.access_order.remove(key)\\n\",\n    \"            self.access_order.append(key)\\n\",\n    \"            self.hits += 1\\n\",\n    \"            return self.cache[key]\\n\",\n    \"        \\n\",\n    \"        self.misses += 1\\n\",\n    \"        return None\\n\",\n    \"    \\n\",\n    \"    def put(self, key: str, value: Any) -> None:\\n\",\n    \"        \\\"\\\"\\\"Put item in cache.\\\"\\\"\\\"\\n\",\n    \"        if key in self.cache:\\n\",\n    \"            # Update existing\\n\",\n    \"            old_value = self.cache[key]\\n\",\n    \"            self.current_memory -= self._estimate_size(old_value)\\n\",\n    \"            self.access_order.remove(key)\\n\",\n    \"        \\n\",\n    \"        size = self._estimate_size(value)\\n\",\n    \"        self.cache[key] = value\\n\",\n    \"        self.access_order.append(key)\\n\",\n    \"        self.current_memory += size\\n\",\n    \"        \\n\",\n    \"        self._evict_if_needed()\\n\",\n    \"    \\n\",\n    \"    def get_stats(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get cache statistics.\\\"\\\"\\\"\\n\",\n    \"        total_requests = self.hits + self.misses\\n\",\n    \"        hit_ratio = self.hits / total_requests if total_requests > 0 else 0\\n\",\n    \"        \\n\",\n    \"        return {\\n\",\n    \"            \\\"size\\\": len(self.cache),\\n\",\n    \"            \\\"max_size\\\": self.max_size,\\n\",\n    \"            \\\"memory_mb\\\": self.current_memory / (1024 * 1024),\\n\",\n    \"            \\\"max_memory_mb\\\": self.max_memory_bytes / (1024 * 1024),\\n\",\n    \"            \\\"hit_ratio\\\": hit_ratio,\\n\",\n    \"            \\\"hits\\\": self.hits,\\n\",\n    \"            \\\"misses\\\": self.misses\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"class ObjectPool:\\n\",\n    \"    \\\"\\\"\\\"Object pool for expensive-to-create objects.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, factory: Callable, max_size: int = 10):\\n\",\n    \"        self.factory = factory\\n\",\n    \"        self.max_size = max_size\\n\",\n    \"        self.available = deque()\\n\",\n    \"        self.in_use = weakref.WeakSet()\\n\",\n    \"        self.total_created = 0\\n\",\n    \"        self.total_acquired = 0\\n\",\n    \"        self.total_released = 0\\n\",\n    \"    \\n\",\n    \"    def acquire(self):\\n\",\n    \"        \\\"\\\"\\\"Acquire object from pool.\\\"\\\"\\\"\\n\",\n    \"        self.total_acquired += 1\\n\",\n    \"        \\n\",\n    \"        if self.available:\\n\",\n    \"            obj = self.available.popleft()\\n\",\n    \"        else:\\n\",\n    \"            if self.total_created < self.max_size:\\n\",\n    \"                obj = self.factory()\\n\",\n    \"                self.total_created += 1\\n\",\n    \"            else:\\n\",\n    \"                # Create temporary object (not pooled)\\n\",\n    \"                obj = self.factory()\\n\",\n    \"        \\n\",\n    \"        self.in_use.add(obj)\\n\",\n    \"        return obj\\n\",\n    \"    \\n\",\n    \"    def release(self, obj):\\n\",\n    \"        \\\"\\\"\\\"Release object back to pool.\\\"\\\"\\\"\\n\",\n    \"        self.total_released += 1\\n\",\n    \"        \\n\",\n    \"        if obj in self.in_use:\\n\",\n    \"            self.in_use.remove(obj)\\n\",\n    \"            if len(self.available) < self.max_size:\\n\",\n    \"                # Reset object state if needed\\n\",\n    \"                if hasattr(obj, 'reset'):\\n\",\n    \"                    obj.reset()\\n\",\n    \"                self.available.append(obj)\\n\",\n    \"    \\n\",\n    \"    @contextmanager\\n\",\n    \"    def borrow(self):\\n\",\n    \"        \\\"\\\"\\\"Context manager for automatic object management.\\\"\\\"\\\"\\n\",\n    \"        obj = self.acquire()\\n\",\n    \"        try:\\n\",\n    \"            yield obj\\n\",\n    \"        finally:\\n\",\n    \"            self.release(obj)\\n\",\n    \"    \\n\",\n    \"    def get_stats(self) -> Dict[str, Any]:\\n\",\n    \"        return {\\n\",\n    \"            \\\"available\\\": len(self.available),\\n\",\n    \"            \\\"in_use\\\": len(self.in_use),\\n\",\n    \"            \\\"total_created\\\": self.total_created,\\n\",\n    \"            \\\"total_acquired\\\": self.total_acquired,\\n\",\n    \"            \\\"total_released\\\": self.total_released,\\n\",\n    \"            \\\"max_size\\\": self.max_size,\\n\",\n    \"            \\\"pool_efficiency\\\": len(self.available) / self.max_size if self.max_size > 0 else 0\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"# Memory-efficient classes using __slots__\\n\",\n    \"class EfficientDataPoint:\\n\",\n    \"    \\\"\\\"\\\"Memory-efficient data point using __slots__.\\\"\\\"\\\"\\n\",\n    \"    __slots__ = ['x', 'y', 'label', 'confidence']\\n\",\n    \"    \\n\",\n    \"    def __init__(self, x: float, y: float, label: str, confidence: float):\\n\",\n    \"        self.x = x\\n\",\n    \"        self.y = y\\n\",\n    \"        self.label = label\\n\",\n    \"        self.confidence = confidence\\n\",\n    \"\\n\",\n    \"class RegularDataPoint:\\n\",\n    \"    \\\"\\\"\\\"Regular data point without __slots__.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, x: float, y: float, label: str, confidence: float):\\n\",\n    \"        self.x = x\\n\",\n    \"        self.y = y\\n\",\n    \"        self.label = label\\n\",\n    \"        self.confidence = confidence\\n\",\n    \"\\n\",\n    \"def demonstrate_memory_efficient_structures():\\n\",\n    \"    \\\"\\\"\\\"Show memory-efficient data structures.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    console.print(Panel(\\\"🧠 Memory-Efficient Structures\\\", style=\\\"bold blue\\\"))\\n\",\n    \"    \\n\",\n    \"    # Test memory-efficient cache\\n\",\n    \"    print(\\\"💾 Testing memory-efficient cache:\\\")\\n\",\n    \"    \\n\",\n    \"    cache = MemoryEfficientCache(max_size=5, max_memory_mb=0.1)\\n\",\n    \"    \\n\",\n    \"    # Add items to cache\\n\",\n    \"    test_data = [f\\\"large_data_item_{i}\\\" * 100 for i in range(10)]\\n\",\n    \"    \\n\",\n    \"    for i, data in enumerate(test_data):\\n\",\n    \"        cache.put(f\\\"key_{i}\\\", data)\\n\",\n    \"        stats = cache.get_stats()\\n\",\n    \"        print(f\\\"  Added item {i}: cache size={stats['size']}, memory={stats['memory_mb']:.3f}MB\\\")\\n\",\n    \"    \\n\",\n    \"    # Test retrieval\\n\",\n    \"    print(f\\\"\\\\n🔍 Cache retrieval test:\\\")\\n\",\n    \"    for i in [0, 3, 7, 9]:\\n\",\n    \"        result = cache.get(f\\\"key_{i}\\\")\\n\",\n    \"        status = \\\"HIT\\\" if result else \\\"MISS\\\"\\n\",\n    \"        print(f\\\"  key_{i}: {status}\\\")\\n\",\n    \"    \\n\",\n    \"    final_stats = cache.get_stats()\\n\",\n    \"    print(f\\\"\\\\nCache final stats: {final_stats}\\\")\\n\",\n    \"    \\n\",\n    \"    # Test object pool\\n\",\n    \"    print(f\\\"\\\\n🏊 Testing object pool:\\\")\\n\",\n    \"    \\n\",\n    \"    class ExpensiveResource:\\n\",\n    \"        def __init__(self):\\n\",\n    \"            time.sleep(0.01)  # Simulate expensive creation\\n\",\n    \"            self.created_at = time.time()\\n\",\n    \"            self.usage_count = 0\\n\",\n    \"        \\n\",\n    \"        def reset(self):\\n\",\n    \"            self.usage_count = 0\\n\",\n    \"        \\n\",\n    \"        def use(self):\\n\",\n    \"            self.usage_count += 1\\n\",\n    \"            return f\\\"Used {self.usage_count} times\\\"\\n\",\n    \"    \\n\",\n    \"    pool = ObjectPool(ExpensiveResource, max_size=3)\\n\",\n    \"    \\n\",\n    \"    # Use objects from pool\\n\",\n    \"    with profile_time(\\\"Object pool operations\\\"):\\n\",\n    \"        for i in range(5):\\n\",\n    \"            with pool.borrow() as obj:\\n\",\n    \"                result = obj.use()\\n\",\n    \"                print(f\\\"  Operation {i}: {result}\\\")\\n\",\n    \"    \\n\",\n    \"    pool_stats = pool.get_stats()\\n\",\n    \"    print(f\\\"Pool stats: {pool_stats}\\\")\\n\",\n    \"    \\n\",\n    \"    # Compare __slots__ vs regular classes\\n\",\n    \"    print(f\\\"\\\\n📏 Memory comparison (__slots__ vs regular):\\\")\\n\",\n    \"    \\n\",\n    \"    # Create instances\\n\",\n    \"    efficient_point = EfficientDataPoint(1.0, 2.0, \\\"positive\\\", 0.95)\\n\",\n    \"    regular_point = RegularDataPoint(1.0, 2.0, \\\"positive\\\", 0.95)\\n\",\n    \"    \\n\",\n    \"    efficient_size = sys.getsizeof(efficient_point)\\n\",\n    \"    regular_size = sys.getsizeof(regular_point)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  EfficientDataPoint (__slots__): {efficient_size} bytes\\\")\\n\",\n    \"    print(f\\\"  RegularDataPoint: {regular_size} bytes\\\")\\n\",\n    \"    print(f\\\"  Memory savings: {((regular_size - efficient_size) / regular_size) * 100:.1f}%\\\")\\n\",\n    \"    \\n\",\n    \"    # Test with many objects\\n\",\n    \"    n_objects = 10000\\n\",\n    \"    \\n\",\n    \"    with profile_memory(\\\"Creating efficient objects\\\"):\\n\",\n    \"        efficient_objects = [\\n\",\n    \"            EfficientDataPoint(i, i*2, f\\\"label_{i%3}\\\", i/n_objects)\\n\",\n    \"            for i in range(n_objects)\\n\",\n    \"        ]\\n\",\n    \"    \\n\",\n    \"    with profile_memory(\\\"Creating regular objects\\\"):\\n\",\n    \"        regular_objects = [\\n\",\n    \"            RegularDataPoint(i, i*2, f\\\"label_{i%3}\\\", i/n_objects)\\n\",\n    \"            for i in range(n_objects)\\n\",\n    \"        ]\\n\",\n    \"    \\n\",\n    \"    # Clean up\\n\",\n    \"    del efficient_objects, regular_objects\\n\",\n    \"    gc.collect()\\n\",\n    \"\\n\",\n    \"demonstrate_memory_efficient_structures()\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Memory Efficiency Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Reduced memory usage with __slots__\\\")\\n\",\n    \"print(f\\\"  ✅ Smart caching with size and memory limits\\\")\\n\",\n    \"print(f\\\"  ✅ Object pooling for expensive resources\\\")\\n\",\n    \"print(f\\\"  ✅ Efficient data structures (deque, weakref)\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 3: Performance Profiling and Monitoring\\n\",\n    \"\\n\",\n    \"**First Principle**: Measure performance to identify bottlenecks before optimizing.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `cProfile`, `tracemalloc`, and custom monitoring for comprehensive profiling.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class PerformanceMonitor:\\n\",\n    \"    \\\"\\\"\\\"Monitor for tracking performance metrics.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self):\\n\",\n    \"        self.metrics = defaultdict(list)\\n\",\n    \"        self.counters = defaultdict(int)\\n\",\n    \"        self.start_times = {}\\n\",\n    \"    \\n\",\n    \"    def start_timer(self, operation: str):\\n\",\n    \"        \\\"\\\"\\\"Start timing an operation.\\\"\\\"\\\"\\n\",\n    \"        self.start_times[operation] = time.perf_counter()\\n\",\n    \"    \\n\",\n    \"    def stop_timer(self, operation: str):\\n\",\n    \"        \\\"\\\"\\\"Stop timing an operation and record the duration.\\\"\\\"\\\"\\n\",\n    \"        if operation in self.start_times:\\n\",\n    \"            duration = time.perf_counter() - self.start_times[operation]\\n\",\n    \"            self.record_time(operation, duration)\\n\",\n    \"            del self.start_times[operation]\\n\",\n    \"            return duration\\n\",\n    \"        return 0.0\\n\",\n    \"    \\n\",\n    \"    def record_time(self, operation: str, duration: float):\\n\",\n    \"        \\\"\\\"\\\"Record operation timing.\\\"\\\"\\\"\\n\",\n    \"        self.metrics[f\\\"{operation}_time\\\"].append(duration)\\n\",\n    \"        self.counters[f\\\"{operation}_count\\\"] += 1\\n\",\n    \"    \\n\",\n    \"    def record_memory(self, operation: str, memory_mb: float):\\n\",\n    \"        \\\"\\\"\\\"Record memory usage.\\\"\\\"\\\"\\n\",\n    \"        self.metrics[f\\\"{operation}_memory\\\"].append(memory_mb)\\n\",\n    \"    \\n\",\n    \"    def increment_counter(self, name: str, value: int = 1):\\n\",\n    \"        \\\"\\\"\\\"Increment a counter.\\\"\\\"\\\"\\n\",\n    \"        self.counters[name] += value\\n\",\n    \"    \\n\",\n    \"    @contextmanager\\n\",\n    \"    def time_operation(self, operation: str):\\n\",\n    \"        \\\"\\\"\\\"Context manager for timing operations.\\\"\\\"\\\"\\n\",\n    \"        self.start_timer(operation)\\n\",\n    \"        try:\\n\",\n    \"            yield\\n\",\n    \"        finally:\\n\",\n    \"            self.stop_timer(operation)\\n\",\n    \"    \\n\",\n    \"    def get_summary(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get performance summary.\\\"\\\"\\\"\\n\",\n    \"        summary = {}\\n\",\n    \"        \\n\",\n    \"        for metric_name, values in self.metrics.items():\\n\",\n    \"            if values:\\n\",\n    \"                summary[metric_name] = {\\n\",\n    \"                    \\\"avg\\\": sum(values) / len(values),\\n\",\n    \"                    \\\"min\\\": min(values),\\n\",\n    \"                    \\\"max\\\": max(values),\\n\",\n    \"                    \\\"count\\\": len(values),\\n\",\n    \"                    \\\"total\\\": sum(values)\\n\",\n    \"                }\\n\",\n    \"        \\n\",\n    \"        summary[\\\"counters\\\"] = dict(self.counters)\\n\",\n    \"        return summary\\n\",\n    \"\\n\",\n    \"# Example AI processing functions for profiling\\n\",\n    \"def simulate_data_loading(size: int) -> List[Dict[str, Any]]:\\n\",\n    \"    \\\"\\\"\\\"Simulate loading data.\\\"\\\"\\\"\\n\",\n    \"    return [{\\n\",\n    \"        \\\"id\\\": i,\\n\",\n    \"        \\\"features\\\": [j * 0.1 for j in range(10)],\\n\",\n    \"        \\\"label\\\": i % 3,\\n\",\n    \"        \\\"metadata\\\": {\\\"source\\\": f\\\"dataset_{i//100}\\\"}\\n\",\n    \"    } for i in range(size)]\\n\",\n    \"\\n\",\n    \"def simulate_feature_extraction(data_point: Dict[str, Any]) -> List[float]:\\n\",\n    \"    \\\"\\\"\\\"Simulate feature extraction.\\\"\\\"\\\"\\n\",\n    \"    features = data_point[\\\"features\\\"]\\n\",\n    \"    # Simulate some processing\\n\",\n    \"    processed = []\\n\",\n    \"    for f in features:\\n\",\n    \"        processed.append(f * f)  # Square\\n\",\n    \"        processed.append(f * 2)  # Double\\n\",\n    \"    return processed\\n\",\n    \"\\n\",\n    \"def simulate_model_inference(features: List[float]) -> Dict[str, Any]:\\n\",\n    \"    \\\"\\\"\\\"Simulate model inference.\\\"\\\"\\\"\\n\",\n    \"    # Simulate computation\\n\",\n    \"    score = sum(features) / len(features) if features else 0\\n\",\n    \"    prediction = \\\"positive\\\" if score > 0.5 else \\\"negative\\\"\\n\",\n    \"    confidence = min(abs(score), 1.0)\\n\",\n    \"    \\n\",\n    \"    return {\\n\",\n    \"        \\\"prediction\\\": prediction,\\n\",\n    \"        \\\"confidence\\\": confidence,\\n\",\n    \"        \\\"score\\\": score\\n\",\n    \"    }\\n\",\n    \"\\n\",\n    \"@lru_cache(maxsize=1000)\\n\",\n    \"def cached_expensive_computation(data_hash: str) -> float:\\n\",\n    \"    \\\"\\\"\\\"Expensive computation with caching.\\\"\\\"\\\"\\n\",\n    \"    # Simulate expensive computation\\n\",\n    \"    result = 0.0\\n\",\n    \"    for i in range(1000):\\n\",\n    \"        result += hash(data_hash + str(i)) % 100 / 100.0\\n\",\n    \"    return result\\n\",\n    \"\\n\",\n    \"def demonstrate_profiling():\\n\",\n    \"    \\\"\\\"\\\"Show profiling techniques.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    console.print(Panel(\\\"📊 Performance Profiling\\\", style=\\\"bold green\\\"))\\n\",\n    \"    \\n\",\n    \"    monitor = PerformanceMonitor()\\n\",\n    \"    \\n\",\n    \"    print(\\\"🔍 Profiling AI processing pipeline:\\\")\\n\",\n    \"    \\n\",\n    \"    # Simulate processing pipeline\\n\",\n    \"    with monitor.time_operation(\\\"data_loading\\\"):\\n\",\n    \"        data = simulate_data_loading(1000)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Loaded {len(data)} data points\\\")\\n\",\n    \"    \\n\",\n    \"    # Process data with detailed monitoring\\n\",\n    \"    results = []\\n\",\n    \"    \\n\",\n    \"    for i, data_point in enumerate(data[:100]):  # Process subset\\n\",\n    \"        # Feature extraction\\n\",\n    \"        with monitor.time_operation(\\\"feature_extraction\\\"):\\n\",\n    \"            features = simulate_feature_extraction(data_point)\\n\",\n    \"        \\n\",\n    \"        # Model inference\\n\",\n    \"        with monitor.time_operation(\\\"model_inference\\\"):\\n\",\n    \"            prediction = simulate_model_inference(features)\\n\",\n    \"        \\n\",\n    \"        # Expensive computation (with caching)\\n\",\n    \"        data_hash = str(hash(str(data_point[\\\"features\\\"])))\\n\",\n    \"        with monitor.time_operation(\\\"expensive_computation\\\"):\\n\",\n    \"            expensive_result = cached_expensive_computation(data_hash)\\n\",\n    \"        \\n\",\n    \"        monitor.increment_counter(\\\"processed_items\\\")\\n\",\n    \"        \\n\",\n    \"        results.append({\\n\",\n    \"            \\\"prediction\\\": prediction,\\n\",\n    \"            \\\"expensive_result\\\": expensive_result\\n\",\n    \"        })\\n\",\n    \"    \\n\",\n    \"    # Show performance summary\\n\",\n    \"    summary = monitor.get_summary()\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n📈 Performance Summary:\\\")\\n\",\n    \"    for metric, stats in summary.items():\\n\",\n    \"        if isinstance(stats, dict) and 'avg' in stats:\\n\",\n    \"            print(f\\\"  {metric}: avg={stats['avg']:.4f}s, min={stats['min']:.4f}s, max={stats['max']:.4f}s, count={stats['count']}\\\")\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n🔢 Counters: {summary.get('counters', {})}\\\")\\n\",\n    \"    \\n\",\n    \"    # Cache performance\\n\",\n    \"    cache_info = cached_expensive_computation.cache_info()\\n\",\n    \"    print(f\\\"\\\\n💾 Cache performance: {cache_info}\\\")\\n\",\n    \"    \\n\",\n    \"    # Profile memory usage of different operations\\n\",\n    \"    print(f\\\"\\\\n🧠 Memory profiling different operations:\\\")\\n\",\n    \"    \\n\",\n    \"    with profile_memory(\\\"Large list creation\\\"):\\n\",\n    \"        large_list = [i for i in range(100000)]\\n\",\n    \"    \\n\",\n    \"    with profile_memory(\\\"Dictionary creation\\\"):\\n\",\n    \"        large_dict = {f\\\"key_{i}\\\": i for i in range(10000)}\\n\",\n    \"    \\n\",\n    \"    with profile_memory(\\\"NumPy array creation\\\"):\\n\",\n    \"        large_array = np.arange(100000)\\n\",\n    \"    \\n\",\n    \"    # Clean up\\n\",\n    \"    del large_list, large_dict, large_array\\n\",\n    \"    gc.collect()\\n\",\n    \"\\n\",\n    \"# Advanced profiling with cProfile\\n\",\n    \"def demonstrate_cprofile():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate cProfile usage.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n⚡ Advanced profiling with cProfile:\\\")\\n\",\n    \"    \\n\",\n    \"    def profile_target():\\n\",\n    \"        \\\"\\\"\\\"Function to profile.\\\"\\\"\\\"\\n\",\n    \"        data = simulate_data_loading(500)\\n\",\n    \"        \\n\",\n    \"        results = []\\n\",\n    \"        for item in data[:50]:\\n\",\n    \"            features = simulate_feature_extraction(item)\\n\",\n    \"            prediction = simulate_model_inference(features)\\n\",\n    \"            results.append(prediction)\\n\",\n    \"        \\n\",\n    \"        return results\\n\",\n    \"    \\n\",\n    \"    # Profile with cProfile\\n\",\n    \"    profiler = cProfile.Profile()\\n\",\n    \"    profiler.enable()\\n\",\n    \"    \\n\",\n    \"    start_time = time.perf_counter()\\n\",\n    \"    results = profile_target()\\n\",\n    \"    duration = time.perf_counter() - start_time\\n\",\n    \"    \\n\",\n    \"    profiler.disable()\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Processed {len(results)} items in {duration:.4f}s\\\")\\n\",\n    \"    print(f\\\"  Rate: {len(results) / duration:.1f} items/second\\\")\\n\",\n    \"    \\n\",\n    \"    # Analyze profiling results\\n\",\n    \"    stats = pstats.Stats(profiler)\\n\",\n    \"    stats.sort_stats('cumulative')\\n\",\n    \"    \\n\",\n    \"    # Get top functions by cumulative time\\n\",\n    \"    print(f\\\"\\\\n📊 Top functions by cumulative time:\\\")\\n\",\n    \"    stats.print_stats(10)  # Top 10 functions\\n\",\n    \"\\n\",\n    \"# Benchmark different approaches\\n\",\n    \"def demonstrate_benchmarking():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate benchmarking different approaches.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n🏁 Benchmarking different approaches:\\\")\\n\",\n    \"    \\n\",\n    \"    data = list(range(10000))\\n\",\n    \"    \\n\",\n    \"    # Different ways to process data\\n\",\n    \"    def approach_1_loop(data):\\n\",\n    \"        \\\"\\\"\\\"Traditional loop.\\\"\\\"\\\"\\n\",\n    \"        result = []\\n\",\n    \"        for item in data:\\n\",\n    \"            result.append(item * 2)\\n\",\n    \"        return result\\n\",\n    \"    \\n\",\n    \"    def approach_2_comprehension(data):\\n\",\n    \"        \\\"\\\"\\\"List comprehension.\\\"\\\"\\\"\\n\",\n    \"        return [item * 2 for item in data]\\n\",\n    \"    \\n\",\n    \"    def approach_3_map(data):\\n\",\n    \"        \\\"\\\"\\\"Map function.\\\"\\\"\\\"\\n\",\n    \"        return list(map(lambda x: x * 2, data))\\n\",\n    \"    \\n\",\n    \"    def approach_4_numpy(data):\\n\",\n    \"        \\\"\\\"\\\"NumPy vectorized.\\\"\\\"\\\"\\n\",\n    \"        arr = np.array(data)\\n\",\n    \"        return (arr * 2).tolist()\\n\",\n    \"    \\n\",\n    \"    # Benchmark all approaches\\n\",\n    \"    approaches = [\\n\",\n    \"        (\\\"Traditional loop\\\", approach_1_loop),\\n\",\n    \"        (\\\"List comprehension\\\", approach_2_comprehension),\\n\",\n    \"        (\\\"Map function\\\", approach_3_map),\\n\",\n    \"        (\\\"NumPy vectorized\\\", approach_4_numpy)\\n\",\n    \"    ]\\n\",\n    \"    \\n\",\n    \"    compare_performance(approaches, data)\\n\",\n    \"\\n\",\n    \"# Run profiling demonstrations\\n\",\n    \"demonstrate_profiling()\\n\",\n    \"demonstrate_cprofile()\\n\",\n    \"demonstrate_benchmarking()\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Profiling Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Identifies performance bottlenecks\\\")\\n\",\n    \"print(f\\\"  ✅ Measures memory usage accurately\\\")\\n\",\n    \"print(f\\\"  ✅ Tracks cache effectiveness\\\")\\n\",\n    \"print(f\\\"  ✅ Compares different approaches objectively\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 4: Vectorized Operations with NumPy\\n\",\n    \"\\n\",\n    \"**First Principle**: Vectorized operations eliminate Python loops and leverage optimized C code for massive speedups.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use NumPy arrays and vectorized functions instead of Python loops for numerical computations.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class VectorizedTextProcessor:\\n\",\n    \"    \\\"\\\"\\\"Text processor using vectorized operations.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def batch_tokenize(texts: List[str]) -> List[List[str]]:\\n\",\n    \"        \\\"\\\"\\\"Vectorized tokenization.\\\"\\\"\\\"\\n\",\n    \"        # This is still Python-level, but demonstrates batch processing\\n\",\n    \"        return [text.lower().split() for text in texts]\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def batch_compute_lengths(texts: List[str]) -> np.ndarray:\\n\",\n    \"        \\\"\\\"\\\"Compute text lengths using NumPy.\\\"\\\"\\\"\\n\",\n    \"        return np.array([len(text) for text in texts])\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def batch_filter_by_length(texts: List[str], min_length: int) -> List[str]:\\n\",\n    \"        \\\"\\\"\\\"Filter texts by length using vectorized operations.\\\"\\\"\\\"\\n\",\n    \"        lengths = VectorizedTextProcessor.batch_compute_lengths(texts)\\n\",\n    \"        mask = lengths >= min_length\\n\",\n    \"        return [text for text, keep in zip(texts, mask) if keep]\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def batch_similarity_matrix(texts: List[str]) -> np.ndarray:\\n\",\n    \"        \\\"\\\"\\\"Compute similarity matrix using vectorized operations.\\\"\\\"\\\"\\n\",\n    \"        n = len(texts)\\n\",\n    \"        \\n\",\n    \"        # Get lengths as vectors\\n\",\n    \"        lengths = VectorizedTextProcessor.batch_compute_lengths(texts)\\n\",\n    \"        \\n\",\n    \"        # Compute pairwise length differences using broadcasting\\n\",\n    \"        length_diff = np.abs(lengths[:, np.newaxis] - lengths[np.newaxis, :])\\n\",\n    \"        \\n\",\n    \"        # Similarity based on length difference (simplified)\\n\",\n    \"        similarity = 1.0 / (1.0 + length_diff)\\n\",\n    \"        \\n\",\n    \"        # Set diagonal to 1.0 (self-similarity)\\n\",\n    \"        np.fill_diagonal(similarity, 1.0)\\n\",\n    \"        \\n\",\n    \"        return similarity\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def compute_text_features(texts: List[str]) -> np.ndarray:\\n\",\n    \"        \\\"\\\"\\\"Compute multiple text features efficiently.\\\"\\\"\\\"\\n\",\n    \"        n = len(texts)\\n\",\n    \"        features = np.zeros((n, 4))  # 4 features per text\\n\",\n    \"        \\n\",\n    \"        for i, text in enumerate(texts):\\n\",\n    \"            words = text.split()\\n\",\n    \"            features[i, 0] = len(text)  # Character count\\n\",\n    \"            features[i, 1] = len(words)  # Word count\\n\",\n    \"            features[i, 2] = len(set(words)) if words else 0  # Unique words\\n\",\n    \"            features[i, 3] = sum(len(word) for word in words) / len(words) if words else 0  # Avg word length\\n\",\n    \"        \\n\",\n    \"        return features\\n\",\n    \"\\n\",\n    \"def demonstrate_vectorization():\\n\",\n    \"    \\\"\\\"\\\"Show vectorized operations.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    console.print(Panel(\\\"⚡ Vectorized Operations\\\", style=\\\"bold magenta\\\"))\\n\",\n    \"    \\n\",\n    \"    # Create test data\\n\",\n    \"    test_texts = [f\\\"Sample text number {i} for vectorized processing analysis\\\" for i in range(1000)]\\n\",\n    \"    \\n\",\n    \"    print(\\\"📊 Comparing scalar vs vectorized operations:\\\")\\n\",\n    \"    \\n\",\n    \"    # Scalar operations (Python loops)\\n\",\n    \"    with profile_time(\\\"Scalar length computation\\\"):\\n\",\n    \"        scalar_lengths = [len(text) for text in test_texts]\\n\",\n    \"    \\n\",\n    \"    # Vectorized operations\\n\",\n    \"    with profile_time(\\\"Vectorized length computation\\\"):\\n\",\n    \"        vector_lengths = VectorizedTextProcessor.batch_compute_lengths(test_texts)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Results match: {np.array_equal(scalar_lengths, vector_lengths)}\\\")\\n\",\n    \"    \\n\",\n    \"    # Mathematical operations comparison\\n\",\n    \"    print(f\\\"\\\\n🔢 Mathematical operations comparison:\\\")\\n\",\n    \"    \\n\",\n    \"    data = list(range(100000))\\n\",\n    \"    \\n\",\n    \"    # Scalar math\\n\",\n    \"    with profile_time(\\\"Scalar math (sum of squares)\\\"):\\n\",\n    \"        scalar_result = sum(x*x for x in data)\\n\",\n    \"    \\n\",\n    \"    # Vectorized math\\n\",\n    \"    with profile_time(\\\"Vectorized math (sum of squares)\\\"):\\n\",\n    \"        arr = np.array(data)\\n\",\n    \"        vector_result = np.sum(arr**2)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Results match: {scalar_result == vector_result}\\\")\\n\",\n    \"    \\n\",\n    \"    # Complex vectorized operations\\n\",\n    \"    print(f\\\"\\\\n🧮 Complex vectorized operations:\\\")\\n\",\n    \"    \\n\",\n    \"    # Text feature extraction\\n\",\n    \"    sample_texts = test_texts[:100]\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Feature extraction\\\"):\\n\",\n    \"        features = VectorizedTextProcessor.compute_text_features(sample_texts)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Extracted features for {len(sample_texts)} texts\\\")\\n\",\n    \"    print(f\\\"  Feature matrix shape: {features.shape}\\\")\\n\",\n    \"    print(f\\\"  Average features: {np.mean(features, axis=0)}\\\")\\n\",\n    \"    \\n\",\n    \"    # Similarity matrix computation\\n\",\n    \"    small_sample = test_texts[:20]\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Similarity matrix computation\\\"):\\n\",\n    \"        similarity_matrix = VectorizedTextProcessor.batch_similarity_matrix(small_sample)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Similarity matrix shape: {similarity_matrix.shape}\\\")\\n\",\n    \"    print(f\\\"  Average similarity: {np.mean(similarity_matrix[similarity_matrix != 1.0]):.3f}\\\")\\n\",\n    \"    \\n\",\n    \"    # Broadcasting examples\\n\",\n    \"    print(f\\\"\\\\n📡 Broadcasting examples:\\\")\\n\",\n    \"    \\n\",\n    \"    # Create sample matrices\\n\",\n    \"    matrix_a = np.random.rand(1000, 50)\\n\",\n    \"    matrix_b = np.random.rand(50)\\n\",\n    \"    \\n\",\n    \"    # Broadcasting operation\\n\",\n    \"    with profile_time(\\\"Broadcasting operation (1000x50 + 50)\\\"):\\n\",\n    \"        result = matrix_a + matrix_b  # Broadcasting automatically applied\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Result shape: {result.shape}\\\")\\n\",\n    \"    \\n\",\n    \"    # Element-wise operations\\n\",\n    \"    large_array = np.random.rand(100000)\\n\",\n    \"    \\n\",\n    \"    operations = [\\n\",\n    \"        (\\\"Square\\\", lambda x: x**2),\\n\",\n    \"        (\\\"Square root\\\", lambda x: np.sqrt(x)),\\n\",\n    \"        (\\\"Exponential\\\", lambda x: np.exp(x)),\\n\",\n    \"        (\\\"Logarithm\\\", lambda x: np.log(x + 1e-8)),  # Add small value to avoid log(0)\\n\",\n    \"        (\\\"Trigonometric\\\", lambda x: np.sin(x) + np.cos(x))\\n\",\n    \"    ]\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n⚡ Element-wise operations on {len(large_array)} elements:\\\")\\n\",\n    \"    \\n\",\n    \"    for name, operation in operations:\\n\",\n    \"        with profile_time(f\\\"{name} operation\\\"):\\n\",\n    \"            result = operation(large_array)\\n\",\n    \"        print(f\\\"  {name}: min={np.min(result):.3f}, max={np.max(result):.3f}, mean={np.mean(result):.3f}\\\")\\n\",\n    \"\\n\",\n    \"# Advanced vectorization patterns\\n\",\n    \"def demonstrate_advanced_vectorization():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate advanced vectorization patterns.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n🚀 Advanced vectorization patterns:\\\")\\n\",\n    \"    \\n\",\n    \"    # Conditional operations with where\\n\",\n    \"    data = np.random.randn(10000)\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Conditional operations with np.where\\\"):\\n\",\n    \"        # Replace negative values with 0, keep positive\\n\",\n    \"        result = np.where(data > 0, data, 0)\\n\",\n    \"    \\n\",\n    \"    positive_count = np.sum(result > 0)\\n\",\n    \"    print(f\\\"  Positive values: {positive_count}/{len(data)}\\\")\\n\",\n    \"    \\n\",\n    \"    # Vectorized string operations\\n\",\n    \"    text_data = np.array([f\\\"text_{i}\\\" for i in range(1000)])\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Vectorized string operations\\\"):\\n\",\n    \"        # Vectorized string length\\n\",\n    \"        str_lengths = np.char.str_len(text_data)\\n\",\n    \"        # Vectorized string operations\\n\",\n    \"        upper_texts = np.char.upper(text_data)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  String operations completed on {len(text_data)} strings\\\")\\n\",\n    \"    \\n\",\n    \"    # Aggregation operations\\n\",\n    \"    matrix = np.random.rand(1000, 100)\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Matrix aggregations\\\"):\\n\",\n    \"        row_sums = np.sum(matrix, axis=1)  # Sum each row\\n\",\n    \"        col_means = np.mean(matrix, axis=0)  # Mean of each column\\n\",\n    \"        global_std = np.std(matrix)  # Standard deviation of entire matrix\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Row sums: {len(row_sums)}, Col means: {len(col_means)}, Global std: {global_std:.3f}\\\")\\n\",\n    \"    \\n\",\n    \"    # Fancy indexing\\n\",\n    \"    large_data = np.random.rand(100000)\\n\",\n    \"    indices = np.random.randint(0, len(large_data), 10000)\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Fancy indexing\\\"):\\n\",\n    \"        selected_data = large_data[indices]\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Selected {len(selected_data)} elements using fancy indexing\\\")\\n\",\n    \"    \\n\",\n    \"    # Boolean indexing\\n\",\n    \"    with profile_time(\\\"Boolean indexing\\\"):\\n\",\n    \"        filtered_data = large_data[large_data > 0.5]\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Filtered to {len(filtered_data)} elements using boolean indexing\\\")\\n\",\n    \"\\n\",\n    \"# Memory layout optimization\\n\",\n    \"def demonstrate_memory_layout():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate memory layout optimization.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n💾 Memory layout optimization:\\\")\\n\",\n    \"    \\n\",\n    \"    # C-contiguous vs Fortran-contiguous\\n\",\n    \"    size = (1000, 1000)\\n\",\n    \"    \\n\",\n    \"    c_array = np.random.rand(*size)  # C-contiguous (row-major)\\n\",\n    \"    f_array = np.asfortranarray(c_array)  # Fortran-contiguous (column-major)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  C-array is C-contiguous: {c_array.flags.c_contiguous}\\\")\\n\",\n    \"    print(f\\\"  F-array is Fortran-contiguous: {f_array.flags.f_contiguous}\\\")\\n\",\n    \"    \\n\",\n    \"    # Row-wise operations (faster on C-contiguous)\\n\",\n    \"    with profile_time(\\\"Row-wise sum on C-contiguous\\\"):\\n\",\n    \"        c_row_sums = np.sum(c_array, axis=1)\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Row-wise sum on F-contiguous\\\"):\\n\",\n    \"        f_row_sums = np.sum(f_array, axis=1)\\n\",\n    \"    \\n\",\n    \"    # Column-wise operations (faster on Fortran-contiguous)\\n\",\n    \"    with profile_time(\\\"Column-wise sum on C-contiguous\\\"):\\n\",\n    \"        c_col_sums = np.sum(c_array, axis=0)\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Column-wise sum on F-contiguous\\\"):\\n\",\n    \"        f_col_sums = np.sum(f_array, axis=0)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Results are equal: {np.allclose(c_row_sums, f_row_sums) and np.allclose(c_col_sums, f_col_sums)}\\\")\\n\",\n    \"\\n\",\n    \"# Run vectorization demonstrations\\n\",\n    \"demonstrate_vectorization()\\n\",\n    \"demonstrate_advanced_vectorization()\\n\",\n    \"demonstrate_memory_layout()\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Vectorization Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ 10-100x speedup for numerical operations\\\")\\n\",\n    \"print(f\\\"  ✅ Memory-efficient operations\\\")\\n\",\n    \"print(f\\\"  ✅ Automatic parallelization in many cases\\\")\\n\",\n    \"print(f\\\"  ✅ Leverages optimized BLAS/LAPACK libraries\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 5: Parallel Processing Patterns\\n\",\n    \"\\n\",\n    \"**First Principle**: Parallel processing leverages multiple cores for CPU-bound tasks and multiple threads for I/O-bound tasks.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `ThreadPoolExecutor` for I/O-bound tasks, `ProcessPoolExecutor` for CPU-bound tasks.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class ParallelProcessor:\\n\",\n    \"    \\\"\\\"\\\"Utilities for parallel processing.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def parallel_map_threads(\\n\",\n    \"        func: Callable, \\n\",\n    \"        items: List[Any], \\n\",\n    \"        max_workers: int = 4\\n\",\n    \"    ) -> List[Any]:\\n\",\n    \"        \\\"\\\"\\\"Parallel map using threads (I/O bound tasks).\\\"\\\"\\\"\\n\",\n    \"        with ThreadPoolExecutor(max_workers=max_workers) as executor:\\n\",\n    \"            results = list(executor.map(func, items))\\n\",\n    \"        return results\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def parallel_map_processes(\\n\",\n    \"        func: Callable, \\n\",\n    \"        items: List[Any], \\n\",\n    \"        max_workers: int = None\\n\",\n    \"    ) -> List[Any]:\\n\",\n    \"        \\\"\\\"\\\"Parallel map using processes (CPU bound tasks).\\\"\\\"\\\"\\n\",\n    \"        if max_workers is None:\\n\",\n    \"            max_workers = mp.cpu_count()\\n\",\n    \"        \\n\",\n    \"        with ProcessPoolExecutor(max_workers=max_workers) as executor:\\n\",\n    \"            results = list(executor.map(func, items))\\n\",\n    \"        return results\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def parallel_batch_process(\\n\",\n    \"        items: List[Any], \\n\",\n    \"        batch_func: Callable[[List[Any]], List[Any]], \\n\",\n    \"        batch_size: int = 100,\\n\",\n    \"        max_workers: int = 4,\\n\",\n    \"        use_processes: bool = False\\n\",\n    \"    ) -> List[Any]:\\n\",\n    \"        \\\"\\\"\\\"Process items in parallel batches.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        # Split into batches\\n\",\n    \"        batches = [items[i:i + batch_size] for i in range(0, len(items), batch_size)]\\n\",\n    \"        \\n\",\n    \"        # Process batches in parallel\\n\",\n    \"        if use_processes:\\n\",\n    \"            with ProcessPoolExecutor(max_workers=max_workers) as executor:\\n\",\n    \"                batch_results = list(executor.map(batch_func, batches))\\n\",\n    \"        else:\\n\",\n    \"            with ThreadPoolExecutor(max_workers=max_workers) as executor:\\n\",\n    \"                batch_results = list(executor.map(batch_func, batches))\\n\",\n    \"        \\n\",\n    \"        # Flatten results\\n\",\n    \"        results = []\\n\",\n    \"        for batch_result in batch_results:\\n\",\n    \"            results.extend(batch_result)\\n\",\n    \"        \\n\",\n    \"        return results\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def parallel_as_completed(\\n\",\n    \"        func: Callable,\\n\",\n    \"        items: List[Any],\\n\",\n    \"        max_workers: int = 4,\\n\",\n    \"        use_processes: bool = False\\n\",\n    \"    ) -> Iterator[Tuple[Any, Any]]:\\n\",\n    \"        \\\"\\\"\\\"Process items in parallel, yielding results as they complete.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        executor_class = ProcessPoolExecutor if use_processes else ThreadPoolExecutor\\n\",\n    \"        \\n\",\n    \"        with executor_class(max_workers=max_workers) as executor:\\n\",\n    \"            # Submit all tasks\\n\",\n    \"            future_to_item = {executor.submit(func, item): item for item in items}\\n\",\n    \"            \\n\",\n    \"            # Yield results as they complete\\n\",\n    \"            for future in as_completed(future_to_item):\\n\",\n    \"                item = future_to_item[future]\\n\",\n    \"                try:\\n\",\n    \"                    result = future.result()\\n\",\n    \"                    yield item, result\\n\",\n    \"                except Exception as exc:\\n\",\n    \"                    yield item, exc\\n\",\n    \"\\n\",\n    \"# Example functions for parallel processing\\n\",\n    \"def cpu_intensive_task(data: str) -> str:\\n\",\n    \"    \\\"\\\"\\\"CPU-intensive task for parallel processing demo.\\\"\\\"\\\"\\n\",\n    \"    # Simulate CPU work with hashing\\n\",\n    \"    result = data\\n\",\n    \"    for _ in range(10000):  # Increased iterations for more CPU work\\n\",\n    \"        result = str(hash(result))[:10]\\n\",\n    \"    return f\\\"CPU_PROCESSED: {result}\\\"\\n\",\n    \"\\n\",\n    \"def io_intensive_task(data: str) -> str:\\n\",\n    \"    \\\"\\\"\\\"I/O-intensive task for parallel processing demo.\\\"\\\"\\\"\\n\",\n    \"    # Simulate I/O wait\\n\",\n    \"    time.sleep(0.1)\\n\",\n    \"    return f\\\"IO_PROCESSED: {data.upper()}\\\"\\n\",\n    \"\\n\",\n    \"def mixed_workload_task(data: str) -> str:\\n\",\n    \"    \\\"\\\"\\\"Mixed CPU and I/O task.\\\"\\\"\\\"\\n\",\n    \"    # CPU work\\n\",\n    \"    result = str(hash(data * 1000))\\n\",\n    \"    # I/O simulation\\n\",\n    \"    time.sleep(0.02)\\n\",\n    \"    return f\\\"MIXED: {result[:8]}\\\"\\n\",\n    \"\\n\",\n    \"def batch_text_processor(texts: List[str]) -> List[str]:\\n\",\n    \"    \\\"\\\"\\\"Process a batch of texts efficiently.\\\"\\\"\\\"\\n\",\n    \"    # Simulate batch processing efficiency\\n\",\n    \"    time.sleep(0.01)  # Setup overhead per batch\\n\",\n    \"    \\n\",\n    \"    results = []\\n\",\n    \"    for text in texts:\\n\",\n    \"        # Faster per-item processing in batch\\n\",\n    \"        processed = text.upper().replace(\\\" \\\", \\\"_\\\")\\n\",\n    \"        results.append(f\\\"BATCH_{processed}\\\")\\n\",\n    \"    \\n\",\n    \"    return results\\n\",\n    \"\\n\",\n    \"def demonstrate_parallel_processing():\\n\",\n    \"    \\\"\\\"\\\"Show parallel processing patterns.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    console.print(Panel(\\\"🚀 Parallel Processing\\\", style=\\\"bold cyan\\\"))\\n\",\n    \"    \\n\",\n    \"    # Create test data\\n\",\n    \"    test_data = [f\\\"data_item_{i}\\\" for i in range(20)]\\n\",\n    \"    \\n\",\n    \"    print(\\\"⚙️ Comparing sequential vs parallel processing:\\\")\\n\",\n    \"    \\n\",\n    \"    # CPU-bound task comparison\\n\",\n    \"    print(f\\\"\\\\n🧮 CPU-bound tasks:\\\")\\n\",\n    \"    \\n\",\n    \"    # Sequential processing\\n\",\n    \"    with profile_time(\\\"Sequential CPU processing\\\"):\\n\",\n    \"        sequential_cpu_results = [cpu_intensive_task(item) for item in test_data[:8]]  # Smaller subset\\n\",\n    \"    \\n\",\n    \"    # Parallel processing with processes\\n\",\n    \"    with profile_time(\\\"Parallel CPU processing (processes)\\\"):\\n\",\n    \"        parallel_cpu_results = ParallelProcessor.parallel_map_processes(\\n\",\n    \"            cpu_intensive_task, test_data[:8], max_workers=2\\n\",\n    \"        )\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Results match: {sequential_cpu_results == parallel_cpu_results}\\\")\\n\",\n    \"    print(f\\\"  Processed {len(parallel_cpu_results)} items\\\")\\n\",\n    \"    \\n\",\n    \"    # I/O-bound task comparison\\n\",\n    \"    print(f\\\"\\\\n💾 I/O-bound tasks:\\\")\\n\",\n    \"    \\n\",\n    \"    # Sequential I/O\\n\",\n    \"    with profile_time(\\\"Sequential I/O processing\\\"):\\n\",\n    \"        sequential_io_results = [io_intensive_task(item) for item in test_data[:10]]\\n\",\n    \"    \\n\",\n    \"    # Parallel I/O with threads\\n\",\n    \"    with profile_time(\\\"Parallel I/O processing (threads)\\\"):\\n\",\n    \"        parallel_io_results = ParallelProcessor.parallel_map_threads(\\n\",\n    \"            io_intensive_task, test_data[:10], max_workers=5\\n\",\n    \"        )\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Results match: {set(sequential_io_results) == set(parallel_io_results)}\\\")\\n\",\n    \"    print(f\\\"  Processed {len(parallel_io_results)} items\\\")\\n\",\n    \"    \\n\",\n    \"    # Batch processing comparison\\n\",\n    \"    print(f\\\"\\\\n📦 Batch processing:\\\")\\n\",\n    \"    \\n\",\n    \"    large_dataset = [f\\\"text_{i}\\\" for i in range(100)]\\n\",\n    \"    \\n\",\n    \"    # Individual processing\\n\",\n    \"    with profile_time(\\\"Individual processing\\\"):\\n\",\n    \"        individual_results = [item.upper().replace(\\\" \\\", \\\"_\\\") for item in large_dataset]\\n\",\n    \"    \\n\",\n    \"    # Batch processing\\n\",\n    \"    with profile_time(\\\"Parallel batch processing\\\"):\\n\",\n    \"        batch_results = ParallelProcessor.parallel_batch_process(\\n\",\n    \"            large_dataset, batch_text_processor, batch_size=20, max_workers=3\\n\",\n    \"        )\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Individual results: {len(individual_results)}\\\")\\n\",\n    \"    print(f\\\"  Batch results: {len(batch_results)}\\\")\\n\",\n    \"    \\n\",\n    \"    # Progressive results with as_completed\\n\",\n    \"    print(f\\\"\\\\n⏱️ Progressive results (as_completed pattern):\\\")\\n\",\n    \"    \\n\",\n    \"    mixed_data = [f\\\"mixed_{i}\\\" for i in range(8)]\\n\",\n    \"    \\n\",\n    \"    start_time = time.time()\\n\",\n    \"    completed_count = 0\\n\",\n    \"    \\n\",\n    \"    for item, result in ParallelProcessor.parallel_as_completed(\\n\",\n    \"        mixed_workload_task, mixed_data, max_workers=3\\n\",\n    \"    ):\\n\",\n    \"        completed_count += 1\\n\",\n    \"        elapsed = time.time() - start_time\\n\",\n    \"        \\n\",\n    \"        if isinstance(result, Exception):\\n\",\n    \"            print(f\\\"  {elapsed:.2f}s: {item} FAILED - {result}\\\")\\n\",\n    \"        else:\\n\",\n    \"            print(f\\\"  {elapsed:.2f}s: {item} -> {result[:20]}...\\\")\\n\",\n    \"    \\n\",\n    \"    total_time = time.time() - start_time\\n\",\n    \"    print(f\\\"  Completed {completed_count} tasks in {total_time:.2f}s\\\")\\n\",\n    \"\\n\",\n    \"# Advanced parallel patterns\\n\",\n    \"def demonstrate_advanced_parallel_patterns():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate advanced parallel processing patterns.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n🎯 Advanced parallel patterns:\\\")\\n\",\n    \"    \\n\",\n    \"    # Map-Reduce pattern\\n\",\n    \"    def map_phase(data_chunk: List[int]) -> Dict[str, int]:\\n\",\n    \"        \\\"\\\"\\\"Map phase: process chunk and return key-value pairs.\\\"\\\"\\\"\\n\",\n    \"        result = {\\\"even\\\": 0, \\\"odd\\\": 0, \\\"sum\\\": 0}\\n\",\n    \"        for num in data_chunk:\\n\",\n    \"            if num % 2 == 0:\\n\",\n    \"                result[\\\"even\\\"] += 1\\n\",\n    \"            else:\\n\",\n    \"                result[\\\"odd\\\"] += 1\\n\",\n    \"            result[\\\"sum\\\"] += num\\n\",\n    \"        return result\\n\",\n    \"    \\n\",\n    \"    def reduce_phase(results: List[Dict[str, int]]) -> Dict[str, int]:\\n\",\n    \"        \\\"\\\"\\\"Reduce phase: combine results from all workers.\\\"\\\"\\\"\\n\",\n    \"        final_result = {\\\"even\\\": 0, \\\"odd\\\": 0, \\\"sum\\\": 0}\\n\",\n    \"        for result in results:\\n\",\n    \"            for key in final_result:\\n\",\n    \"                final_result[key] += result[key]\\n\",\n    \"        return final_result\\n\",\n    \"    \\n\",\n    \"    # Generate test data\\n\",\n    \"    large_numbers = list(range(10000))\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Map-Reduce pattern\\\"):\\n\",\n    \"        # Split data into chunks\\n\",\n    \"        chunk_size = 1000\\n\",\n    \"        chunks = [large_numbers[i:i + chunk_size] for i in range(0, len(large_numbers), chunk_size)]\\n\",\n    \"        \\n\",\n    \"        # Map phase (parallel)\\n\",\n    \"        map_results = ParallelProcessor.parallel_map_processes(map_phase, chunks, max_workers=3)\\n\",\n    \"        \\n\",\n    \"        # Reduce phase (sequential)\\n\",\n    \"        final_result = reduce_phase(map_results)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Map-Reduce result: {final_result}\\\")\\n\",\n    \"    \\n\",\n    \"    # Pipeline pattern\\n\",\n    \"    print(f\\\"\\\\n🔄 Pipeline processing pattern:\\\")\\n\",\n    \"    \\n\",\n    \"    def stage1_preprocess(data: str) -> str:\\n\",\n    \"        \\\"\\\"\\\"Stage 1: Preprocessing.\\\"\\\"\\\"\\n\",\n    \"        time.sleep(0.01)\\n\",\n    \"        return f\\\"PREPROCESSED_{data}\\\"\\n\",\n    \"    \\n\",\n    \"    def stage2_analyze(data: str) -> str:\\n\",\n    \"        \\\"\\\"\\\"Stage 2: Analysis.\\\"\\\"\\\"\\n\",\n    \"        time.sleep(0.02)\\n\",\n    \"        return f\\\"ANALYZED_{data}\\\"\\n\",\n    \"    \\n\",\n    \"    def stage3_postprocess(data: str) -> str:\\n\",\n    \"        \\\"\\\"\\\"Stage 3: Post-processing.\\\"\\\"\\\"\\n\",\n    \"        time.sleep(0.01)\\n\",\n    \"        return f\\\"FINAL_{data}\\\"\\n\",\n    \"    \\n\",\n    \"    pipeline_data = [f\\\"item_{i}\\\" for i in range(20)]\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Sequential pipeline\\\"):\\n\",\n    \"        # Sequential pipeline\\n\",\n    \"        stage1_results = [stage1_preprocess(item) for item in pipeline_data]\\n\",\n    \"        stage2_results = [stage2_analyze(item) for item in stage1_results]\\n\",\n    \"        stage3_results = [stage3_postprocess(item) for item in stage2_results]\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Parallel pipeline\\\"):\\n\",\n    \"        # Parallel pipeline\\n\",\n    \"        stage1_parallel = ParallelProcessor.parallel_map_threads(stage1_preprocess, pipeline_data, max_workers=3)\\n\",\n    \"        stage2_parallel = ParallelProcessor.parallel_map_threads(stage2_analyze, stage1_parallel, max_workers=3)\\n\",\n    \"        stage3_parallel = ParallelProcessor.parallel_map_threads(stage3_postprocess, stage2_parallel, max_workers=3)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Sequential pipeline: {len(stage3_results)} items\\\")\\n\",\n    \"    print(f\\\"  Parallel pipeline: {len(stage3_parallel)} items\\\")\\n\",\n    \"    \\n\",\n    \"    # Worker pool with different task types\\n\",\n    \"    print(f\\\"\\\\n👥 Mixed workload distribution:\\\")\\n\",\n    \"    \\n\",\n    \"    # Create mixed tasks\\n\",\n    \"    cpu_tasks = [(\\\"cpu\\\", f\\\"cpu_task_{i}\\\") for i in range(4)]\\n\",\n    \"    io_tasks = [(\\\"io\\\", f\\\"io_task_{i}\\\") for i in range(8)]\\n\",\n    \"    all_tasks = cpu_tasks + io_tasks\\n\",\n    \"    \\n\",\n    \"    def process_mixed_task(task_info: Tuple[str, str]) -> str:\\n\",\n    \"        task_type, data = task_info\\n\",\n    \"        if task_type == \\\"cpu\\\":\\n\",\n    \"            return cpu_intensive_task(data)\\n\",\n    \"        else:\\n\",\n    \"            return io_intensive_task(data)\\n\",\n    \"    \\n\",\n    \"    # Process with appropriate parallelization\\n\",\n    \"    with profile_time(\\\"Mixed workload processing\\\"):\\n\",\n    \"        # Separate CPU and I/O tasks\\n\",\n    \"        cpu_results = ParallelProcessor.parallel_map_processes(\\n\",\n    \"            process_mixed_task, cpu_tasks, max_workers=2\\n\",\n    \"        )\\n\",\n    \"        io_results = ParallelProcessor.parallel_map_threads(\\n\",\n    \"            process_mixed_task, io_tasks, max_workers=4\\n\",\n    \"        )\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  CPU tasks completed: {len(cpu_results)}\\\")\\n\",\n    \"    print(f\\\"  I/O tasks completed: {len(io_results)}\\\")\\n\",\n    \"\\n\",\n    \"# System information\\n\",\n    \"def show_system_info():\\n\",\n    \"    \\\"\\\"\\\"Show system information for parallel processing.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n💻 System Information:\\\")\\n\",\n    \"    print(f\\\"  CPU cores: {mp.cpu_count()}\\\")\\n\",\n    \"    print(f\\\"  Active threads: {threading.active_count()}\\\")\\n\",\n    \"    print(f\\\"  Current process ID: {mp.current_process().pid}\\\")\\n\",\n    \"\\n\",\n    \"# Run parallel processing demonstrations\\n\",\n    \"show_system_info()\\n\",\n    \"demonstrate_parallel_processing()\\n\",\n    \"demonstrate_advanced_parallel_patterns()\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Parallel Processing Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Utilizes multiple CPU cores\\\")\\n\",\n    \"print(f\\\"  ✅ Overlaps I/O operations\\\")\\n\",\n    \"print(f\\\"  ✅ Scales with available hardware\\\")\\n\",\n    \"print(f\\\"  ✅ Improves throughput for batch operations\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 6: Production Performance System\\n\",\n    \"\\n\",\n    \"**First Principle**: Combine all performance techniques to create a comprehensive, optimized AI processing system.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use composition of optimized components to build high-performance systems.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Complete high-performance AI processing system\\n\",\n    \"from dataclasses import dataclass, field\\n\",\n    \"from typing import Union\\n\",\n    \"import pickle\\n\",\n    \"import hashlib\\n\",\n    \"import os\\n\",\n    \"\\n\",\n    \"@dataclass\\n\",\n    \"class PerformanceConfig:\\n\",\n    \"    \\\"\\\"\\\"Configuration for performance optimization.\\\"\\\"\\\"\\n\",\n    \"    enable_caching: bool = True\\n\",\n    \"    cache_size: int = 1000\\n\",\n    \"    cache_ttl: float = 3600.0  # 1 hour\\n\",\n    \"    enable_parallel: bool = True\\n\",\n    \"    max_workers: int = 4\\n\",\n    \"    batch_size: int = 100\\n\",\n    \"    enable_vectorization: bool = True\\n\",\n    \"    memory_limit_mb: float = 500.0\\n\",\n    \"    enable_profiling: bool = False\\n\",\n    \"\\n\",\n    \"@dataclass\\n\",\n    \"class ProcessingResult:\\n\",\n    \"    \\\"\\\"\\\"Result from AI processing.\\\"\\\"\\\"\\n\",\n    \"    data: Any\\n\",\n    \"    processing_time: float\\n\",\n    \"    from_cache: bool = False\\n\",\n    \"    worker_id: Optional[str] = None\\n\",\n    \"    memory_used_mb: float = 0.0\\n\",\n    \"\\n\",\n    \"class HighPerformanceAIProcessor:\\n\",\n    \"    \\\"\\\"\\\"High-performance AI processor using all optimization techniques.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, config: PerformanceConfig):\\n\",\n    \"        self.config = config\\n\",\n    \"        \\n\",\n    \"        # Performance components\\n\",\n    \"        self.cache = MemoryEfficientCache(\\n\",\n    \"            max_size=config.cache_size,\\n\",\n    \"            max_memory_mb=config.memory_limit_mb * 0.5  # Use half memory limit for cache\\n\",\n    \"        ) if config.enable_caching else None\\n\",\n    \"        \\n\",\n    \"        self.monitor = PerformanceMonitor() if config.enable_profiling else None\\n\",\n    \"        \\n\",\n    \"        # Object pool for expensive resources\\n\",\n    \"        self.resource_pool = ObjectPool(\\n\",\n    \"            factory=lambda: {\\\"id\\\": f\\\"resource_{time.time()}\\\", \\\"data\\\": np.zeros(1000)},\\n\",\n    \"            max_size=config.max_workers\\n\",\n    \"        )\\n\",\n    \"        \\n\",\n    \"        # Processing statistics\\n\",\n    \"        self.stats = {\\n\",\n    \"            \\\"total_processed\\\": 0,\\n\",\n    \"            \\\"cache_hits\\\": 0,\\n\",\n    \"            \\\"cache_misses\\\": 0,\\n\",\n    \"            \\\"total_time\\\": 0.0,\\n\",\n    \"            \\\"parallel_batches\\\": 0,\\n\",\n    \"            \\\"vectorized_operations\\\": 0\\n\",\n    \"        }\\n\",\n    \"    \\n\",\n    \"    def _generate_cache_key(self, data: Any, operation: str) -> str:\\n\",\n    \"        \\\"\\\"\\\"Generate cache key for data and operation.\\\"\\\"\\\"\\n\",\n    \"        data_str = str(data) if len(str(data)) < 1000 else str(hash(str(data)))\\n\",\n    \"        return hashlib.md5(f\\\"{operation}_{data_str}\\\".encode()).hexdigest()\\n\",\n    \"    \\n\",\n    \"    def _check_cache(self, cache_key: str) -> Optional[ProcessingResult]:\\n\",\n    \"        \\\"\\\"\\\"Check if result is cached.\\\"\\\"\\\"\\n\",\n    \"        if not self.cache:\\n\",\n    \"            return None\\n\",\n    \"        \\n\",\n    \"        cached = self.cache.get(cache_key)\\n\",\n    \"        if cached:\\n\",\n    \"            self.stats[\\\"cache_hits\\\"] += 1\\n\",\n    \"            return ProcessingResult(\\n\",\n    \"                data=cached,\\n\",\n    \"                processing_time=0.0,\\n\",\n    \"                from_cache=True\\n\",\n    \"            )\\n\",\n    \"        \\n\",\n    \"        self.stats[\\\"cache_misses\\\"] += 1\\n\",\n    \"        return None\\n\",\n    \"    \\n\",\n    \"    def _store_cache(self, cache_key: str, result: Any):\\n\",\n    \"        \\\"\\\"\\\"Store result in cache.\\\"\\\"\\\"\\n\",\n    \"        if self.cache:\\n\",\n    \"            self.cache.put(cache_key, result)\\n\",\n    \"    \\n\",\n    \"    def process_single(self, data: Any, operation: str = \\\"default\\\") -> ProcessingResult:\\n\",\n    \"        \\\"\\\"\\\"Process a single item with full optimization.\\\"\\\"\\\"\\n\",\n    \"        start_time = time.perf_counter()\\n\",\n    \"        \\n\",\n    \"        # Check cache\\n\",\n    \"        cache_key = self._generate_cache_key(data, operation)\\n\",\n    \"        cached_result = self._check_cache(cache_key)\\n\",\n    \"        if cached_result:\\n\",\n    \"            return cached_result\\n\",\n    \"        \\n\",\n    \"        # Process with resource pooling\\n\",\n    \"        with self.resource_pool.borrow() as resource:\\n\",\n    \"            # Simulate AI processing based on operation\\n\",\n    \"            if operation == \\\"classify\\\":\\n\",\n    \"                result = self._classify(data, resource)\\n\",\n    \"            elif operation == \\\"vectorize\\\":\\n\",\n    \"                result = self._vectorize(data, resource)\\n\",\n    \"            elif operation == \\\"analyze\\\":\\n\",\n    \"                result = self._analyze(data, resource)\\n\",\n    \"            else:\\n\",\n    \"                result = self._default_process(data, resource)\\n\",\n    \"        \\n\",\n    \"        processing_time = time.perf_counter() - start_time\\n\",\n    \"        \\n\",\n    \"        # Store in cache\\n\",\n    \"        self._store_cache(cache_key, result)\\n\",\n    \"        \\n\",\n    \"        # Update statistics\\n\",\n    \"        self.stats[\\\"total_processed\\\"] += 1\\n\",\n    \"        self.stats[\\\"total_time\\\"] += processing_time\\n\",\n    \"        \\n\",\n    \"        if self.monitor:\\n\",\n    \"            self.monitor.record_time(operation, processing_time)\\n\",\n    \"        \\n\",\n    \"        return ProcessingResult(\\n\",\n    \"            data=result,\\n\",\n    \"            processing_time=processing_time,\\n\",\n    \"            from_cache=False,\\n\",\n    \"            worker_id=resource[\\\"id\\\"]\\n\",\n    \"        )\\n\",\n    \"    \\n\",\n    \"    def process_batch(self, data_list: List[Any], operation: str = \\\"default\\\") -> List[ProcessingResult]:\\n\",\n    \"        \\\"\\\"\\\"Process batch with parallel and vectorized optimization.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        if not self.config.enable_parallel or len(data_list) < self.config.batch_size:\\n\",\n    \"            # Sequential processing for small batches\\n\",\n    \"            return [self.process_single(data, operation) for data in data_list]\\n\",\n    \"        \\n\",\n    \"        # Parallel batch processing\\n\",\n    \"        def process_batch_chunk(chunk: List[Any]) -> List[ProcessingResult]:\\n\",\n    \"            return [self.process_single(data, operation) for data in chunk]\\n\",\n    \"        \\n\",\n    \"        start_time = time.perf_counter()\\n\",\n    \"        \\n\",\n    \"        results = ParallelProcessor.parallel_batch_process(\\n\",\n    \"            data_list,\\n\",\n    \"            process_batch_chunk,\\n\",\n    \"            batch_size=self.config.batch_size,\\n\",\n    \"            max_workers=self.config.max_workers,\\n\",\n    \"            use_processes=False  # Use threads for I/O-bound AI operations\\n\",\n    \"        )\\n\",\n    \"        \\n\",\n    \"        batch_time = time.perf_counter() - start_time\\n\",\n    \"        self.stats[\\\"parallel_batches\\\"] += 1\\n\",\n    \"        \\n\",\n    \"        if self.monitor:\\n\",\n    \"            self.monitor.record_time(f\\\"batch_{operation}\\\", batch_time)\\n\",\n    \"        \\n\",\n    \"        return results\\n\",\n    \"    \\n\",\n    \"    def process_vectorized(self, data_array: np.ndarray, operation: str = \\\"vectorized\\\") -> ProcessingResult:\\n\",\n    \"        \\\"\\\"\\\"Process data using vectorized operations.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        if not self.config.enable_vectorization:\\n\",\n    \"            # Fall back to element-wise processing\\n\",\n    \"            results = [self.process_single(item, operation) for item in data_array]\\n\",\n    \"            return ProcessingResult(\\n\",\n    \"                data=[r.data for r in results],\\n\",\n    \"                processing_time=sum(r.processing_time for r in results),\\n\",\n    \"                from_cache=False\\n\",\n    \"            )\\n\",\n    \"        \\n\",\n    \"        start_time = time.perf_counter()\\n\",\n    \"        \\n\",\n    \"        # Vectorized processing\\n\",\n    \"        if operation == \\\"normalize\\\":\\n\",\n    \"            # Normalize data using vectorized operations\\n\",\n    \"            mean = np.mean(data_array, axis=0)\\n\",\n    \"            std = np.std(data_array, axis=0)\\n\",\n    \"            result = (data_array - mean) / (std + 1e-8)\\n\",\n    \"            \\n\",\n    \"        elif operation == \\\"similarity\\\":\\n\",\n    \"            # Compute pairwise similarities\\n\",\n    \"            result = np.dot(data_array, data_array.T)\\n\",\n    \"            \\n\",\n    \"        elif operation == \\\"transform\\\":\\n\",\n    \"            # Apply mathematical transformations\\n\",\n    \"            result = np.log(1 + np.abs(data_array))\\n\",\n    \"            \\n\",\n    \"        else:\\n\",\n    \"            # Default vectorized operation\\n\",\n    \"            result = data_array ** 2 + np.sin(data_array)\\n\",\n    \"        \\n\",\n    \"        processing_time = time.perf_counter() - start_time\\n\",\n    \"        \\n\",\n    \"        self.stats[\\\"vectorized_operations\\\"] += 1\\n\",\n    \"        self.stats[\\\"total_processed\\\"] += len(data_array)\\n\",\n    \"        self.stats[\\\"total_time\\\"] += processing_time\\n\",\n    \"        \\n\",\n    \"        if self.monitor:\\n\",\n    \"            self.monitor.record_time(f\\\"vectorized_{operation}\\\", processing_time)\\n\",\n    \"        \\n\",\n    \"        return ProcessingResult(\\n\",\n    \"            data=result,\\n\",\n    \"            processing_time=processing_time,\\n\",\n    \"            from_cache=False\\n\",\n    \"        )\\n\",\n    \"    \\n\",\n    \"    def _classify(self, data: Any, resource: Dict) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Simulate classification.\\\"\\\"\\\"\\n\",\n    \"        time.sleep(0.01)  # Simulate processing\\n\",\n    \"        confidence = hash(str(data)) % 100 / 100.0\\n\",\n    \"        return {\\n\",\n    \"            \\\"label\\\": \\\"positive\\\" if confidence > 0.5 else \\\"negative\\\",\\n\",\n    \"            \\\"confidence\\\": confidence,\\n\",\n    \"            \\\"resource_id\\\": resource[\\\"id\\\"]\\n\",\n    \"        }\\n\",\n    \"    \\n\",\n    \"    def _vectorize(self, data: Any, resource: Dict) -> List[float]:\\n\",\n    \"        \\\"\\\"\\\"Simulate vectorization.\\\"\\\"\\\"\\n\",\n    \"        time.sleep(0.005)\\n\",\n    \"        # Create feature vector\\n\",\n    \"        features = []\\n\",\n    \"        data_str = str(data)\\n\",\n    \"        for i in range(10):\\n\",\n    \"            features.append(hash(data_str + str(i)) % 1000 / 1000.0)\\n\",\n    \"        return features\\n\",\n    \"    \\n\",\n    \"    def _analyze(self, data: Any, resource: Dict) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Simulate analysis.\\\"\\\"\\\"\\n\",\n    \"        time.sleep(0.02)\\n\",\n    \"        data_str = str(data)\\n\",\n    \"        return {\\n\",\n    \"            \\\"length\\\": len(data_str),\\n\",\n    \"            \\\"complexity\\\": len(set(data_str)) / len(data_str) if data_str else 0,\\n\",\n    \"            \\\"hash_value\\\": hash(data_str),\\n\",\n    \"            \\\"resource_id\\\": resource[\\\"id\\\"]\\n\",\n    \"        }\\n\",\n    \"    \\n\",\n    \"    def _default_process(self, data: Any, resource: Dict) -> str:\\n\",\n    \"        \\\"\\\"\\\"Default processing.\\\"\\\"\\\"\\n\",\n    \"        time.sleep(0.001)\\n\",\n    \"        return f\\\"PROCESSED_{data}_{resource['id']}\\\"\\n\",\n    \"    \\n\",\n    \"    def get_performance_report(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get comprehensive performance report.\\\"\\\"\\\"\\n\",\n    \"        report = {\\n\",\n    \"            \\\"processing_stats\\\": self.stats.copy(),\\n\",\n    \"            \\\"cache_stats\\\": self.cache.get_stats() if self.cache else None,\\n\",\n    \"            \\\"resource_pool_stats\\\": self.resource_pool.get_stats(),\\n\",\n    \"            \\\"performance_summary\\\": {}\\n\",\n    \"        }\\n\",\n    \"        \\n\",\n    \"        # Calculate performance metrics\\n\",\n    \"        if self.stats[\\\"total_processed\\\"] > 0:\\n\",\n    \"            avg_time = self.stats[\\\"total_time\\\"] / self.stats[\\\"total_processed\\\"]\\n\",\n    \"            throughput = self.stats[\\\"total_processed\\\"] / self.stats[\\\"total_time\\\"] if self.stats[\\\"total_time\\\"] > 0 else 0\\n\",\n    \"            \\n\",\n    \"            report[\\\"performance_summary\\\"] = {\\n\",\n    \"                \\\"avg_processing_time\\\": avg_time,\\n\",\n    \"                \\\"throughput_items_per_sec\\\": throughput,\\n\",\n    \"                \\\"cache_hit_rate\\\": self.stats[\\\"cache_hits\\\"] / (self.stats[\\\"cache_hits\\\"] + self.stats[\\\"cache_misses\\\"]) if (self.stats[\\\"cache_hits\\\"] + self.stats[\\\"cache_misses\\\"]) > 0 else 0\\n\",\n    \"            }\\n\",\n    \"        \\n\",\n    \"        if self.monitor:\\n\",\n    \"            report[\\\"detailed_monitoring\\\"] = self.monitor.get_summary()\\n\",\n    \"        \\n\",\n    \"        return report\\n\",\n    \"    \\n\",\n    \"    def optimize_configuration(self) -> PerformanceConfig:\\n\",\n    \"        \\\"\\\"\\\"Suggest optimized configuration based on usage patterns.\\\"\\\"\\\"\\n\",\n    \"        current_config = self.config\\n\",\n    \"        \\n\",\n    \"        # Simple optimization heuristics\\n\",\n    \"        if self.cache and self.cache.get_stats()[\\\"hit_ratio\\\"] < 0.3:\\n\",\n    \"            # Low cache hit rate, increase cache size\\n\",\n    \"            current_config.cache_size = min(current_config.cache_size * 2, 5000)\\n\",\n    \"        \\n\",\n    \"        if self.stats[\\\"parallel_batches\\\"] > 10:\\n\",\n    \"            # Frequent parallel processing, optimize batch size\\n\",\n    \"            current_config.batch_size = max(current_config.batch_size // 2, 50)\\n\",\n    \"        \\n\",\n    \"        return current_config\\n\",\n    \"\\n\",\n    \"def demonstrate_production_system():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate the complete production performance system.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    console.print(Panel(\\\"🏭 Production Performance System\\\", style=\\\"bold green\\\"))\\n\",\n    \"    \\n\",\n    \"    # Create optimized configuration\\n\",\n    \"    config = PerformanceConfig(\\n\",\n    \"        enable_caching=True,\\n\",\n    \"        cache_size=500,\\n\",\n    \"        enable_parallel=True,\\n\",\n    \"        max_workers=3,\\n\",\n    \"        batch_size=50,\\n\",\n    \"        enable_vectorization=True,\\n\",\n    \"        memory_limit_mb=200.0,\\n\",\n    \"        enable_profiling=True\\n\",\n    \"    )\\n\",\n    \"    \\n\",\n    \"    processor = HighPerformanceAIProcessor(config)\\n\",\n    \"    \\n\",\n    \"    print(\\\"🚀 Testing high-performance AI processing:\\\")\\n\",\n    \"    \\n\",\n    \"    # Test 1: Single item processing with caching\\n\",\n    \"    print(f\\\"\\\\n📝 Single item processing (with caching):\\\")\\n\",\n    \"    \\n\",\n    \"    test_items = [\\\"test_item_1\\\", \\\"test_item_2\\\", \\\"test_item_1\\\"]  # Duplicate for cache test\\n\",\n    \"    \\n\",\n    \"    for item in test_items:\\n\",\n    \"        result = processor.process_single(item, \\\"classify\\\")\\n\",\n    \"        cache_status = \\\"CACHE HIT\\\" if result.from_cache else \\\"COMPUTED\\\"\\n\",\n    \"        print(f\\\"  {item}: {result.data['label']} (confidence: {result.data['confidence']:.3f}) - {cache_status} - {result.processing_time:.4f}s\\\")\\n\",\n    \"    \\n\",\n    \"    # Test 2: Batch processing\\n\",\n    \"    print(f\\\"\\\\n📦 Batch processing:\\\")\\n\",\n    \"    \\n\",\n    \"    batch_data = [f\\\"batch_item_{i}\\\" for i in range(20)]\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Batch processing\\\"):\\n\",\n    \"        batch_results = processor.process_batch(batch_data, \\\"analyze\\\")\\n\",\n    \"    \\n\",\n    \"    successful_results = [r for r in batch_results if r.data]\\n\",\n    \"    avg_time = sum(r.processing_time for r in successful_results) / len(successful_results)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Processed {len(successful_results)} items\\\")\\n\",\n    \"    print(f\\\"  Average processing time: {avg_time:.4f}s\\\")\\n\",\n    \"    print(f\\\"  Sample result: {successful_results[0].data}\\\")\\n\",\n    \"    \\n\",\n    \"    # Test 3: Vectorized processing\\n\",\n    \"    print(f\\\"\\\\n⚡ Vectorized processing:\\\")\\n\",\n    \"    \\n\",\n    \"    # Create test matrices\\n\",\n    \"    test_matrix = np.random.rand(100, 10)\\n\",\n    \"    \\n\",\n    \"    operations = [\\\"normalize\\\", \\\"similarity\\\", \\\"transform\\\"]\\n\",\n    \"    \\n\",\n    \"    for operation in operations:\\n\",\n    \"        result = processor.process_vectorized(test_matrix, operation)\\n\",\n    \"        print(f\\\"  {operation}: shape={result.data.shape}, time={result.processing_time:.4f}s\\\")\\n\",\n    \"    \\n\",\n    \"    # Test 4: Mixed workload\\n\",\n    \"    print(f\\\"\\\\n🔀 Mixed workload processing:\\\")\\n\",\n    \"    \\n\",\n    \"    mixed_data = [f\\\"mixed_{i}\\\" for i in range(30)]\\n\",\n    \"    operations = [\\\"classify\\\", \\\"vectorize\\\", \\\"analyze\\\"]\\n\",\n    \"    \\n\",\n    \"    start_time = time.perf_counter()\\n\",\n    \"    \\n\",\n    \"    for i, data in enumerate(mixed_data):\\n\",\n    \"        operation = operations[i % len(operations)]\\n\",\n    \"        result = processor.process_single(data, operation)\\n\",\n    \"    \\n\",\n    \"    mixed_time = time.perf_counter() - start_time\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Mixed workload: {len(mixed_data)} items in {mixed_time:.4f}s\\\")\\n\",\n    \"    \\n\",\n    \"    # Performance report\\n\",\n    \"    report = processor.get_performance_report()\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n📊 Performance Report:\\\")\\n\",\n    \"    print(f\\\"  Total processed: {report['processing_stats']['total_processed']}\\\")\\n\",\n    \"    print(f\\\"  Cache hit rate: {report['performance_summary']['cache_hit_rate']:.1%}\\\")\\n\",\n    \"    print(f\\\"  Average processing time: {report['performance_summary']['avg_processing_time']:.4f}s\\\")\\n\",\n    \"    print(f\\\"  Throughput: {report['performance_summary']['throughput_items_per_sec']:.1f} items/sec\\\")\\n\",\n    \"    \\n\",\n    \"    if report['cache_stats']:\\n\",\n    \"        print(f\\\"  Cache efficiency: {report['cache_stats']['memory_mb']:.1f}MB used\\\")\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Resource pool: {report['resource_pool_stats']['pool_efficiency']:.1%} efficiency\\\")\\n\",\n    \"    \\n\",\n    \"    # Configuration optimization\\n\",\n    \"    print(f\\\"\\\\n🔧 Configuration optimization:\\\")\\n\",\n    \"    optimized_config = processor.optimize_configuration()\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Original batch size: {config.batch_size}\\\")\\n\",\n    \"    print(f\\\"  Optimized batch size: {optimized_config.batch_size}\\\")\\n\",\n    \"    print(f\\\"  Original cache size: {config.cache_size}\\\")\\n\",\n    \"    print(f\\\"  Optimized cache size: {optimized_config.cache_size}\\\")\\n\",\n    \"    \\n\",\n    \"    # Memory cleanup demonstration\\n\",\n    \"    print(f\\\"\\\\n🧹 Memory cleanup:\\\")\\n\",\n    \"    \\n\",\n    \"    objects_before = len(gc.get_objects())\\n\",\n    \"    \\n\",\n    \"    # Clear caches and force garbage collection\\n\",\n    \"    if processor.cache:\\n\",\n    \"        processor.cache.cache.clear()\\n\",\n    \"    \\n\",\n    \"    del batch_results, successful_results, mixed_data\\n\",\n    \"    gc.collect()\\n\",\n    \"    \\n\",\n    \"    objects_after = len(gc.get_objects())\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Objects before cleanup: {objects_before}\\\")\\n\",\n    \"    print(f\\\"  Objects after cleanup: {objects_after}\\\")\\n\",\n    \"    print(f\\\"  Objects freed: {objects_before - objects_after}\\\")\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n🏆 Production System Features:\\\")\\n\",\n    \"    print(f\\\"  ✅ Intelligent caching with memory limits\\\")\\n\",\n    \"    print(f\\\"  ✅ Parallel batch processing\\\")\\n\",\n    \"    print(f\\\"  ✅ Vectorized mathematical operations\\\")\\n\",\n    \"    print(f\\\"  ✅ Resource pooling and management\\\")\\n\",\n    \"    print(f\\\"  ✅ Comprehensive performance monitoring\\\")\\n\",\n    \"    print(f\\\"  ✅ Automatic configuration optimization\\\")\\n\",\n    \"    print(f\\\"  ✅ Memory-efficient data structures\\\")\\n\",\n    \"\\n\",\n    \"# Run the complete production system demonstration\\n\",\n    \"demonstrate_production_system()\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🎯 Performance Optimization Mastery Complete!\\\")\\n\",\n    \"print(f\\\"\\\\n💡 Key Performance Optimization Benefits:\\\")\\n\",\n    \"print(f\\\"  ⚡ 10-100x speedup with proper optimization\\\")\\n\",\n    \"print(f\\\"  💾 Efficient memory usage and management\\\")\\n\",\n    \"print(f\\\"  📊 Data-driven performance monitoring\\\")\\n\",\n    \"print(f\\\"  🔧 Adaptive configuration optimization\\\")\\n\",\n    \"print(f\\\"  🚀 Production-ready scalable architecture\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Summary: Performance Optimization Mastery\\n\",\n    \"\\n\",\n    \"**🎯 Key Takeaways:**\\n\",\n    \"\\n\",\n    \"1. **Memory Efficiency** reduces allocation overhead and improves cache locality\\n\",\n    \"2. **Performance Profiling** identifies bottlenecks and guides optimization efforts\\n\",\n    \"3. **Vectorization** provides massive speedups for numerical operations\\n\",\n    \"4. **Parallel Processing** utilizes multiple cores for CPU-bound and I/O-bound tasks\\n\",\n    \"5. **Smart Caching** eliminates redundant computations\\n\",\n    \"6. **Resource Pooling** reuses expensive objects efficiently\\n\",\n    \"7. **Monitoring** provides insights for continuous optimization\\n\",\n    \"\\n\",\n    \"**🚀 Production Considerations:**\\n\",\n    \"- Always profile before optimizing\\n\",\n    \"- Use appropriate data structures for your use case\\n\",\n    \"- Leverage NumPy for numerical computations\\n\",\n    \"- Choose threads vs processes based on workload type\\n\",\n    \"- Monitor memory usage and implement limits\\n\",\n    \"- Cache strategically with appropriate TTL\\n\",\n    \"\\n\",\n    \"**💡 Remember:** Performance optimization is about making the right trade-offs between speed, memory, and code complexity. Focus on the bottlenecks that matter most for your specific AI application!\"\n   ]\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"Python 3\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.11.0\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 4\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":139085,"cache_read_input_tokens":0,"output_tokens":3}},"requestId":"req_vrtx_011CRhSYczuuib9Tu6sh1g7f","type":"assistant","uuid":"fbd9399c-81a6-4745-b36e-24d4ce4f6718","timestamp":"2025-08-01T18:17:56.192Z"}
{"parentUuid":"fbd9399c-81a6-4745-b36e-24d4ce4f6718","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_vrtx_01NqgAZAe2ajWivvFZ31rVm2","type":"tool_result","content":"File created successfully at: /home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/notebooks/05_performance_optimization_learning.ipynb"}]},"uuid":"5a30ebeb-98ed-4a5c-ad5b-51c5e118b88f","timestamp":"2025-08-01T18:17:56.220Z","toolUseResult":{"type":"create","filePath":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/notebooks/05_performance_optimization_learning.ipynb","content":"{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Performance Optimization for AI Systems\\n\",\n    \"\\n\",\n    \"This notebook teaches performance optimization techniques for AI applications including profiling, memory management, vectorization, and parallel processing. You'll learn:\\n\",\n    \"\\n\",\n    \"1. **Memory-Efficient Data Structures** - Optimizing memory usage\\n\",\n    \"2. **Performance Profiling** - Identifying bottlenecks\\n\",\n    \"3. **Vectorized Operations** - NumPy and efficient computations\\n\",\n    \"4. **Parallel Processing** - CPU and I/O optimization\\n\",\n    \"5. **Lazy Loading** - Memory-efficient data processing\\n\",\n    \"6. **Batch Processing** - Optimizing throughput\\n\",\n    \"7. **Garbage Collection** - Memory management\\n\",\n    \"8. **Benchmarking** - Measuring and comparing performance\\n\",\n    \"\\n\",\n    \"## Prerequisites\\n\",\n    \"```bash\\n\",\n    \"pip install rich numpy\\n\",\n    \"```\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 1: Performance Fundamentals and Setup\\n\",\n    \"\\n\",\n    \"**First Principle**: Performance optimization starts with measurement - profile first, optimize second.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `time.perf_counter()` for precise timing, `sys.getsizeof()` for memory measurement.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Essential imports for performance optimization\\n\",\n    \"import sys\\n\",\n    \"import time\\n\",\n    \"import gc\\n\",\n    \"import weakref\\n\",\n    \"import threading\\n\",\n    \"import multiprocessing as mp\\n\",\n    \"from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, as_completed\\n\",\n    \"from typing import List, Dict, Any, Callable, Iterator, Optional, Tuple\\n\",\n    \"from dataclasses import dataclass\\n\",\n    \"from functools import lru_cache, partial\\n\",\n    \"import cProfile\\n\",\n    \"import pstats\\n\",\n    \"import tracemalloc\\n\",\n    \"from contextlib import contextmanager\\n\",\n    \"from collections import deque, defaultdict\\n\",\n    \"import numpy as np\\n\",\n    \"from rich.console import Console\\n\",\n    \"from rich.panel import Panel\\n\",\n    \"from rich.table import Table\\n\",\n    \"\\n\",\n    \"console = Console()\\n\",\n    \"\\n\",\n    \"console.print(Panel(\\\"⚡ Performance Optimization Fundamentals\\\", style=\\\"bold blue\\\"))\\n\",\n    \"\\n\",\n    \"print(\\\"\\\"\\\"\\n\",\n    \"🔑 Key Performance Principles:\\n\",\n    \"\\n\",\n    \"1. **Measure First**: Profile before optimizing\\n\",\n    \"2. **Bottleneck Focus**: Optimize the slowest parts\\n\",\n    \"3. **Memory Efficiency**: Reduce allocations and copies\\n\",\n    \"4. **Vectorization**: Use NumPy for numerical operations\\n\",\n    \"5. **Parallelization**: Leverage multiple cores\\n\",\n    \"6. **Caching**: Avoid redundant computations\\n\",\n    \"7. **Lazy Evaluation**: Compute only when needed\\n\",\n    \"\\n\",\n    \"🎯 Performance Areas for AI:\\n\",\n    \"• Data loading and preprocessing\\n\",\n    \"• Model inference and training\\n\",\n    \"• Feature extraction and transformation\\n\",\n    \"• Batch processing and streaming\\n\",\n    \"• Memory management\\n\",\n    \"\\\"\\\"\\\")\\n\",\n    \"\\n\",\n    \"# Basic timing utilities\\n\",\n    \"@contextmanager\\n\",\n    \"def profile_time(operation_name: str = \\\"Operation\\\"):\\n\",\n    \"    \\\"\\\"\\\"Context manager for timing operations.\\\"\\\"\\\"\\n\",\n    \"    start_time = time.perf_counter()\\n\",\n    \"    yield\\n\",\n    \"    end_time = time.perf_counter()\\n\",\n    \"    duration = end_time - start_time\\n\",\n    \"    print(f\\\"⏱️  {operation_name}: {duration:.4f}s\\\")\\n\",\n    \"\\n\",\n    \"@contextmanager\\n\",\n    \"def profile_memory(operation_name: str = \\\"Operation\\\"):\\n\",\n    \"    \\\"\\\"\\\"Context manager for memory profiling.\\\"\\\"\\\"\\n\",\n    \"    tracemalloc.start()\\n\",\n    \"    start_memory = tracemalloc.get_traced_memory()[0]\\n\",\n    \"    \\n\",\n    \"    yield\\n\",\n    \"    \\n\",\n    \"    end_memory = tracemalloc.get_traced_memory()[0]\\n\",\n    \"    tracemalloc.stop()\\n\",\n    \"    \\n\",\n    \"    memory_used = (end_memory - start_memory) / (1024 * 1024)  # MB\\n\",\n    \"    print(f\\\"🧠 {operation_name} memory: {memory_used:.2f} MB\\\")\\n\",\n    \"\\n\",\n    \"def compare_performance(functions: List[Tuple[str, Callable]], *args, **kwargs):\\n\",\n    \"    \\\"\\\"\\\"Compare performance of multiple functions.\\\"\\\"\\\"\\n\",\n    \"    results = []\\n\",\n    \"    \\n\",\n    \"    for name, func in functions:\\n\",\n    \"        # Warm up\\n\",\n    \"        try:\\n\",\n    \"            func(*args, **kwargs)\\n\",\n    \"        except:\\n\",\n    \"            pass\\n\",\n    \"        \\n\",\n    \"        # Measure\\n\",\n    \"        start_time = time.perf_counter()\\n\",\n    \"        try:\\n\",\n    \"            result = func(*args, **kwargs)\\n\",\n    \"            end_time = time.perf_counter()\\n\",\n    \"            duration = end_time - start_time\\n\",\n    \"            results.append((name, duration, \\\"success\\\", result))\\n\",\n    \"        except Exception as e:\\n\",\n    \"            end_time = time.perf_counter()\\n\",\n    \"            duration = end_time - start_time\\n\",\n    \"            results.append((name, duration, \\\"error\\\", str(e)))\\n\",\n    \"    \\n\",\n    \"    # Display results\\n\",\n    \"    print(f\\\"\\\\n📊 Performance Comparison:\\\")\\n\",\n    \"    fastest_time = min(r[1] for r in results if r[2] == \\\"success\\\")\\n\",\n    \"    \\n\",\n    \"    for name, duration, status, result in results:\\n\",\n    \"        if status == \\\"success\\\":\\n\",\n    \"            speedup = fastest_time / duration\\n\",\n    \"            print(f\\\"  {name}: {duration:.4f}s ({speedup:.1f}x)\\\")\\n\",\n    \"        else:\\n\",\n    \"            print(f\\\"  {name}: ERROR - {result}\\\")\\n\",\n    \"    \\n\",\n    \"    return results\\n\",\n    \"\\n\",\n    \"# Simple demonstration\\n\",\n    \"def demo_timing():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate basic timing.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    # Inefficient way\\n\",\n    \"    def slow_sum(n: int) -> int:\\n\",\n    \"        result = 0\\n\",\n    \"        for i in range(n):\\n\",\n    \"            result += i\\n\",\n    \"        return result\\n\",\n    \"    \\n\",\n    \"    # Efficient way\\n\",\n    \"    def fast_sum(n: int) -> int:\\n\",\n    \"        return n * (n - 1) // 2\\n\",\n    \"    \\n\",\n    \"    n = 1000000\\n\",\n    \"    \\n\",\n    \"    compare_performance([\\n\",\n    \"        (\\\"Slow loop\\\", slow_sum),\\n\",\n    \"        (\\\"Fast formula\\\", fast_sum)\\n\",\n    \"    ], n)\\n\",\n    \"\\n\",\n    \"demo_timing()\\n\",\n    \"print(\\\"\\\\n✅ Performance toolkit ready!\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 2: Memory-Efficient Data Structures\\n\",\n    \"\\n\",\n    \"**First Principle**: Memory efficiency is crucial for AI systems that process large datasets.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `deque`, `__slots__`, and custom memory-aware containers to reduce memory overhead.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class MemoryEfficientCache:\\n\",\n    \"    \\\"\\\"\\\"Memory-efficient LRU cache with size limits.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, max_size: int = 1000, max_memory_mb: float = 100.0):\\n\",\n    \"        self.max_size = max_size\\n\",\n    \"        self.max_memory_bytes = max_memory_mb * 1024 * 1024\\n\",\n    \"        self.cache = {}\\n\",\n    \"        self.access_order = deque()\\n\",\n    \"        self.current_memory = 0\\n\",\n    \"        self.hits = 0\\n\",\n    \"        self.misses = 0\\n\",\n    \"    \\n\",\n    \"    def _estimate_size(self, obj: Any) -> int:\\n\",\n    \"        \\\"\\\"\\\"Estimate object size in bytes.\\\"\\\"\\\"\\n\",\n    \"        return sys.getsizeof(obj)\\n\",\n    \"    \\n\",\n    \"    def _evict_if_needed(self):\\n\",\n    \"        \\\"\\\"\\\"Evict items if cache is too large.\\\"\\\"\\\"\\n\",\n    \"        while (len(self.cache) > self.max_size or \\n\",\n    \"               self.current_memory > self.max_memory_bytes):\\n\",\n    \"            if not self.access_order:\\n\",\n    \"                break\\n\",\n    \"            \\n\",\n    \"            key = self.access_order.popleft()\\n\",\n    \"            if key in self.cache:\\n\",\n    \"                value = self.cache.pop(key)\\n\",\n    \"                self.current_memory -= self._estimate_size(value)\\n\",\n    \"    \\n\",\n    \"    def get(self, key: str) -> Optional[Any]:\\n\",\n    \"        \\\"\\\"\\\"Get item from cache.\\\"\\\"\\\"\\n\",\n    \"        if key in self.cache:\\n\",\n    \"            # Move to end (most recent)\\n\",\n    \"            self.access_order.remove(key)\\n\",\n    \"            self.access_order.append(key)\\n\",\n    \"            self.hits += 1\\n\",\n    \"            return self.cache[key]\\n\",\n    \"        \\n\",\n    \"        self.misses += 1\\n\",\n    \"        return None\\n\",\n    \"    \\n\",\n    \"    def put(self, key: str, value: Any) -> None:\\n\",\n    \"        \\\"\\\"\\\"Put item in cache.\\\"\\\"\\\"\\n\",\n    \"        if key in self.cache:\\n\",\n    \"            # Update existing\\n\",\n    \"            old_value = self.cache[key]\\n\",\n    \"            self.current_memory -= self._estimate_size(old_value)\\n\",\n    \"            self.access_order.remove(key)\\n\",\n    \"        \\n\",\n    \"        size = self._estimate_size(value)\\n\",\n    \"        self.cache[key] = value\\n\",\n    \"        self.access_order.append(key)\\n\",\n    \"        self.current_memory += size\\n\",\n    \"        \\n\",\n    \"        self._evict_if_needed()\\n\",\n    \"    \\n\",\n    \"    def get_stats(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get cache statistics.\\\"\\\"\\\"\\n\",\n    \"        total_requests = self.hits + self.misses\\n\",\n    \"        hit_ratio = self.hits / total_requests if total_requests > 0 else 0\\n\",\n    \"        \\n\",\n    \"        return {\\n\",\n    \"            \\\"size\\\": len(self.cache),\\n\",\n    \"            \\\"max_size\\\": self.max_size,\\n\",\n    \"            \\\"memory_mb\\\": self.current_memory / (1024 * 1024),\\n\",\n    \"            \\\"max_memory_mb\\\": self.max_memory_bytes / (1024 * 1024),\\n\",\n    \"            \\\"hit_ratio\\\": hit_ratio,\\n\",\n    \"            \\\"hits\\\": self.hits,\\n\",\n    \"            \\\"misses\\\": self.misses\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"class ObjectPool:\\n\",\n    \"    \\\"\\\"\\\"Object pool for expensive-to-create objects.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, factory: Callable, max_size: int = 10):\\n\",\n    \"        self.factory = factory\\n\",\n    \"        self.max_size = max_size\\n\",\n    \"        self.available = deque()\\n\",\n    \"        self.in_use = weakref.WeakSet()\\n\",\n    \"        self.total_created = 0\\n\",\n    \"        self.total_acquired = 0\\n\",\n    \"        self.total_released = 0\\n\",\n    \"    \\n\",\n    \"    def acquire(self):\\n\",\n    \"        \\\"\\\"\\\"Acquire object from pool.\\\"\\\"\\\"\\n\",\n    \"        self.total_acquired += 1\\n\",\n    \"        \\n\",\n    \"        if self.available:\\n\",\n    \"            obj = self.available.popleft()\\n\",\n    \"        else:\\n\",\n    \"            if self.total_created < self.max_size:\\n\",\n    \"                obj = self.factory()\\n\",\n    \"                self.total_created += 1\\n\",\n    \"            else:\\n\",\n    \"                # Create temporary object (not pooled)\\n\",\n    \"                obj = self.factory()\\n\",\n    \"        \\n\",\n    \"        self.in_use.add(obj)\\n\",\n    \"        return obj\\n\",\n    \"    \\n\",\n    \"    def release(self, obj):\\n\",\n    \"        \\\"\\\"\\\"Release object back to pool.\\\"\\\"\\\"\\n\",\n    \"        self.total_released += 1\\n\",\n    \"        \\n\",\n    \"        if obj in self.in_use:\\n\",\n    \"            self.in_use.remove(obj)\\n\",\n    \"            if len(self.available) < self.max_size:\\n\",\n    \"                # Reset object state if needed\\n\",\n    \"                if hasattr(obj, 'reset'):\\n\",\n    \"                    obj.reset()\\n\",\n    \"                self.available.append(obj)\\n\",\n    \"    \\n\",\n    \"    @contextmanager\\n\",\n    \"    def borrow(self):\\n\",\n    \"        \\\"\\\"\\\"Context manager for automatic object management.\\\"\\\"\\\"\\n\",\n    \"        obj = self.acquire()\\n\",\n    \"        try:\\n\",\n    \"            yield obj\\n\",\n    \"        finally:\\n\",\n    \"            self.release(obj)\\n\",\n    \"    \\n\",\n    \"    def get_stats(self) -> Dict[str, Any]:\\n\",\n    \"        return {\\n\",\n    \"            \\\"available\\\": len(self.available),\\n\",\n    \"            \\\"in_use\\\": len(self.in_use),\\n\",\n    \"            \\\"total_created\\\": self.total_created,\\n\",\n    \"            \\\"total_acquired\\\": self.total_acquired,\\n\",\n    \"            \\\"total_released\\\": self.total_released,\\n\",\n    \"            \\\"max_size\\\": self.max_size,\\n\",\n    \"            \\\"pool_efficiency\\\": len(self.available) / self.max_size if self.max_size > 0 else 0\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"# Memory-efficient classes using __slots__\\n\",\n    \"class EfficientDataPoint:\\n\",\n    \"    \\\"\\\"\\\"Memory-efficient data point using __slots__.\\\"\\\"\\\"\\n\",\n    \"    __slots__ = ['x', 'y', 'label', 'confidence']\\n\",\n    \"    \\n\",\n    \"    def __init__(self, x: float, y: float, label: str, confidence: float):\\n\",\n    \"        self.x = x\\n\",\n    \"        self.y = y\\n\",\n    \"        self.label = label\\n\",\n    \"        self.confidence = confidence\\n\",\n    \"\\n\",\n    \"class RegularDataPoint:\\n\",\n    \"    \\\"\\\"\\\"Regular data point without __slots__.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, x: float, y: float, label: str, confidence: float):\\n\",\n    \"        self.x = x\\n\",\n    \"        self.y = y\\n\",\n    \"        self.label = label\\n\",\n    \"        self.confidence = confidence\\n\",\n    \"\\n\",\n    \"def demonstrate_memory_efficient_structures():\\n\",\n    \"    \\\"\\\"\\\"Show memory-efficient data structures.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    console.print(Panel(\\\"🧠 Memory-Efficient Structures\\\", style=\\\"bold blue\\\"))\\n\",\n    \"    \\n\",\n    \"    # Test memory-efficient cache\\n\",\n    \"    print(\\\"💾 Testing memory-efficient cache:\\\")\\n\",\n    \"    \\n\",\n    \"    cache = MemoryEfficientCache(max_size=5, max_memory_mb=0.1)\\n\",\n    \"    \\n\",\n    \"    # Add items to cache\\n\",\n    \"    test_data = [f\\\"large_data_item_{i}\\\" * 100 for i in range(10)]\\n\",\n    \"    \\n\",\n    \"    for i, data in enumerate(test_data):\\n\",\n    \"        cache.put(f\\\"key_{i}\\\", data)\\n\",\n    \"        stats = cache.get_stats()\\n\",\n    \"        print(f\\\"  Added item {i}: cache size={stats['size']}, memory={stats['memory_mb']:.3f}MB\\\")\\n\",\n    \"    \\n\",\n    \"    # Test retrieval\\n\",\n    \"    print(f\\\"\\\\n🔍 Cache retrieval test:\\\")\\n\",\n    \"    for i in [0, 3, 7, 9]:\\n\",\n    \"        result = cache.get(f\\\"key_{i}\\\")\\n\",\n    \"        status = \\\"HIT\\\" if result else \\\"MISS\\\"\\n\",\n    \"        print(f\\\"  key_{i}: {status}\\\")\\n\",\n    \"    \\n\",\n    \"    final_stats = cache.get_stats()\\n\",\n    \"    print(f\\\"\\\\nCache final stats: {final_stats}\\\")\\n\",\n    \"    \\n\",\n    \"    # Test object pool\\n\",\n    \"    print(f\\\"\\\\n🏊 Testing object pool:\\\")\\n\",\n    \"    \\n\",\n    \"    class ExpensiveResource:\\n\",\n    \"        def __init__(self):\\n\",\n    \"            time.sleep(0.01)  # Simulate expensive creation\\n\",\n    \"            self.created_at = time.time()\\n\",\n    \"            self.usage_count = 0\\n\",\n    \"        \\n\",\n    \"        def reset(self):\\n\",\n    \"            self.usage_count = 0\\n\",\n    \"        \\n\",\n    \"        def use(self):\\n\",\n    \"            self.usage_count += 1\\n\",\n    \"            return f\\\"Used {self.usage_count} times\\\"\\n\",\n    \"    \\n\",\n    \"    pool = ObjectPool(ExpensiveResource, max_size=3)\\n\",\n    \"    \\n\",\n    \"    # Use objects from pool\\n\",\n    \"    with profile_time(\\\"Object pool operations\\\"):\\n\",\n    \"        for i in range(5):\\n\",\n    \"            with pool.borrow() as obj:\\n\",\n    \"                result = obj.use()\\n\",\n    \"                print(f\\\"  Operation {i}: {result}\\\")\\n\",\n    \"    \\n\",\n    \"    pool_stats = pool.get_stats()\\n\",\n    \"    print(f\\\"Pool stats: {pool_stats}\\\")\\n\",\n    \"    \\n\",\n    \"    # Compare __slots__ vs regular classes\\n\",\n    \"    print(f\\\"\\\\n📏 Memory comparison (__slots__ vs regular):\\\")\\n\",\n    \"    \\n\",\n    \"    # Create instances\\n\",\n    \"    efficient_point = EfficientDataPoint(1.0, 2.0, \\\"positive\\\", 0.95)\\n\",\n    \"    regular_point = RegularDataPoint(1.0, 2.0, \\\"positive\\\", 0.95)\\n\",\n    \"    \\n\",\n    \"    efficient_size = sys.getsizeof(efficient_point)\\n\",\n    \"    regular_size = sys.getsizeof(regular_point)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  EfficientDataPoint (__slots__): {efficient_size} bytes\\\")\\n\",\n    \"    print(f\\\"  RegularDataPoint: {regular_size} bytes\\\")\\n\",\n    \"    print(f\\\"  Memory savings: {((regular_size - efficient_size) / regular_size) * 100:.1f}%\\\")\\n\",\n    \"    \\n\",\n    \"    # Test with many objects\\n\",\n    \"    n_objects = 10000\\n\",\n    \"    \\n\",\n    \"    with profile_memory(\\\"Creating efficient objects\\\"):\\n\",\n    \"        efficient_objects = [\\n\",\n    \"            EfficientDataPoint(i, i*2, f\\\"label_{i%3}\\\", i/n_objects)\\n\",\n    \"            for i in range(n_objects)\\n\",\n    \"        ]\\n\",\n    \"    \\n\",\n    \"    with profile_memory(\\\"Creating regular objects\\\"):\\n\",\n    \"        regular_objects = [\\n\",\n    \"            RegularDataPoint(i, i*2, f\\\"label_{i%3}\\\", i/n_objects)\\n\",\n    \"            for i in range(n_objects)\\n\",\n    \"        ]\\n\",\n    \"    \\n\",\n    \"    # Clean up\\n\",\n    \"    del efficient_objects, regular_objects\\n\",\n    \"    gc.collect()\\n\",\n    \"\\n\",\n    \"demonstrate_memory_efficient_structures()\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Memory Efficiency Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Reduced memory usage with __slots__\\\")\\n\",\n    \"print(f\\\"  ✅ Smart caching with size and memory limits\\\")\\n\",\n    \"print(f\\\"  ✅ Object pooling for expensive resources\\\")\\n\",\n    \"print(f\\\"  ✅ Efficient data structures (deque, weakref)\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 3: Performance Profiling and Monitoring\\n\",\n    \"\\n\",\n    \"**First Principle**: Measure performance to identify bottlenecks before optimizing.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `cProfile`, `tracemalloc`, and custom monitoring for comprehensive profiling.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class PerformanceMonitor:\\n\",\n    \"    \\\"\\\"\\\"Monitor for tracking performance metrics.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self):\\n\",\n    \"        self.metrics = defaultdict(list)\\n\",\n    \"        self.counters = defaultdict(int)\\n\",\n    \"        self.start_times = {}\\n\",\n    \"    \\n\",\n    \"    def start_timer(self, operation: str):\\n\",\n    \"        \\\"\\\"\\\"Start timing an operation.\\\"\\\"\\\"\\n\",\n    \"        self.start_times[operation] = time.perf_counter()\\n\",\n    \"    \\n\",\n    \"    def stop_timer(self, operation: str):\\n\",\n    \"        \\\"\\\"\\\"Stop timing an operation and record the duration.\\\"\\\"\\\"\\n\",\n    \"        if operation in self.start_times:\\n\",\n    \"            duration = time.perf_counter() - self.start_times[operation]\\n\",\n    \"            self.record_time(operation, duration)\\n\",\n    \"            del self.start_times[operation]\\n\",\n    \"            return duration\\n\",\n    \"        return 0.0\\n\",\n    \"    \\n\",\n    \"    def record_time(self, operation: str, duration: float):\\n\",\n    \"        \\\"\\\"\\\"Record operation timing.\\\"\\\"\\\"\\n\",\n    \"        self.metrics[f\\\"{operation}_time\\\"].append(duration)\\n\",\n    \"        self.counters[f\\\"{operation}_count\\\"] += 1\\n\",\n    \"    \\n\",\n    \"    def record_memory(self, operation: str, memory_mb: float):\\n\",\n    \"        \\\"\\\"\\\"Record memory usage.\\\"\\\"\\\"\\n\",\n    \"        self.metrics[f\\\"{operation}_memory\\\"].append(memory_mb)\\n\",\n    \"    \\n\",\n    \"    def increment_counter(self, name: str, value: int = 1):\\n\",\n    \"        \\\"\\\"\\\"Increment a counter.\\\"\\\"\\\"\\n\",\n    \"        self.counters[name] += value\\n\",\n    \"    \\n\",\n    \"    @contextmanager\\n\",\n    \"    def time_operation(self, operation: str):\\n\",\n    \"        \\\"\\\"\\\"Context manager for timing operations.\\\"\\\"\\\"\\n\",\n    \"        self.start_timer(operation)\\n\",\n    \"        try:\\n\",\n    \"            yield\\n\",\n    \"        finally:\\n\",\n    \"            self.stop_timer(operation)\\n\",\n    \"    \\n\",\n    \"    def get_summary(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get performance summary.\\\"\\\"\\\"\\n\",\n    \"        summary = {}\\n\",\n    \"        \\n\",\n    \"        for metric_name, values in self.metrics.items():\\n\",\n    \"            if values:\\n\",\n    \"                summary[metric_name] = {\\n\",\n    \"                    \\\"avg\\\": sum(values) / len(values),\\n\",\n    \"                    \\\"min\\\": min(values),\\n\",\n    \"                    \\\"max\\\": max(values),\\n\",\n    \"                    \\\"count\\\": len(values),\\n\",\n    \"                    \\\"total\\\": sum(values)\\n\",\n    \"                }\\n\",\n    \"        \\n\",\n    \"        summary[\\\"counters\\\"] = dict(self.counters)\\n\",\n    \"        return summary\\n\",\n    \"\\n\",\n    \"# Example AI processing functions for profiling\\n\",\n    \"def simulate_data_loading(size: int) -> List[Dict[str, Any]]:\\n\",\n    \"    \\\"\\\"\\\"Simulate loading data.\\\"\\\"\\\"\\n\",\n    \"    return [{\\n\",\n    \"        \\\"id\\\": i,\\n\",\n    \"        \\\"features\\\": [j * 0.1 for j in range(10)],\\n\",\n    \"        \\\"label\\\": i % 3,\\n\",\n    \"        \\\"metadata\\\": {\\\"source\\\": f\\\"dataset_{i//100}\\\"}\\n\",\n    \"    } for i in range(size)]\\n\",\n    \"\\n\",\n    \"def simulate_feature_extraction(data_point: Dict[str, Any]) -> List[float]:\\n\",\n    \"    \\\"\\\"\\\"Simulate feature extraction.\\\"\\\"\\\"\\n\",\n    \"    features = data_point[\\\"features\\\"]\\n\",\n    \"    # Simulate some processing\\n\",\n    \"    processed = []\\n\",\n    \"    for f in features:\\n\",\n    \"        processed.append(f * f)  # Square\\n\",\n    \"        processed.append(f * 2)  # Double\\n\",\n    \"    return processed\\n\",\n    \"\\n\",\n    \"def simulate_model_inference(features: List[float]) -> Dict[str, Any]:\\n\",\n    \"    \\\"\\\"\\\"Simulate model inference.\\\"\\\"\\\"\\n\",\n    \"    # Simulate computation\\n\",\n    \"    score = sum(features) / len(features) if features else 0\\n\",\n    \"    prediction = \\\"positive\\\" if score > 0.5 else \\\"negative\\\"\\n\",\n    \"    confidence = min(abs(score), 1.0)\\n\",\n    \"    \\n\",\n    \"    return {\\n\",\n    \"        \\\"prediction\\\": prediction,\\n\",\n    \"        \\\"confidence\\\": confidence,\\n\",\n    \"        \\\"score\\\": score\\n\",\n    \"    }\\n\",\n    \"\\n\",\n    \"@lru_cache(maxsize=1000)\\n\",\n    \"def cached_expensive_computation(data_hash: str) -> float:\\n\",\n    \"    \\\"\\\"\\\"Expensive computation with caching.\\\"\\\"\\\"\\n\",\n    \"    # Simulate expensive computation\\n\",\n    \"    result = 0.0\\n\",\n    \"    for i in range(1000):\\n\",\n    \"        result += hash(data_hash + str(i)) % 100 / 100.0\\n\",\n    \"    return result\\n\",\n    \"\\n\",\n    \"def demonstrate_profiling():\\n\",\n    \"    \\\"\\\"\\\"Show profiling techniques.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    console.print(Panel(\\\"📊 Performance Profiling\\\", style=\\\"bold green\\\"))\\n\",\n    \"    \\n\",\n    \"    monitor = PerformanceMonitor()\\n\",\n    \"    \\n\",\n    \"    print(\\\"🔍 Profiling AI processing pipeline:\\\")\\n\",\n    \"    \\n\",\n    \"    # Simulate processing pipeline\\n\",\n    \"    with monitor.time_operation(\\\"data_loading\\\"):\\n\",\n    \"        data = simulate_data_loading(1000)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Loaded {len(data)} data points\\\")\\n\",\n    \"    \\n\",\n    \"    # Process data with detailed monitoring\\n\",\n    \"    results = []\\n\",\n    \"    \\n\",\n    \"    for i, data_point in enumerate(data[:100]):  # Process subset\\n\",\n    \"        # Feature extraction\\n\",\n    \"        with monitor.time_operation(\\\"feature_extraction\\\"):\\n\",\n    \"            features = simulate_feature_extraction(data_point)\\n\",\n    \"        \\n\",\n    \"        # Model inference\\n\",\n    \"        with monitor.time_operation(\\\"model_inference\\\"):\\n\",\n    \"            prediction = simulate_model_inference(features)\\n\",\n    \"        \\n\",\n    \"        # Expensive computation (with caching)\\n\",\n    \"        data_hash = str(hash(str(data_point[\\\"features\\\"])))\\n\",\n    \"        with monitor.time_operation(\\\"expensive_computation\\\"):\\n\",\n    \"            expensive_result = cached_expensive_computation(data_hash)\\n\",\n    \"        \\n\",\n    \"        monitor.increment_counter(\\\"processed_items\\\")\\n\",\n    \"        \\n\",\n    \"        results.append({\\n\",\n    \"            \\\"prediction\\\": prediction,\\n\",\n    \"            \\\"expensive_result\\\": expensive_result\\n\",\n    \"        })\\n\",\n    \"    \\n\",\n    \"    # Show performance summary\\n\",\n    \"    summary = monitor.get_summary()\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n📈 Performance Summary:\\\")\\n\",\n    \"    for metric, stats in summary.items():\\n\",\n    \"        if isinstance(stats, dict) and 'avg' in stats:\\n\",\n    \"            print(f\\\"  {metric}: avg={stats['avg']:.4f}s, min={stats['min']:.4f}s, max={stats['max']:.4f}s, count={stats['count']}\\\")\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n🔢 Counters: {summary.get('counters', {})}\\\")\\n\",\n    \"    \\n\",\n    \"    # Cache performance\\n\",\n    \"    cache_info = cached_expensive_computation.cache_info()\\n\",\n    \"    print(f\\\"\\\\n💾 Cache performance: {cache_info}\\\")\\n\",\n    \"    \\n\",\n    \"    # Profile memory usage of different operations\\n\",\n    \"    print(f\\\"\\\\n🧠 Memory profiling different operations:\\\")\\n\",\n    \"    \\n\",\n    \"    with profile_memory(\\\"Large list creation\\\"):\\n\",\n    \"        large_list = [i for i in range(100000)]\\n\",\n    \"    \\n\",\n    \"    with profile_memory(\\\"Dictionary creation\\\"):\\n\",\n    \"        large_dict = {f\\\"key_{i}\\\": i for i in range(10000)}\\n\",\n    \"    \\n\",\n    \"    with profile_memory(\\\"NumPy array creation\\\"):\\n\",\n    \"        large_array = np.arange(100000)\\n\",\n    \"    \\n\",\n    \"    # Clean up\\n\",\n    \"    del large_list, large_dict, large_array\\n\",\n    \"    gc.collect()\\n\",\n    \"\\n\",\n    \"# Advanced profiling with cProfile\\n\",\n    \"def demonstrate_cprofile():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate cProfile usage.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n⚡ Advanced profiling with cProfile:\\\")\\n\",\n    \"    \\n\",\n    \"    def profile_target():\\n\",\n    \"        \\\"\\\"\\\"Function to profile.\\\"\\\"\\\"\\n\",\n    \"        data = simulate_data_loading(500)\\n\",\n    \"        \\n\",\n    \"        results = []\\n\",\n    \"        for item in data[:50]:\\n\",\n    \"            features = simulate_feature_extraction(item)\\n\",\n    \"            prediction = simulate_model_inference(features)\\n\",\n    \"            results.append(prediction)\\n\",\n    \"        \\n\",\n    \"        return results\\n\",\n    \"    \\n\",\n    \"    # Profile with cProfile\\n\",\n    \"    profiler = cProfile.Profile()\\n\",\n    \"    profiler.enable()\\n\",\n    \"    \\n\",\n    \"    start_time = time.perf_counter()\\n\",\n    \"    results = profile_target()\\n\",\n    \"    duration = time.perf_counter() - start_time\\n\",\n    \"    \\n\",\n    \"    profiler.disable()\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Processed {len(results)} items in {duration:.4f}s\\\")\\n\",\n    \"    print(f\\\"  Rate: {len(results) / duration:.1f} items/second\\\")\\n\",\n    \"    \\n\",\n    \"    # Analyze profiling results\\n\",\n    \"    stats = pstats.Stats(profiler)\\n\",\n    \"    stats.sort_stats('cumulative')\\n\",\n    \"    \\n\",\n    \"    # Get top functions by cumulative time\\n\",\n    \"    print(f\\\"\\\\n📊 Top functions by cumulative time:\\\")\\n\",\n    \"    stats.print_stats(10)  # Top 10 functions\\n\",\n    \"\\n\",\n    \"# Benchmark different approaches\\n\",\n    \"def demonstrate_benchmarking():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate benchmarking different approaches.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n🏁 Benchmarking different approaches:\\\")\\n\",\n    \"    \\n\",\n    \"    data = list(range(10000))\\n\",\n    \"    \\n\",\n    \"    # Different ways to process data\\n\",\n    \"    def approach_1_loop(data):\\n\",\n    \"        \\\"\\\"\\\"Traditional loop.\\\"\\\"\\\"\\n\",\n    \"        result = []\\n\",\n    \"        for item in data:\\n\",\n    \"            result.append(item * 2)\\n\",\n    \"        return result\\n\",\n    \"    \\n\",\n    \"    def approach_2_comprehension(data):\\n\",\n    \"        \\\"\\\"\\\"List comprehension.\\\"\\\"\\\"\\n\",\n    \"        return [item * 2 for item in data]\\n\",\n    \"    \\n\",\n    \"    def approach_3_map(data):\\n\",\n    \"        \\\"\\\"\\\"Map function.\\\"\\\"\\\"\\n\",\n    \"        return list(map(lambda x: x * 2, data))\\n\",\n    \"    \\n\",\n    \"    def approach_4_numpy(data):\\n\",\n    \"        \\\"\\\"\\\"NumPy vectorized.\\\"\\\"\\\"\\n\",\n    \"        arr = np.array(data)\\n\",\n    \"        return (arr * 2).tolist()\\n\",\n    \"    \\n\",\n    \"    # Benchmark all approaches\\n\",\n    \"    approaches = [\\n\",\n    \"        (\\\"Traditional loop\\\", approach_1_loop),\\n\",\n    \"        (\\\"List comprehension\\\", approach_2_comprehension),\\n\",\n    \"        (\\\"Map function\\\", approach_3_map),\\n\",\n    \"        (\\\"NumPy vectorized\\\", approach_4_numpy)\\n\",\n    \"    ]\\n\",\n    \"    \\n\",\n    \"    compare_performance(approaches, data)\\n\",\n    \"\\n\",\n    \"# Run profiling demonstrations\\n\",\n    \"demonstrate_profiling()\\n\",\n    \"demonstrate_cprofile()\\n\",\n    \"demonstrate_benchmarking()\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Profiling Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Identifies performance bottlenecks\\\")\\n\",\n    \"print(f\\\"  ✅ Measures memory usage accurately\\\")\\n\",\n    \"print(f\\\"  ✅ Tracks cache effectiveness\\\")\\n\",\n    \"print(f\\\"  ✅ Compares different approaches objectively\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 4: Vectorized Operations with NumPy\\n\",\n    \"\\n\",\n    \"**First Principle**: Vectorized operations eliminate Python loops and leverage optimized C code for massive speedups.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use NumPy arrays and vectorized functions instead of Python loops for numerical computations.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class VectorizedTextProcessor:\\n\",\n    \"    \\\"\\\"\\\"Text processor using vectorized operations.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def batch_tokenize(texts: List[str]) -> List[List[str]]:\\n\",\n    \"        \\\"\\\"\\\"Vectorized tokenization.\\\"\\\"\\\"\\n\",\n    \"        # This is still Python-level, but demonstrates batch processing\\n\",\n    \"        return [text.lower().split() for text in texts]\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def batch_compute_lengths(texts: List[str]) -> np.ndarray:\\n\",\n    \"        \\\"\\\"\\\"Compute text lengths using NumPy.\\\"\\\"\\\"\\n\",\n    \"        return np.array([len(text) for text in texts])\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def batch_filter_by_length(texts: List[str], min_length: int) -> List[str]:\\n\",\n    \"        \\\"\\\"\\\"Filter texts by length using vectorized operations.\\\"\\\"\\\"\\n\",\n    \"        lengths = VectorizedTextProcessor.batch_compute_lengths(texts)\\n\",\n    \"        mask = lengths >= min_length\\n\",\n    \"        return [text for text, keep in zip(texts, mask) if keep]\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def batch_similarity_matrix(texts: List[str]) -> np.ndarray:\\n\",\n    \"        \\\"\\\"\\\"Compute similarity matrix using vectorized operations.\\\"\\\"\\\"\\n\",\n    \"        n = len(texts)\\n\",\n    \"        \\n\",\n    \"        # Get lengths as vectors\\n\",\n    \"        lengths = VectorizedTextProcessor.batch_compute_lengths(texts)\\n\",\n    \"        \\n\",\n    \"        # Compute pairwise length differences using broadcasting\\n\",\n    \"        length_diff = np.abs(lengths[:, np.newaxis] - lengths[np.newaxis, :])\\n\",\n    \"        \\n\",\n    \"        # Similarity based on length difference (simplified)\\n\",\n    \"        similarity = 1.0 / (1.0 + length_diff)\\n\",\n    \"        \\n\",\n    \"        # Set diagonal to 1.0 (self-similarity)\\n\",\n    \"        np.fill_diagonal(similarity, 1.0)\\n\",\n    \"        \\n\",\n    \"        return similarity\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def compute_text_features(texts: List[str]) -> np.ndarray:\\n\",\n    \"        \\\"\\\"\\\"Compute multiple text features efficiently.\\\"\\\"\\\"\\n\",\n    \"        n = len(texts)\\n\",\n    \"        features = np.zeros((n, 4))  # 4 features per text\\n\",\n    \"        \\n\",\n    \"        for i, text in enumerate(texts):\\n\",\n    \"            words = text.split()\\n\",\n    \"            features[i, 0] = len(text)  # Character count\\n\",\n    \"            features[i, 1] = len(words)  # Word count\\n\",\n    \"            features[i, 2] = len(set(words)) if words else 0  # Unique words\\n\",\n    \"            features[i, 3] = sum(len(word) for word in words) / len(words) if words else 0  # Avg word length\\n\",\n    \"        \\n\",\n    \"        return features\\n\",\n    \"\\n\",\n    \"def demonstrate_vectorization():\\n\",\n    \"    \\\"\\\"\\\"Show vectorized operations.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    console.print(Panel(\\\"⚡ Vectorized Operations\\\", style=\\\"bold magenta\\\"))\\n\",\n    \"    \\n\",\n    \"    # Create test data\\n\",\n    \"    test_texts = [f\\\"Sample text number {i} for vectorized processing analysis\\\" for i in range(1000)]\\n\",\n    \"    \\n\",\n    \"    print(\\\"📊 Comparing scalar vs vectorized operations:\\\")\\n\",\n    \"    \\n\",\n    \"    # Scalar operations (Python loops)\\n\",\n    \"    with profile_time(\\\"Scalar length computation\\\"):\\n\",\n    \"        scalar_lengths = [len(text) for text in test_texts]\\n\",\n    \"    \\n\",\n    \"    # Vectorized operations\\n\",\n    \"    with profile_time(\\\"Vectorized length computation\\\"):\\n\",\n    \"        vector_lengths = VectorizedTextProcessor.batch_compute_lengths(test_texts)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Results match: {np.array_equal(scalar_lengths, vector_lengths)}\\\")\\n\",\n    \"    \\n\",\n    \"    # Mathematical operations comparison\\n\",\n    \"    print(f\\\"\\\\n🔢 Mathematical operations comparison:\\\")\\n\",\n    \"    \\n\",\n    \"    data = list(range(100000))\\n\",\n    \"    \\n\",\n    \"    # Scalar math\\n\",\n    \"    with profile_time(\\\"Scalar math (sum of squares)\\\"):\\n\",\n    \"        scalar_result = sum(x*x for x in data)\\n\",\n    \"    \\n\",\n    \"    # Vectorized math\\n\",\n    \"    with profile_time(\\\"Vectorized math (sum of squares)\\\"):\\n\",\n    \"        arr = np.array(data)\\n\",\n    \"        vector_result = np.sum(arr**2)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Results match: {scalar_result == vector_result}\\\")\\n\",\n    \"    \\n\",\n    \"    # Complex vectorized operations\\n\",\n    \"    print(f\\\"\\\\n🧮 Complex vectorized operations:\\\")\\n\",\n    \"    \\n\",\n    \"    # Text feature extraction\\n\",\n    \"    sample_texts = test_texts[:100]\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Feature extraction\\\"):\\n\",\n    \"        features = VectorizedTextProcessor.compute_text_features(sample_texts)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Extracted features for {len(sample_texts)} texts\\\")\\n\",\n    \"    print(f\\\"  Feature matrix shape: {features.shape}\\\")\\n\",\n    \"    print(f\\\"  Average features: {np.mean(features, axis=0)}\\\")\\n\",\n    \"    \\n\",\n    \"    # Similarity matrix computation\\n\",\n    \"    small_sample = test_texts[:20]\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Similarity matrix computation\\\"):\\n\",\n    \"        similarity_matrix = VectorizedTextProcessor.batch_similarity_matrix(small_sample)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Similarity matrix shape: {similarity_matrix.shape}\\\")\\n\",\n    \"    print(f\\\"  Average similarity: {np.mean(similarity_matrix[similarity_matrix != 1.0]):.3f}\\\")\\n\",\n    \"    \\n\",\n    \"    # Broadcasting examples\\n\",\n    \"    print(f\\\"\\\\n📡 Broadcasting examples:\\\")\\n\",\n    \"    \\n\",\n    \"    # Create sample matrices\\n\",\n    \"    matrix_a = np.random.rand(1000, 50)\\n\",\n    \"    matrix_b = np.random.rand(50)\\n\",\n    \"    \\n\",\n    \"    # Broadcasting operation\\n\",\n    \"    with profile_time(\\\"Broadcasting operation (1000x50 + 50)\\\"):\\n\",\n    \"        result = matrix_a + matrix_b  # Broadcasting automatically applied\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Result shape: {result.shape}\\\")\\n\",\n    \"    \\n\",\n    \"    # Element-wise operations\\n\",\n    \"    large_array = np.random.rand(100000)\\n\",\n    \"    \\n\",\n    \"    operations = [\\n\",\n    \"        (\\\"Square\\\", lambda x: x**2),\\n\",\n    \"        (\\\"Square root\\\", lambda x: np.sqrt(x)),\\n\",\n    \"        (\\\"Exponential\\\", lambda x: np.exp(x)),\\n\",\n    \"        (\\\"Logarithm\\\", lambda x: np.log(x + 1e-8)),  # Add small value to avoid log(0)\\n\",\n    \"        (\\\"Trigonometric\\\", lambda x: np.sin(x) + np.cos(x))\\n\",\n    \"    ]\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n⚡ Element-wise operations on {len(large_array)} elements:\\\")\\n\",\n    \"    \\n\",\n    \"    for name, operation in operations:\\n\",\n    \"        with profile_time(f\\\"{name} operation\\\"):\\n\",\n    \"            result = operation(large_array)\\n\",\n    \"        print(f\\\"  {name}: min={np.min(result):.3f}, max={np.max(result):.3f}, mean={np.mean(result):.3f}\\\")\\n\",\n    \"\\n\",\n    \"# Advanced vectorization patterns\\n\",\n    \"def demonstrate_advanced_vectorization():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate advanced vectorization patterns.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n🚀 Advanced vectorization patterns:\\\")\\n\",\n    \"    \\n\",\n    \"    # Conditional operations with where\\n\",\n    \"    data = np.random.randn(10000)\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Conditional operations with np.where\\\"):\\n\",\n    \"        # Replace negative values with 0, keep positive\\n\",\n    \"        result = np.where(data > 0, data, 0)\\n\",\n    \"    \\n\",\n    \"    positive_count = np.sum(result > 0)\\n\",\n    \"    print(f\\\"  Positive values: {positive_count}/{len(data)}\\\")\\n\",\n    \"    \\n\",\n    \"    # Vectorized string operations\\n\",\n    \"    text_data = np.array([f\\\"text_{i}\\\" for i in range(1000)])\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Vectorized string operations\\\"):\\n\",\n    \"        # Vectorized string length\\n\",\n    \"        str_lengths = np.char.str_len(text_data)\\n\",\n    \"        # Vectorized string operations\\n\",\n    \"        upper_texts = np.char.upper(text_data)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  String operations completed on {len(text_data)} strings\\\")\\n\",\n    \"    \\n\",\n    \"    # Aggregation operations\\n\",\n    \"    matrix = np.random.rand(1000, 100)\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Matrix aggregations\\\"):\\n\",\n    \"        row_sums = np.sum(matrix, axis=1)  # Sum each row\\n\",\n    \"        col_means = np.mean(matrix, axis=0)  # Mean of each column\\n\",\n    \"        global_std = np.std(matrix)  # Standard deviation of entire matrix\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Row sums: {len(row_sums)}, Col means: {len(col_means)}, Global std: {global_std:.3f}\\\")\\n\",\n    \"    \\n\",\n    \"    # Fancy indexing\\n\",\n    \"    large_data = np.random.rand(100000)\\n\",\n    \"    indices = np.random.randint(0, len(large_data), 10000)\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Fancy indexing\\\"):\\n\",\n    \"        selected_data = large_data[indices]\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Selected {len(selected_data)} elements using fancy indexing\\\")\\n\",\n    \"    \\n\",\n    \"    # Boolean indexing\\n\",\n    \"    with profile_time(\\\"Boolean indexing\\\"):\\n\",\n    \"        filtered_data = large_data[large_data > 0.5]\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Filtered to {len(filtered_data)} elements using boolean indexing\\\")\\n\",\n    \"\\n\",\n    \"# Memory layout optimization\\n\",\n    \"def demonstrate_memory_layout():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate memory layout optimization.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n💾 Memory layout optimization:\\\")\\n\",\n    \"    \\n\",\n    \"    # C-contiguous vs Fortran-contiguous\\n\",\n    \"    size = (1000, 1000)\\n\",\n    \"    \\n\",\n    \"    c_array = np.random.rand(*size)  # C-contiguous (row-major)\\n\",\n    \"    f_array = np.asfortranarray(c_array)  # Fortran-contiguous (column-major)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  C-array is C-contiguous: {c_array.flags.c_contiguous}\\\")\\n\",\n    \"    print(f\\\"  F-array is Fortran-contiguous: {f_array.flags.f_contiguous}\\\")\\n\",\n    \"    \\n\",\n    \"    # Row-wise operations (faster on C-contiguous)\\n\",\n    \"    with profile_time(\\\"Row-wise sum on C-contiguous\\\"):\\n\",\n    \"        c_row_sums = np.sum(c_array, axis=1)\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Row-wise sum on F-contiguous\\\"):\\n\",\n    \"        f_row_sums = np.sum(f_array, axis=1)\\n\",\n    \"    \\n\",\n    \"    # Column-wise operations (faster on Fortran-contiguous)\\n\",\n    \"    with profile_time(\\\"Column-wise sum on C-contiguous\\\"):\\n\",\n    \"        c_col_sums = np.sum(c_array, axis=0)\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Column-wise sum on F-contiguous\\\"):\\n\",\n    \"        f_col_sums = np.sum(f_array, axis=0)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Results are equal: {np.allclose(c_row_sums, f_row_sums) and np.allclose(c_col_sums, f_col_sums)}\\\")\\n\",\n    \"\\n\",\n    \"# Run vectorization demonstrations\\n\",\n    \"demonstrate_vectorization()\\n\",\n    \"demonstrate_advanced_vectorization()\\n\",\n    \"demonstrate_memory_layout()\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Vectorization Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ 10-100x speedup for numerical operations\\\")\\n\",\n    \"print(f\\\"  ✅ Memory-efficient operations\\\")\\n\",\n    \"print(f\\\"  ✅ Automatic parallelization in many cases\\\")\\n\",\n    \"print(f\\\"  ✅ Leverages optimized BLAS/LAPACK libraries\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 5: Parallel Processing Patterns\\n\",\n    \"\\n\",\n    \"**First Principle**: Parallel processing leverages multiple cores for CPU-bound tasks and multiple threads for I/O-bound tasks.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use `ThreadPoolExecutor` for I/O-bound tasks, `ProcessPoolExecutor` for CPU-bound tasks.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"class ParallelProcessor:\\n\",\n    \"    \\\"\\\"\\\"Utilities for parallel processing.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def parallel_map_threads(\\n\",\n    \"        func: Callable, \\n\",\n    \"        items: List[Any], \\n\",\n    \"        max_workers: int = 4\\n\",\n    \"    ) -> List[Any]:\\n\",\n    \"        \\\"\\\"\\\"Parallel map using threads (I/O bound tasks).\\\"\\\"\\\"\\n\",\n    \"        with ThreadPoolExecutor(max_workers=max_workers) as executor:\\n\",\n    \"            results = list(executor.map(func, items))\\n\",\n    \"        return results\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def parallel_map_processes(\\n\",\n    \"        func: Callable, \\n\",\n    \"        items: List[Any], \\n\",\n    \"        max_workers: int = None\\n\",\n    \"    ) -> List[Any]:\\n\",\n    \"        \\\"\\\"\\\"Parallel map using processes (CPU bound tasks).\\\"\\\"\\\"\\n\",\n    \"        if max_workers is None:\\n\",\n    \"            max_workers = mp.cpu_count()\\n\",\n    \"        \\n\",\n    \"        with ProcessPoolExecutor(max_workers=max_workers) as executor:\\n\",\n    \"            results = list(executor.map(func, items))\\n\",\n    \"        return results\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def parallel_batch_process(\\n\",\n    \"        items: List[Any], \\n\",\n    \"        batch_func: Callable[[List[Any]], List[Any]], \\n\",\n    \"        batch_size: int = 100,\\n\",\n    \"        max_workers: int = 4,\\n\",\n    \"        use_processes: bool = False\\n\",\n    \"    ) -> List[Any]:\\n\",\n    \"        \\\"\\\"\\\"Process items in parallel batches.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        # Split into batches\\n\",\n    \"        batches = [items[i:i + batch_size] for i in range(0, len(items), batch_size)]\\n\",\n    \"        \\n\",\n    \"        # Process batches in parallel\\n\",\n    \"        if use_processes:\\n\",\n    \"            with ProcessPoolExecutor(max_workers=max_workers) as executor:\\n\",\n    \"                batch_results = list(executor.map(batch_func, batches))\\n\",\n    \"        else:\\n\",\n    \"            with ThreadPoolExecutor(max_workers=max_workers) as executor:\\n\",\n    \"                batch_results = list(executor.map(batch_func, batches))\\n\",\n    \"        \\n\",\n    \"        # Flatten results\\n\",\n    \"        results = []\\n\",\n    \"        for batch_result in batch_results:\\n\",\n    \"            results.extend(batch_result)\\n\",\n    \"        \\n\",\n    \"        return results\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def parallel_as_completed(\\n\",\n    \"        func: Callable,\\n\",\n    \"        items: List[Any],\\n\",\n    \"        max_workers: int = 4,\\n\",\n    \"        use_processes: bool = False\\n\",\n    \"    ) -> Iterator[Tuple[Any, Any]]:\\n\",\n    \"        \\\"\\\"\\\"Process items in parallel, yielding results as they complete.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        executor_class = ProcessPoolExecutor if use_processes else ThreadPoolExecutor\\n\",\n    \"        \\n\",\n    \"        with executor_class(max_workers=max_workers) as executor:\\n\",\n    \"            # Submit all tasks\\n\",\n    \"            future_to_item = {executor.submit(func, item): item for item in items}\\n\",\n    \"            \\n\",\n    \"            # Yield results as they complete\\n\",\n    \"            for future in as_completed(future_to_item):\\n\",\n    \"                item = future_to_item[future]\\n\",\n    \"                try:\\n\",\n    \"                    result = future.result()\\n\",\n    \"                    yield item, result\\n\",\n    \"                except Exception as exc:\\n\",\n    \"                    yield item, exc\\n\",\n    \"\\n\",\n    \"# Example functions for parallel processing\\n\",\n    \"def cpu_intensive_task(data: str) -> str:\\n\",\n    \"    \\\"\\\"\\\"CPU-intensive task for parallel processing demo.\\\"\\\"\\\"\\n\",\n    \"    # Simulate CPU work with hashing\\n\",\n    \"    result = data\\n\",\n    \"    for _ in range(10000):  # Increased iterations for more CPU work\\n\",\n    \"        result = str(hash(result))[:10]\\n\",\n    \"    return f\\\"CPU_PROCESSED: {result}\\\"\\n\",\n    \"\\n\",\n    \"def io_intensive_task(data: str) -> str:\\n\",\n    \"    \\\"\\\"\\\"I/O-intensive task for parallel processing demo.\\\"\\\"\\\"\\n\",\n    \"    # Simulate I/O wait\\n\",\n    \"    time.sleep(0.1)\\n\",\n    \"    return f\\\"IO_PROCESSED: {data.upper()}\\\"\\n\",\n    \"\\n\",\n    \"def mixed_workload_task(data: str) -> str:\\n\",\n    \"    \\\"\\\"\\\"Mixed CPU and I/O task.\\\"\\\"\\\"\\n\",\n    \"    # CPU work\\n\",\n    \"    result = str(hash(data * 1000))\\n\",\n    \"    # I/O simulation\\n\",\n    \"    time.sleep(0.02)\\n\",\n    \"    return f\\\"MIXED: {result[:8]}\\\"\\n\",\n    \"\\n\",\n    \"def batch_text_processor(texts: List[str]) -> List[str]:\\n\",\n    \"    \\\"\\\"\\\"Process a batch of texts efficiently.\\\"\\\"\\\"\\n\",\n    \"    # Simulate batch processing efficiency\\n\",\n    \"    time.sleep(0.01)  # Setup overhead per batch\\n\",\n    \"    \\n\",\n    \"    results = []\\n\",\n    \"    for text in texts:\\n\",\n    \"        # Faster per-item processing in batch\\n\",\n    \"        processed = text.upper().replace(\\\" \\\", \\\"_\\\")\\n\",\n    \"        results.append(f\\\"BATCH_{processed}\\\")\\n\",\n    \"    \\n\",\n    \"    return results\\n\",\n    \"\\n\",\n    \"def demonstrate_parallel_processing():\\n\",\n    \"    \\\"\\\"\\\"Show parallel processing patterns.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    console.print(Panel(\\\"🚀 Parallel Processing\\\", style=\\\"bold cyan\\\"))\\n\",\n    \"    \\n\",\n    \"    # Create test data\\n\",\n    \"    test_data = [f\\\"data_item_{i}\\\" for i in range(20)]\\n\",\n    \"    \\n\",\n    \"    print(\\\"⚙️ Comparing sequential vs parallel processing:\\\")\\n\",\n    \"    \\n\",\n    \"    # CPU-bound task comparison\\n\",\n    \"    print(f\\\"\\\\n🧮 CPU-bound tasks:\\\")\\n\",\n    \"    \\n\",\n    \"    # Sequential processing\\n\",\n    \"    with profile_time(\\\"Sequential CPU processing\\\"):\\n\",\n    \"        sequential_cpu_results = [cpu_intensive_task(item) for item in test_data[:8]]  # Smaller subset\\n\",\n    \"    \\n\",\n    \"    # Parallel processing with processes\\n\",\n    \"    with profile_time(\\\"Parallel CPU processing (processes)\\\"):\\n\",\n    \"        parallel_cpu_results = ParallelProcessor.parallel_map_processes(\\n\",\n    \"            cpu_intensive_task, test_data[:8], max_workers=2\\n\",\n    \"        )\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Results match: {sequential_cpu_results == parallel_cpu_results}\\\")\\n\",\n    \"    print(f\\\"  Processed {len(parallel_cpu_results)} items\\\")\\n\",\n    \"    \\n\",\n    \"    # I/O-bound task comparison\\n\",\n    \"    print(f\\\"\\\\n💾 I/O-bound tasks:\\\")\\n\",\n    \"    \\n\",\n    \"    # Sequential I/O\\n\",\n    \"    with profile_time(\\\"Sequential I/O processing\\\"):\\n\",\n    \"        sequential_io_results = [io_intensive_task(item) for item in test_data[:10]]\\n\",\n    \"    \\n\",\n    \"    # Parallel I/O with threads\\n\",\n    \"    with profile_time(\\\"Parallel I/O processing (threads)\\\"):\\n\",\n    \"        parallel_io_results = ParallelProcessor.parallel_map_threads(\\n\",\n    \"            io_intensive_task, test_data[:10], max_workers=5\\n\",\n    \"        )\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Results match: {set(sequential_io_results) == set(parallel_io_results)}\\\")\\n\",\n    \"    print(f\\\"  Processed {len(parallel_io_results)} items\\\")\\n\",\n    \"    \\n\",\n    \"    # Batch processing comparison\\n\",\n    \"    print(f\\\"\\\\n📦 Batch processing:\\\")\\n\",\n    \"    \\n\",\n    \"    large_dataset = [f\\\"text_{i}\\\" for i in range(100)]\\n\",\n    \"    \\n\",\n    \"    # Individual processing\\n\",\n    \"    with profile_time(\\\"Individual processing\\\"):\\n\",\n    \"        individual_results = [item.upper().replace(\\\" \\\", \\\"_\\\") for item in large_dataset]\\n\",\n    \"    \\n\",\n    \"    # Batch processing\\n\",\n    \"    with profile_time(\\\"Parallel batch processing\\\"):\\n\",\n    \"        batch_results = ParallelProcessor.parallel_batch_process(\\n\",\n    \"            large_dataset, batch_text_processor, batch_size=20, max_workers=3\\n\",\n    \"        )\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Individual results: {len(individual_results)}\\\")\\n\",\n    \"    print(f\\\"  Batch results: {len(batch_results)}\\\")\\n\",\n    \"    \\n\",\n    \"    # Progressive results with as_completed\\n\",\n    \"    print(f\\\"\\\\n⏱️ Progressive results (as_completed pattern):\\\")\\n\",\n    \"    \\n\",\n    \"    mixed_data = [f\\\"mixed_{i}\\\" for i in range(8)]\\n\",\n    \"    \\n\",\n    \"    start_time = time.time()\\n\",\n    \"    completed_count = 0\\n\",\n    \"    \\n\",\n    \"    for item, result in ParallelProcessor.parallel_as_completed(\\n\",\n    \"        mixed_workload_task, mixed_data, max_workers=3\\n\",\n    \"    ):\\n\",\n    \"        completed_count += 1\\n\",\n    \"        elapsed = time.time() - start_time\\n\",\n    \"        \\n\",\n    \"        if isinstance(result, Exception):\\n\",\n    \"            print(f\\\"  {elapsed:.2f}s: {item} FAILED - {result}\\\")\\n\",\n    \"        else:\\n\",\n    \"            print(f\\\"  {elapsed:.2f}s: {item} -> {result[:20]}...\\\")\\n\",\n    \"    \\n\",\n    \"    total_time = time.time() - start_time\\n\",\n    \"    print(f\\\"  Completed {completed_count} tasks in {total_time:.2f}s\\\")\\n\",\n    \"\\n\",\n    \"# Advanced parallel patterns\\n\",\n    \"def demonstrate_advanced_parallel_patterns():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate advanced parallel processing patterns.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n🎯 Advanced parallel patterns:\\\")\\n\",\n    \"    \\n\",\n    \"    # Map-Reduce pattern\\n\",\n    \"    def map_phase(data_chunk: List[int]) -> Dict[str, int]:\\n\",\n    \"        \\\"\\\"\\\"Map phase: process chunk and return key-value pairs.\\\"\\\"\\\"\\n\",\n    \"        result = {\\\"even\\\": 0, \\\"odd\\\": 0, \\\"sum\\\": 0}\\n\",\n    \"        for num in data_chunk:\\n\",\n    \"            if num % 2 == 0:\\n\",\n    \"                result[\\\"even\\\"] += 1\\n\",\n    \"            else:\\n\",\n    \"                result[\\\"odd\\\"] += 1\\n\",\n    \"            result[\\\"sum\\\"] += num\\n\",\n    \"        return result\\n\",\n    \"    \\n\",\n    \"    def reduce_phase(results: List[Dict[str, int]]) -> Dict[str, int]:\\n\",\n    \"        \\\"\\\"\\\"Reduce phase: combine results from all workers.\\\"\\\"\\\"\\n\",\n    \"        final_result = {\\\"even\\\": 0, \\\"odd\\\": 0, \\\"sum\\\": 0}\\n\",\n    \"        for result in results:\\n\",\n    \"            for key in final_result:\\n\",\n    \"                final_result[key] += result[key]\\n\",\n    \"        return final_result\\n\",\n    \"    \\n\",\n    \"    # Generate test data\\n\",\n    \"    large_numbers = list(range(10000))\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Map-Reduce pattern\\\"):\\n\",\n    \"        # Split data into chunks\\n\",\n    \"        chunk_size = 1000\\n\",\n    \"        chunks = [large_numbers[i:i + chunk_size] for i in range(0, len(large_numbers), chunk_size)]\\n\",\n    \"        \\n\",\n    \"        # Map phase (parallel)\\n\",\n    \"        map_results = ParallelProcessor.parallel_map_processes(map_phase, chunks, max_workers=3)\\n\",\n    \"        \\n\",\n    \"        # Reduce phase (sequential)\\n\",\n    \"        final_result = reduce_phase(map_results)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Map-Reduce result: {final_result}\\\")\\n\",\n    \"    \\n\",\n    \"    # Pipeline pattern\\n\",\n    \"    print(f\\\"\\\\n🔄 Pipeline processing pattern:\\\")\\n\",\n    \"    \\n\",\n    \"    def stage1_preprocess(data: str) -> str:\\n\",\n    \"        \\\"\\\"\\\"Stage 1: Preprocessing.\\\"\\\"\\\"\\n\",\n    \"        time.sleep(0.01)\\n\",\n    \"        return f\\\"PREPROCESSED_{data}\\\"\\n\",\n    \"    \\n\",\n    \"    def stage2_analyze(data: str) -> str:\\n\",\n    \"        \\\"\\\"\\\"Stage 2: Analysis.\\\"\\\"\\\"\\n\",\n    \"        time.sleep(0.02)\\n\",\n    \"        return f\\\"ANALYZED_{data}\\\"\\n\",\n    \"    \\n\",\n    \"    def stage3_postprocess(data: str) -> str:\\n\",\n    \"        \\\"\\\"\\\"Stage 3: Post-processing.\\\"\\\"\\\"\\n\",\n    \"        time.sleep(0.01)\\n\",\n    \"        return f\\\"FINAL_{data}\\\"\\n\",\n    \"    \\n\",\n    \"    pipeline_data = [f\\\"item_{i}\\\" for i in range(20)]\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Sequential pipeline\\\"):\\n\",\n    \"        # Sequential pipeline\\n\",\n    \"        stage1_results = [stage1_preprocess(item) for item in pipeline_data]\\n\",\n    \"        stage2_results = [stage2_analyze(item) for item in stage1_results]\\n\",\n    \"        stage3_results = [stage3_postprocess(item) for item in stage2_results]\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Parallel pipeline\\\"):\\n\",\n    \"        # Parallel pipeline\\n\",\n    \"        stage1_parallel = ParallelProcessor.parallel_map_threads(stage1_preprocess, pipeline_data, max_workers=3)\\n\",\n    \"        stage2_parallel = ParallelProcessor.parallel_map_threads(stage2_analyze, stage1_parallel, max_workers=3)\\n\",\n    \"        stage3_parallel = ParallelProcessor.parallel_map_threads(stage3_postprocess, stage2_parallel, max_workers=3)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Sequential pipeline: {len(stage3_results)} items\\\")\\n\",\n    \"    print(f\\\"  Parallel pipeline: {len(stage3_parallel)} items\\\")\\n\",\n    \"    \\n\",\n    \"    # Worker pool with different task types\\n\",\n    \"    print(f\\\"\\\\n👥 Mixed workload distribution:\\\")\\n\",\n    \"    \\n\",\n    \"    # Create mixed tasks\\n\",\n    \"    cpu_tasks = [(\\\"cpu\\\", f\\\"cpu_task_{i}\\\") for i in range(4)]\\n\",\n    \"    io_tasks = [(\\\"io\\\", f\\\"io_task_{i}\\\") for i in range(8)]\\n\",\n    \"    all_tasks = cpu_tasks + io_tasks\\n\",\n    \"    \\n\",\n    \"    def process_mixed_task(task_info: Tuple[str, str]) -> str:\\n\",\n    \"        task_type, data = task_info\\n\",\n    \"        if task_type == \\\"cpu\\\":\\n\",\n    \"            return cpu_intensive_task(data)\\n\",\n    \"        else:\\n\",\n    \"            return io_intensive_task(data)\\n\",\n    \"    \\n\",\n    \"    # Process with appropriate parallelization\\n\",\n    \"    with profile_time(\\\"Mixed workload processing\\\"):\\n\",\n    \"        # Separate CPU and I/O tasks\\n\",\n    \"        cpu_results = ParallelProcessor.parallel_map_processes(\\n\",\n    \"            process_mixed_task, cpu_tasks, max_workers=2\\n\",\n    \"        )\\n\",\n    \"        io_results = ParallelProcessor.parallel_map_threads(\\n\",\n    \"            process_mixed_task, io_tasks, max_workers=4\\n\",\n    \"        )\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  CPU tasks completed: {len(cpu_results)}\\\")\\n\",\n    \"    print(f\\\"  I/O tasks completed: {len(io_results)}\\\")\\n\",\n    \"\\n\",\n    \"# System information\\n\",\n    \"def show_system_info():\\n\",\n    \"    \\\"\\\"\\\"Show system information for parallel processing.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n💻 System Information:\\\")\\n\",\n    \"    print(f\\\"  CPU cores: {mp.cpu_count()}\\\")\\n\",\n    \"    print(f\\\"  Active threads: {threading.active_count()}\\\")\\n\",\n    \"    print(f\\\"  Current process ID: {mp.current_process().pid}\\\")\\n\",\n    \"\\n\",\n    \"# Run parallel processing demonstrations\\n\",\n    \"show_system_info()\\n\",\n    \"demonstrate_parallel_processing()\\n\",\n    \"demonstrate_advanced_parallel_patterns()\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n💡 Parallel Processing Benefits:\\\")\\n\",\n    \"print(f\\\"  ✅ Utilizes multiple CPU cores\\\")\\n\",\n    \"print(f\\\"  ✅ Overlaps I/O operations\\\")\\n\",\n    \"print(f\\\"  ✅ Scales with available hardware\\\")\\n\",\n    \"print(f\\\"  ✅ Improves throughput for batch operations\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Cell 6: Production Performance System\\n\",\n    \"\\n\",\n    \"**First Principle**: Combine all performance techniques to create a comprehensive, optimized AI processing system.\\n\",\n    \"\\n\",\n    \"**Python Idiom**: Use composition of optimized components to build high-performance systems.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Complete high-performance AI processing system\\n\",\n    \"from dataclasses import dataclass, field\\n\",\n    \"from typing import Union\\n\",\n    \"import pickle\\n\",\n    \"import hashlib\\n\",\n    \"import os\\n\",\n    \"\\n\",\n    \"@dataclass\\n\",\n    \"class PerformanceConfig:\\n\",\n    \"    \\\"\\\"\\\"Configuration for performance optimization.\\\"\\\"\\\"\\n\",\n    \"    enable_caching: bool = True\\n\",\n    \"    cache_size: int = 1000\\n\",\n    \"    cache_ttl: float = 3600.0  # 1 hour\\n\",\n    \"    enable_parallel: bool = True\\n\",\n    \"    max_workers: int = 4\\n\",\n    \"    batch_size: int = 100\\n\",\n    \"    enable_vectorization: bool = True\\n\",\n    \"    memory_limit_mb: float = 500.0\\n\",\n    \"    enable_profiling: bool = False\\n\",\n    \"\\n\",\n    \"@dataclass\\n\",\n    \"class ProcessingResult:\\n\",\n    \"    \\\"\\\"\\\"Result from AI processing.\\\"\\\"\\\"\\n\",\n    \"    data: Any\\n\",\n    \"    processing_time: float\\n\",\n    \"    from_cache: bool = False\\n\",\n    \"    worker_id: Optional[str] = None\\n\",\n    \"    memory_used_mb: float = 0.0\\n\",\n    \"\\n\",\n    \"class HighPerformanceAIProcessor:\\n\",\n    \"    \\\"\\\"\\\"High-performance AI processor using all optimization techniques.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, config: PerformanceConfig):\\n\",\n    \"        self.config = config\\n\",\n    \"        \\n\",\n    \"        # Performance components\\n\",\n    \"        self.cache = MemoryEfficientCache(\\n\",\n    \"            max_size=config.cache_size,\\n\",\n    \"            max_memory_mb=config.memory_limit_mb * 0.5  # Use half memory limit for cache\\n\",\n    \"        ) if config.enable_caching else None\\n\",\n    \"        \\n\",\n    \"        self.monitor = PerformanceMonitor() if config.enable_profiling else None\\n\",\n    \"        \\n\",\n    \"        # Object pool for expensive resources\\n\",\n    \"        self.resource_pool = ObjectPool(\\n\",\n    \"            factory=lambda: {\\\"id\\\": f\\\"resource_{time.time()}\\\", \\\"data\\\": np.zeros(1000)},\\n\",\n    \"            max_size=config.max_workers\\n\",\n    \"        )\\n\",\n    \"        \\n\",\n    \"        # Processing statistics\\n\",\n    \"        self.stats = {\\n\",\n    \"            \\\"total_processed\\\": 0,\\n\",\n    \"            \\\"cache_hits\\\": 0,\\n\",\n    \"            \\\"cache_misses\\\": 0,\\n\",\n    \"            \\\"total_time\\\": 0.0,\\n\",\n    \"            \\\"parallel_batches\\\": 0,\\n\",\n    \"            \\\"vectorized_operations\\\": 0\\n\",\n    \"        }\\n\",\n    \"    \\n\",\n    \"    def _generate_cache_key(self, data: Any, operation: str) -> str:\\n\",\n    \"        \\\"\\\"\\\"Generate cache key for data and operation.\\\"\\\"\\\"\\n\",\n    \"        data_str = str(data) if len(str(data)) < 1000 else str(hash(str(data)))\\n\",\n    \"        return hashlib.md5(f\\\"{operation}_{data_str}\\\".encode()).hexdigest()\\n\",\n    \"    \\n\",\n    \"    def _check_cache(self, cache_key: str) -> Optional[ProcessingResult]:\\n\",\n    \"        \\\"\\\"\\\"Check if result is cached.\\\"\\\"\\\"\\n\",\n    \"        if not self.cache:\\n\",\n    \"            return None\\n\",\n    \"        \\n\",\n    \"        cached = self.cache.get(cache_key)\\n\",\n    \"        if cached:\\n\",\n    \"            self.stats[\\\"cache_hits\\\"] += 1\\n\",\n    \"            return ProcessingResult(\\n\",\n    \"                data=cached,\\n\",\n    \"                processing_time=0.0,\\n\",\n    \"                from_cache=True\\n\",\n    \"            )\\n\",\n    \"        \\n\",\n    \"        self.stats[\\\"cache_misses\\\"] += 1\\n\",\n    \"        return None\\n\",\n    \"    \\n\",\n    \"    def _store_cache(self, cache_key: str, result: Any):\\n\",\n    \"        \\\"\\\"\\\"Store result in cache.\\\"\\\"\\\"\\n\",\n    \"        if self.cache:\\n\",\n    \"            self.cache.put(cache_key, result)\\n\",\n    \"    \\n\",\n    \"    def process_single(self, data: Any, operation: str = \\\"default\\\") -> ProcessingResult:\\n\",\n    \"        \\\"\\\"\\\"Process a single item with full optimization.\\\"\\\"\\\"\\n\",\n    \"        start_time = time.perf_counter()\\n\",\n    \"        \\n\",\n    \"        # Check cache\\n\",\n    \"        cache_key = self._generate_cache_key(data, operation)\\n\",\n    \"        cached_result = self._check_cache(cache_key)\\n\",\n    \"        if cached_result:\\n\",\n    \"            return cached_result\\n\",\n    \"        \\n\",\n    \"        # Process with resource pooling\\n\",\n    \"        with self.resource_pool.borrow() as resource:\\n\",\n    \"            # Simulate AI processing based on operation\\n\",\n    \"            if operation == \\\"classify\\\":\\n\",\n    \"                result = self._classify(data, resource)\\n\",\n    \"            elif operation == \\\"vectorize\\\":\\n\",\n    \"                result = self._vectorize(data, resource)\\n\",\n    \"            elif operation == \\\"analyze\\\":\\n\",\n    \"                result = self._analyze(data, resource)\\n\",\n    \"            else:\\n\",\n    \"                result = self._default_process(data, resource)\\n\",\n    \"        \\n\",\n    \"        processing_time = time.perf_counter() - start_time\\n\",\n    \"        \\n\",\n    \"        # Store in cache\\n\",\n    \"        self._store_cache(cache_key, result)\\n\",\n    \"        \\n\",\n    \"        # Update statistics\\n\",\n    \"        self.stats[\\\"total_processed\\\"] += 1\\n\",\n    \"        self.stats[\\\"total_time\\\"] += processing_time\\n\",\n    \"        \\n\",\n    \"        if self.monitor:\\n\",\n    \"            self.monitor.record_time(operation, processing_time)\\n\",\n    \"        \\n\",\n    \"        return ProcessingResult(\\n\",\n    \"            data=result,\\n\",\n    \"            processing_time=processing_time,\\n\",\n    \"            from_cache=False,\\n\",\n    \"            worker_id=resource[\\\"id\\\"]\\n\",\n    \"        )\\n\",\n    \"    \\n\",\n    \"    def process_batch(self, data_list: List[Any], operation: str = \\\"default\\\") -> List[ProcessingResult]:\\n\",\n    \"        \\\"\\\"\\\"Process batch with parallel and vectorized optimization.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        if not self.config.enable_parallel or len(data_list) < self.config.batch_size:\\n\",\n    \"            # Sequential processing for small batches\\n\",\n    \"            return [self.process_single(data, operation) for data in data_list]\\n\",\n    \"        \\n\",\n    \"        # Parallel batch processing\\n\",\n    \"        def process_batch_chunk(chunk: List[Any]) -> List[ProcessingResult]:\\n\",\n    \"            return [self.process_single(data, operation) for data in chunk]\\n\",\n    \"        \\n\",\n    \"        start_time = time.perf_counter()\\n\",\n    \"        \\n\",\n    \"        results = ParallelProcessor.parallel_batch_process(\\n\",\n    \"            data_list,\\n\",\n    \"            process_batch_chunk,\\n\",\n    \"            batch_size=self.config.batch_size,\\n\",\n    \"            max_workers=self.config.max_workers,\\n\",\n    \"            use_processes=False  # Use threads for I/O-bound AI operations\\n\",\n    \"        )\\n\",\n    \"        \\n\",\n    \"        batch_time = time.perf_counter() - start_time\\n\",\n    \"        self.stats[\\\"parallel_batches\\\"] += 1\\n\",\n    \"        \\n\",\n    \"        if self.monitor:\\n\",\n    \"            self.monitor.record_time(f\\\"batch_{operation}\\\", batch_time)\\n\",\n    \"        \\n\",\n    \"        return results\\n\",\n    \"    \\n\",\n    \"    def process_vectorized(self, data_array: np.ndarray, operation: str = \\\"vectorized\\\") -> ProcessingResult:\\n\",\n    \"        \\\"\\\"\\\"Process data using vectorized operations.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        if not self.config.enable_vectorization:\\n\",\n    \"            # Fall back to element-wise processing\\n\",\n    \"            results = [self.process_single(item, operation) for item in data_array]\\n\",\n    \"            return ProcessingResult(\\n\",\n    \"                data=[r.data for r in results],\\n\",\n    \"                processing_time=sum(r.processing_time for r in results),\\n\",\n    \"                from_cache=False\\n\",\n    \"            )\\n\",\n    \"        \\n\",\n    \"        start_time = time.perf_counter()\\n\",\n    \"        \\n\",\n    \"        # Vectorized processing\\n\",\n    \"        if operation == \\\"normalize\\\":\\n\",\n    \"            # Normalize data using vectorized operations\\n\",\n    \"            mean = np.mean(data_array, axis=0)\\n\",\n    \"            std = np.std(data_array, axis=0)\\n\",\n    \"            result = (data_array - mean) / (std + 1e-8)\\n\",\n    \"            \\n\",\n    \"        elif operation == \\\"similarity\\\":\\n\",\n    \"            # Compute pairwise similarities\\n\",\n    \"            result = np.dot(data_array, data_array.T)\\n\",\n    \"            \\n\",\n    \"        elif operation == \\\"transform\\\":\\n\",\n    \"            # Apply mathematical transformations\\n\",\n    \"            result = np.log(1 + np.abs(data_array))\\n\",\n    \"            \\n\",\n    \"        else:\\n\",\n    \"            # Default vectorized operation\\n\",\n    \"            result = data_array ** 2 + np.sin(data_array)\\n\",\n    \"        \\n\",\n    \"        processing_time = time.perf_counter() - start_time\\n\",\n    \"        \\n\",\n    \"        self.stats[\\\"vectorized_operations\\\"] += 1\\n\",\n    \"        self.stats[\\\"total_processed\\\"] += len(data_array)\\n\",\n    \"        self.stats[\\\"total_time\\\"] += processing_time\\n\",\n    \"        \\n\",\n    \"        if self.monitor:\\n\",\n    \"            self.monitor.record_time(f\\\"vectorized_{operation}\\\", processing_time)\\n\",\n    \"        \\n\",\n    \"        return ProcessingResult(\\n\",\n    \"            data=result,\\n\",\n    \"            processing_time=processing_time,\\n\",\n    \"            from_cache=False\\n\",\n    \"        )\\n\",\n    \"    \\n\",\n    \"    def _classify(self, data: Any, resource: Dict) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Simulate classification.\\\"\\\"\\\"\\n\",\n    \"        time.sleep(0.01)  # Simulate processing\\n\",\n    \"        confidence = hash(str(data)) % 100 / 100.0\\n\",\n    \"        return {\\n\",\n    \"            \\\"label\\\": \\\"positive\\\" if confidence > 0.5 else \\\"negative\\\",\\n\",\n    \"            \\\"confidence\\\": confidence,\\n\",\n    \"            \\\"resource_id\\\": resource[\\\"id\\\"]\\n\",\n    \"        }\\n\",\n    \"    \\n\",\n    \"    def _vectorize(self, data: Any, resource: Dict) -> List[float]:\\n\",\n    \"        \\\"\\\"\\\"Simulate vectorization.\\\"\\\"\\\"\\n\",\n    \"        time.sleep(0.005)\\n\",\n    \"        # Create feature vector\\n\",\n    \"        features = []\\n\",\n    \"        data_str = str(data)\\n\",\n    \"        for i in range(10):\\n\",\n    \"            features.append(hash(data_str + str(i)) % 1000 / 1000.0)\\n\",\n    \"        return features\\n\",\n    \"    \\n\",\n    \"    def _analyze(self, data: Any, resource: Dict) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Simulate analysis.\\\"\\\"\\\"\\n\",\n    \"        time.sleep(0.02)\\n\",\n    \"        data_str = str(data)\\n\",\n    \"        return {\\n\",\n    \"            \\\"length\\\": len(data_str),\\n\",\n    \"            \\\"complexity\\\": len(set(data_str)) / len(data_str) if data_str else 0,\\n\",\n    \"            \\\"hash_value\\\": hash(data_str),\\n\",\n    \"            \\\"resource_id\\\": resource[\\\"id\\\"]\\n\",\n    \"        }\\n\",\n    \"    \\n\",\n    \"    def _default_process(self, data: Any, resource: Dict) -> str:\\n\",\n    \"        \\\"\\\"\\\"Default processing.\\\"\\\"\\\"\\n\",\n    \"        time.sleep(0.001)\\n\",\n    \"        return f\\\"PROCESSED_{data}_{resource['id']}\\\"\\n\",\n    \"    \\n\",\n    \"    def get_performance_report(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Get comprehensive performance report.\\\"\\\"\\\"\\n\",\n    \"        report = {\\n\",\n    \"            \\\"processing_stats\\\": self.stats.copy(),\\n\",\n    \"            \\\"cache_stats\\\": self.cache.get_stats() if self.cache else None,\\n\",\n    \"            \\\"resource_pool_stats\\\": self.resource_pool.get_stats(),\\n\",\n    \"            \\\"performance_summary\\\": {}\\n\",\n    \"        }\\n\",\n    \"        \\n\",\n    \"        # Calculate performance metrics\\n\",\n    \"        if self.stats[\\\"total_processed\\\"] > 0:\\n\",\n    \"            avg_time = self.stats[\\\"total_time\\\"] / self.stats[\\\"total_processed\\\"]\\n\",\n    \"            throughput = self.stats[\\\"total_processed\\\"] / self.stats[\\\"total_time\\\"] if self.stats[\\\"total_time\\\"] > 0 else 0\\n\",\n    \"            \\n\",\n    \"            report[\\\"performance_summary\\\"] = {\\n\",\n    \"                \\\"avg_processing_time\\\": avg_time,\\n\",\n    \"                \\\"throughput_items_per_sec\\\": throughput,\\n\",\n    \"                \\\"cache_hit_rate\\\": self.stats[\\\"cache_hits\\\"] / (self.stats[\\\"cache_hits\\\"] + self.stats[\\\"cache_misses\\\"]) if (self.stats[\\\"cache_hits\\\"] + self.stats[\\\"cache_misses\\\"]) > 0 else 0\\n\",\n    \"            }\\n\",\n    \"        \\n\",\n    \"        if self.monitor:\\n\",\n    \"            report[\\\"detailed_monitoring\\\"] = self.monitor.get_summary()\\n\",\n    \"        \\n\",\n    \"        return report\\n\",\n    \"    \\n\",\n    \"    def optimize_configuration(self) -> PerformanceConfig:\\n\",\n    \"        \\\"\\\"\\\"Suggest optimized configuration based on usage patterns.\\\"\\\"\\\"\\n\",\n    \"        current_config = self.config\\n\",\n    \"        \\n\",\n    \"        # Simple optimization heuristics\\n\",\n    \"        if self.cache and self.cache.get_stats()[\\\"hit_ratio\\\"] < 0.3:\\n\",\n    \"            # Low cache hit rate, increase cache size\\n\",\n    \"            current_config.cache_size = min(current_config.cache_size * 2, 5000)\\n\",\n    \"        \\n\",\n    \"        if self.stats[\\\"parallel_batches\\\"] > 10:\\n\",\n    \"            # Frequent parallel processing, optimize batch size\\n\",\n    \"            current_config.batch_size = max(current_config.batch_size // 2, 50)\\n\",\n    \"        \\n\",\n    \"        return current_config\\n\",\n    \"\\n\",\n    \"def demonstrate_production_system():\\n\",\n    \"    \\\"\\\"\\\"Demonstrate the complete production performance system.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    console.print(Panel(\\\"🏭 Production Performance System\\\", style=\\\"bold green\\\"))\\n\",\n    \"    \\n\",\n    \"    # Create optimized configuration\\n\",\n    \"    config = PerformanceConfig(\\n\",\n    \"        enable_caching=True,\\n\",\n    \"        cache_size=500,\\n\",\n    \"        enable_parallel=True,\\n\",\n    \"        max_workers=3,\\n\",\n    \"        batch_size=50,\\n\",\n    \"        enable_vectorization=True,\\n\",\n    \"        memory_limit_mb=200.0,\\n\",\n    \"        enable_profiling=True\\n\",\n    \"    )\\n\",\n    \"    \\n\",\n    \"    processor = HighPerformanceAIProcessor(config)\\n\",\n    \"    \\n\",\n    \"    print(\\\"🚀 Testing high-performance AI processing:\\\")\\n\",\n    \"    \\n\",\n    \"    # Test 1: Single item processing with caching\\n\",\n    \"    print(f\\\"\\\\n📝 Single item processing (with caching):\\\")\\n\",\n    \"    \\n\",\n    \"    test_items = [\\\"test_item_1\\\", \\\"test_item_2\\\", \\\"test_item_1\\\"]  # Duplicate for cache test\\n\",\n    \"    \\n\",\n    \"    for item in test_items:\\n\",\n    \"        result = processor.process_single(item, \\\"classify\\\")\\n\",\n    \"        cache_status = \\\"CACHE HIT\\\" if result.from_cache else \\\"COMPUTED\\\"\\n\",\n    \"        print(f\\\"  {item}: {result.data['label']} (confidence: {result.data['confidence']:.3f}) - {cache_status} - {result.processing_time:.4f}s\\\")\\n\",\n    \"    \\n\",\n    \"    # Test 2: Batch processing\\n\",\n    \"    print(f\\\"\\\\n📦 Batch processing:\\\")\\n\",\n    \"    \\n\",\n    \"    batch_data = [f\\\"batch_item_{i}\\\" for i in range(20)]\\n\",\n    \"    \\n\",\n    \"    with profile_time(\\\"Batch processing\\\"):\\n\",\n    \"        batch_results = processor.process_batch(batch_data, \\\"analyze\\\")\\n\",\n    \"    \\n\",\n    \"    successful_results = [r for r in batch_results if r.data]\\n\",\n    \"    avg_time = sum(r.processing_time for r in successful_results) / len(successful_results)\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Processed {len(successful_results)} items\\\")\\n\",\n    \"    print(f\\\"  Average processing time: {avg_time:.4f}s\\\")\\n\",\n    \"    print(f\\\"  Sample result: {successful_results[0].data}\\\")\\n\",\n    \"    \\n\",\n    \"    # Test 3: Vectorized processing\\n\",\n    \"    print(f\\\"\\\\n⚡ Vectorized processing:\\\")\\n\",\n    \"    \\n\",\n    \"    # Create test matrices\\n\",\n    \"    test_matrix = np.random.rand(100, 10)\\n\",\n    \"    \\n\",\n    \"    operations = [\\\"normalize\\\", \\\"similarity\\\", \\\"transform\\\"]\\n\",\n    \"    \\n\",\n    \"    for operation in operations:\\n\",\n    \"        result = processor.process_vectorized(test_matrix, operation)\\n\",\n    \"        print(f\\\"  {operation}: shape={result.data.shape}, time={result.processing_time:.4f}s\\\")\\n\",\n    \"    \\n\",\n    \"    # Test 4: Mixed workload\\n\",\n    \"    print(f\\\"\\\\n🔀 Mixed workload processing:\\\")\\n\",\n    \"    \\n\",\n    \"    mixed_data = [f\\\"mixed_{i}\\\" for i in range(30)]\\n\",\n    \"    operations = [\\\"classify\\\", \\\"vectorize\\\", \\\"analyze\\\"]\\n\",\n    \"    \\n\",\n    \"    start_time = time.perf_counter()\\n\",\n    \"    \\n\",\n    \"    for i, data in enumerate(mixed_data):\\n\",\n    \"        operation = operations[i % len(operations)]\\n\",\n    \"        result = processor.process_single(data, operation)\\n\",\n    \"    \\n\",\n    \"    mixed_time = time.perf_counter() - start_time\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Mixed workload: {len(mixed_data)} items in {mixed_time:.4f}s\\\")\\n\",\n    \"    \\n\",\n    \"    # Performance report\\n\",\n    \"    report = processor.get_performance_report()\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n📊 Performance Report:\\\")\\n\",\n    \"    print(f\\\"  Total processed: {report['processing_stats']['total_processed']}\\\")\\n\",\n    \"    print(f\\\"  Cache hit rate: {report['performance_summary']['cache_hit_rate']:.1%}\\\")\\n\",\n    \"    print(f\\\"  Average processing time: {report['performance_summary']['avg_processing_time']:.4f}s\\\")\\n\",\n    \"    print(f\\\"  Throughput: {report['performance_summary']['throughput_items_per_sec']:.1f} items/sec\\\")\\n\",\n    \"    \\n\",\n    \"    if report['cache_stats']:\\n\",\n    \"        print(f\\\"  Cache efficiency: {report['cache_stats']['memory_mb']:.1f}MB used\\\")\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Resource pool: {report['resource_pool_stats']['pool_efficiency']:.1%} efficiency\\\")\\n\",\n    \"    \\n\",\n    \"    # Configuration optimization\\n\",\n    \"    print(f\\\"\\\\n🔧 Configuration optimization:\\\")\\n\",\n    \"    optimized_config = processor.optimize_configuration()\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Original batch size: {config.batch_size}\\\")\\n\",\n    \"    print(f\\\"  Optimized batch size: {optimized_config.batch_size}\\\")\\n\",\n    \"    print(f\\\"  Original cache size: {config.cache_size}\\\")\\n\",\n    \"    print(f\\\"  Optimized cache size: {optimized_config.cache_size}\\\")\\n\",\n    \"    \\n\",\n    \"    # Memory cleanup demonstration\\n\",\n    \"    print(f\\\"\\\\n🧹 Memory cleanup:\\\")\\n\",\n    \"    \\n\",\n    \"    objects_before = len(gc.get_objects())\\n\",\n    \"    \\n\",\n    \"    # Clear caches and force garbage collection\\n\",\n    \"    if processor.cache:\\n\",\n    \"        processor.cache.cache.clear()\\n\",\n    \"    \\n\",\n    \"    del batch_results, successful_results, mixed_data\\n\",\n    \"    gc.collect()\\n\",\n    \"    \\n\",\n    \"    objects_after = len(gc.get_objects())\\n\",\n    \"    \\n\",\n    \"    print(f\\\"  Objects before cleanup: {objects_before}\\\")\\n\",\n    \"    print(f\\\"  Objects after cleanup: {objects_after}\\\")\\n\",\n    \"    print(f\\\"  Objects freed: {objects_before - objects_after}\\\")\\n\",\n    \"    \\n\",\n    \"    print(f\\\"\\\\n🏆 Production System Features:\\\")\\n\",\n    \"    print(f\\\"  ✅ Intelligent caching with memory limits\\\")\\n\",\n    \"    print(f\\\"  ✅ Parallel batch processing\\\")\\n\",\n    \"    print(f\\\"  ✅ Vectorized mathematical operations\\\")\\n\",\n    \"    print(f\\\"  ✅ Resource pooling and management\\\")\\n\",\n    \"    print(f\\\"  ✅ Comprehensive performance monitoring\\\")\\n\",\n    \"    print(f\\\"  ✅ Automatic configuration optimization\\\")\\n\",\n    \"    print(f\\\"  ✅ Memory-efficient data structures\\\")\\n\",\n    \"\\n\",\n    \"# Run the complete production system demonstration\\n\",\n    \"demonstrate_production_system()\\n\",\n    \"\\n\",\n    \"print(f\\\"\\\\n🎯 Performance Optimization Mastery Complete!\\\")\\n\",\n    \"print(f\\\"\\\\n💡 Key Performance Optimization Benefits:\\\")\\n\",\n    \"print(f\\\"  ⚡ 10-100x speedup with proper optimization\\\")\\n\",\n    \"print(f\\\"  💾 Efficient memory usage and management\\\")\\n\",\n    \"print(f\\\"  📊 Data-driven performance monitoring\\\")\\n\",\n    \"print(f\\\"  🔧 Adaptive configuration optimization\\\")\\n\",\n    \"print(f\\\"  🚀 Production-ready scalable architecture\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Summary: Performance Optimization Mastery\\n\",\n    \"\\n\",\n    \"**🎯 Key Takeaways:**\\n\",\n    \"\\n\",\n    \"1. **Memory Efficiency** reduces allocation overhead and improves cache locality\\n\",\n    \"2. **Performance Profiling** identifies bottlenecks and guides optimization efforts\\n\",\n    \"3. **Vectorization** provides massive speedups for numerical operations\\n\",\n    \"4. **Parallel Processing** utilizes multiple cores for CPU-bound and I/O-bound tasks\\n\",\n    \"5. **Smart Caching** eliminates redundant computations\\n\",\n    \"6. **Resource Pooling** reuses expensive objects efficiently\\n\",\n    \"7. **Monitoring** provides insights for continuous optimization\\n\",\n    \"\\n\",\n    \"**🚀 Production Considerations:**\\n\",\n    \"- Always profile before optimizing\\n\",\n    \"- Use appropriate data structures for your use case\\n\",\n    \"- Leverage NumPy for numerical computations\\n\",\n    \"- Choose threads vs processes based on workload type\\n\",\n    \"- Monitor memory usage and implement limits\\n\",\n    \"- Cache strategically with appropriate TTL\\n\",\n    \"\\n\",\n    \"**💡 Remember:** Performance optimization is about making the right trade-offs between speed, memory, and code complexity. Focus on the bottlenecks that matter most for your specific AI application!\"\n   ]\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"Python 3\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.11.0\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 4\n}","structuredPatch":[]}}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","type":"user","message":{"role":"user","content":"This session is being continued from a previous conversation that ran out of context. The conversation is summarized below:\nAnalysis:\nLet me chronologically analyze this conversation to capture all the user's requests, my actions, and technical details:\n\n1. **Initial Request**: The user asked me to read a specific Python file (`03-python-idioms/examples/01_type_system_advanced.py`) and create a Jupyter notebook for learning, with explanations of first principles and Python idioms to make them \"well-rounded\".\n\n2. **My Response**: I read the file (which contained advanced Python typing examples for AI systems) and created a comprehensive Jupyter notebook (`01_type_system_advanced_learning.ipynb`) with 10 progressive cells covering:\n   - Type variables and generics\n   - Dataclasses \n   - Protocols\n   - TypedDict\n   - Function overloading\n   - Advanced decorators\n   - Real-world integration\n\n3. **User's Follow-up Request**: The user asked me to:\n   - Move the notebook to a notebooks directory\n   - Create similar notebooks for files 2, 3, 4, 5 \n   - Start with files in order: 3, 2, 5, 4\n\n4. **My Implementation**: I:\n   - Created the notebooks directory\n   - Moved the existing notebook there\n   - Read the other Python files (02_async_patterns.py, 05_performance_optimization.py, 03_functional_programming.py, 04_metaprogramming.py)\n   - Created comprehensive learning notebooks for files 3, 2, and 5 in the requested order\n   - Each notebook followed the same educational structure with first principles, Python idioms, and progressive learning cells\n\n5. **Technical Patterns**: Each notebook contained:\n   - 10+ progressive cells building complexity\n   - First principle explanations\n   - Python idiom demonstrations\n   - Production-ready examples\n   - Interactive learning with rich console output\n\n6. **File Status**: I successfully created:\n   - `/notebooks/01_type_system_advanced_learning.ipynb` (moved)\n   - `/notebooks/03_functional_programming_learning.ipynb` (created)\n   - `/notebooks/02_async_patterns_learning.ipynb` (created) \n   - `/notebooks/05_performance_optimization_learning.ipynb` (created)\n\n7. **Remaining Work**: I still need to create the notebook for file 4 (metaprogramming) to complete the user's request.\n\nThe conversation shows a clear educational focus on Python patterns for AI systems, with comprehensive notebook creation following a consistent pedagogical structure.\n\nSummary:\n1. Primary Request and Intent:\n   The user requested me to read a specific Python file (`@03-python-idioms/examples/01_type_system_advanced.py`) and create a Jupyter notebook for learning from these examples, with explanations of first principles and Python idioms to help them become \"well-rounded.\" After the initial notebook, they requested me to move it to a notebooks directory and create similar learning notebooks for other Python files (2, 3, 4, 5) in a specific order: 3, 2, 5, 4.\n\n2. Key Technical Concepts:\n   - Advanced Python Type System (Type variables, Generics, Protocols, TypedDict)\n   - Functional Programming (Immutability, Pure functions, Composition, Monadic error handling)\n   - Async Patterns (Streaming, Rate limiting, Connection pooling, Concurrent processing)\n   - Performance Optimization (Memory efficiency, Vectorization, Parallel processing, Profiling)\n   - Dataclasses and frozen dataclasses\n   - Context managers and async context managers\n   - Decorators and function overloading\n   - Rich console library for formatted output\n   - AI system architecture patterns\n\n3. Files and Code Sections:\n   - `/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/examples/01_type_system_advanced.py`\n     - Source file containing advanced typing examples for AI systems\n     - Contains examples of TypeVar, Generic, Protocol, TypedDict, overload decorators\n     - Key snippet: ModelRegistryMeta metaclass for automatic model registration\n   \n   - `/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/notebooks/01_type_system_advanced_learning.ipynb`\n     - Comprehensive learning notebook with 10 progressive cells\n     - Covers type variables, dataclasses, protocols, and real-world integration\n     - Key snippet: Complete functional AI pipeline combining all patterns\n   \n   - `/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/examples/03_functional_programming.py`\n     - Source file with functional programming patterns for AI\n     - Contains immutable data structures, pure functions, monadic error handling\n     - Key snippet: Result monad for safe computation chains\n   \n   - `/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/notebooks/03_functional_programming_learning.ipynb`\n     - Educational notebook covering functional programming concepts\n     - 11 cells progressing from basics to production system\n     - Key snippet: Complete functional AI text processing system with immutable config\n   \n   - `/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/examples/02_async_patterns.py`\n     - Source file with async patterns for high-performance AI systems\n     - Contains streaming, rate limiting, connection pooling examples\n     - Key snippet: ConcurrentInferenceEngine for managing parallel AI requests\n   \n   - `/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/notebooks/02_async_patterns_learning.ipynb`\n     - Comprehensive async programming tutorial\n     - 6 cells covering streaming, rate limiting, resource management\n     - Key snippet: Production-ready AsyncAISystem with full async patterns\n   \n   - `/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/examples/05_performance_optimization.py`\n     - Source file with performance optimization techniques\n     - Contains memory-efficient structures, vectorization, parallel processing\n     - Key snippet: MemoryEfficientCache with size and memory limits\n   \n   - `/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/notebooks/05_performance_optimization_learning.ipynb`\n     - Performance optimization tutorial\n     - 6 cells covering profiling, vectorization, parallel processing\n     - Key snippet: HighPerformanceAIProcessor combining all optimization techniques\n\n4. Errors and fixes:\n   - File not found error when trying to read `03_context_managers.py` and `04_error_handling.py` - these files don't exist\n   - Fixed by checking directory contents and finding the correct files: `03_functional_programming.py` and `04_metaprogramming.py`\n   - No user feedback on errors received\n\n5. Problem Solving:\n   - Successfully created a consistent educational structure across all notebooks\n   - Solved the challenge of making complex Python concepts accessible through progressive learning cells\n   - Implemented rich console output for interactive learning experience\n   - Created production-ready examples that combine multiple concepts\n\n6. All user messages:\n   - \"@03-python-idioms/examples/01_type_system_advanced.py can you create a juptyer notebook for me to learn form these examples. explain each cell what are the first priciples, python idioms also so i come out well rounded Called the Read tool with the following input...\"\n   - \"ok great, can you move notebooks directory this one and create similiar for other 2,3,4,5 also start with 3, 2,5,4 python files\"\n\n7. Pending Tasks:\n   - Create learning notebook for file 4 (04_metaprogramming.py) to complete the user's request\n\n8. Current Work:\n   I just completed creating the performance optimization learning notebook (`05_performance_optimization_learning.ipynb`). This was the third notebook in the requested sequence (3, 2, 5, 4). The notebook contains 6 comprehensive cells covering memory-efficient data structures, performance profiling, vectorized operations, parallel processing patterns, and a complete production-ready high-performance AI processing system. The final cell demonstrates a `HighPerformanceAIProcessor` class that combines all optimization techniques including intelligent caching, parallel batch processing, vectorized operations, and comprehensive performance monitoring.\n\n9. Optional Next Step:\n   Create the learning notebook for file 4 (04_metaprogramming.py) to complete the user's request sequence. Based on the user's explicit request: \"create similiar for other 2,3,4,5 also start with 3, 2,5,4 python files\" - I have completed notebooks for 3, 2, and 5, so the final step is to create the notebook for file 4 (metaprogramming)..\nPlease continue the conversation from where we left it off without asking the user any further questions. Continue with the last task that you were asked to work on."},"isCompactSummary":true,"uuid":"aa5c88df-042a-49e4-b866-bc17a9c25e36","timestamp":"2025-08-01T18:18:40.329Z"}
{"parentUuid":"aa5c88df-042a-49e4-b866-bc17a9c25e36","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_0199yfXy6oTnpwC2qDYXCE2g","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Now I'll create the final learning notebook for metaprogramming patterns. This will complete the requested sequence of notebooks (3, 2, 5, 4)."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":30505,"cache_read_input_tokens":15686,"output_tokens":1}},"requestId":"req_vrtx_011CRhT5NxvheVJdmpDzBavw","type":"assistant","uuid":"5dc6b5f4-98be-4ec9-a1bb-a455a70bc66c","timestamp":"2025-08-01T18:18:46.749Z"}
{"parentUuid":"5dc6b5f4-98be-4ec9-a1bb-a455a70bc66c","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_0199yfXy6oTnpwC2qDYXCE2g","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"tool_use","id":"toolu_vrtx_01LaPQXY1PdDL7iy3yoAp7gk","name":"Write","input":{"file_path":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/notebooks/04_metaprogramming_learning.ipynb","content":"{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"# 🏭 Metaprogramming for AI Systems - Learning Notebook\\n\",\n    \"\\n\",\n    \"**First Principles**: Metaprogramming is code that manipulates code. It allows us to create flexible, self-adapting systems that can modify their behavior at runtime.\\n\",\n    \"\\n\",\n    \"**Python Idioms**: Descriptors, metaclasses, decorators, dynamic class generation, and introspection enable powerful metaprogramming patterns.\\n\",\n    \"\\n\",\n    \"**AI Applications**: Dynamic model registration, automatic instrumentation, configuration management, and adaptive behavior.\\n\",\n    \"\\n\",\n    \"---\\n\",\n    \"\\n\",\n    \"## Learning Path\\n\",\n    \"1. **Descriptors** - Custom attribute access patterns\\n\",\n    \"2. **Metaclasses** - Class creation and automatic registration\\n\",\n    \"3. **Dynamic Classes** - Runtime class generation\\n\",\n    \"4. **Advanced Decorators** - Behavior modification patterns\\n\",\n    \"5. **Property Factories** - Type-safe dynamic properties\\n\",\n    \"6. **Context Managers** - Dynamic configuration management\\n\",\n    \"7. **Reflection** - Runtime introspection capabilities\\n\",\n    \"8. **Complete AI Framework** - Production-ready metaprogramming system\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Cell 1: Descriptors - Custom Attribute Access\\n\",\n    \"from typing import Any, Type, Callable, Dict, Optional\\n\",\n    \"from functools import update_wrapper\\n\",\n    \"import time\\n\",\n    \"from rich.console import Console\\n\",\n    \"\\n\",\n    \"console = Console()\\n\",\n    \"\\n\",\n    \"class ValidatedProperty:\\n\",\n    \"    \\\"\\\"\\\"Descriptor that validates property values.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, validator: Callable[[Any], bool], error_msg: str):\\n\",\n    \"        self.validator = validator\\n\",\n    \"        self.error_msg = error_msg\\n\",\n    \"        self.name = None\\n\",\n    \"    \\n\",\n    \"    def __set_name__(self, owner: Type, name: str):\\n\",\n    \"        \\\"\\\"\\\"Called when descriptor is assigned to a class attribute.\\\"\\\"\\\"\\n\",\n    \"        self.name = name\\n\",\n    \"        self.private_name = f'_{name}'\\n\",\n    \"    \\n\",\n    \"    def __get__(self, obj: Any, objtype: Type = None) -> Any:\\n\",\n    \"        if obj is None:\\n\",\n    \"            return self\\n\",\n    \"        return getattr(obj, self.private_name, None)\\n\",\n    \"    \\n\",\n    \"    def __set__(self, obj: Any, value: Any) -> None:\\n\",\n    \"        if not self.validator(value):\\n\",\n    \"            raise ValueError(f\\\"{self.error_msg}: {value}\\\")\\n\",\n    \"        setattr(obj, self.private_name, value)\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"class CachedProperty:\\n\",\n    \"    \\\"\\\"\\\"Descriptor that caches expensive computations.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, func: Callable):\\n\",\n    \"        self.func = func\\n\",\n    \"        self.name = func.__name__\\n\",\n    \"        update_wrapper(self, func)\\n\",\n    \"    \\n\",\n    \"    def __get__(self, obj: Any, objtype: Type = None) -> Any:\\n\",\n    \"        if obj is None:\\n\",\n    \"            return self\\n\",\n    \"        \\n\",\n    \"        cache_name = f'_cached_{self.name}'\\n\",\n    \"        if hasattr(obj, cache_name):\\n\",\n    \"            console.print(f\\\"[dim green]💾 Cache hit for {self.name}[/dim green]\\\")\\n\",\n    \"            return getattr(obj, cache_name)\\n\",\n    \"        \\n\",\n    \"        console.print(f\\\"[dim yellow]🔄 Computing {self.name}[/dim yellow]\\\")\\n\",\n    \"        value = self.func(obj)\\n\",\n    \"        setattr(obj, cache_name, value)\\n\",\n    \"        return value\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"# Example: AI Model with Validated Properties\\n\",\n    \"class AIModel:\\n\",\n    \"    \\\"\\\"\\\"AI model with validated properties using descriptors.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    temperature = ValidatedProperty(\\n\",\n    \"        lambda x: 0.0 <= x <= 2.0,\\n\",\n    \"        \\\"Temperature must be between 0.0 and 2.0\\\"\\n\",\n    \"    )\\n\",\n    \"    \\n\",\n    \"    max_tokens = ValidatedProperty(\\n\",\n    \"        lambda x: isinstance(x, int) and x > 0,\\n\",\n    \"        \\\"Max tokens must be a positive integer\\\"\\n\",\n    \"    )\\n\",\n    \"    \\n\",\n    \"    def __init__(self, temperature: float = 0.7, max_tokens: int = 1000):\\n\",\n    \"        self.temperature = temperature\\n\",\n    \"        self.max_tokens = max_tokens\\n\",\n    \"    \\n\",\n    \"    @CachedProperty\\n\",\n    \"    def model_signature(self) -> str:\\n\",\n    \"        \\\"\\\"\\\"Expensive computation that gets cached.\\\"\\\"\\\"\\n\",\n    \"        time.sleep(0.1)  # Simulate expensive computation\\n\",\n    \"        return f\\\"Model_{hash(str(self.temperature) + str(self.max_tokens))}\\\"\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"console.print(\\\"[bold blue]🔍 Testing Descriptors[/bold blue]\\\")\\n\",\n    \"\\n\",\n    \"# Test validation\\n\",\n    \"model = AIModel()\\n\",\n    \"console.print(f\\\"Default temperature: {model.temperature}\\\")\\n\",\n    \"\\n\",\n    \"model.temperature = 1.5\\n\",\n    \"console.print(f\\\"✅ Set temperature to {model.temperature}\\\")\\n\",\n    \"\\n\",\n    \"try:\\n\",\n    \"    model.temperature = 3.0  # Should fail\\nexcept ValueError as e:\\n\",\n    \"    console.print(f\\\"❌ Validation caught: {e}\\\")\\n\",\n    \"\\n\",\n    \"# Test cached property\\n\",\n    \"sig1 = model.model_signature  # Should compute\\n\",\n    \"sig2 = model.model_signature  # Should use cache\\n\",\n    \"console.print(f\\\"Signatures match: {sig1 == sig2}\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold green]First Principle:[/bold green] Descriptors control attribute access\\\")\\n\",\n    \"console.print(\\\"[bold yellow]Python Idiom:[/bold yellow] __get__, __set__, __set_name__ methods\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Cell 2: Metaclasses - Automatic Registration and Instrumentation\\n\",\n    \"\\n\",\n    \"class ModelRegistryMeta(type):\\n\",\n    \"    \\\"\\\"\\\"Metaclass that automatically registers AI models.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    _registry: Dict[str, Type] = {}\\n\",\n    \"    \\n\",\n    \"    def __new__(mcs, name: str, bases: tuple, namespace: dict, **kwargs):\\n\",\n    \"        # Add automatic ID generation\\n\",\n    \"        if 'model_id' not in namespace and name != 'BaseModel':\\n\",\n    \"            namespace['model_id'] = name.lower().replace('model', '')\\n\",\n    \"        \\n\",\n    \"        cls = super().__new__(mcs, name, bases, namespace)\\n\",\n    \"        \\n\",\n    \"        # Register the model\\n\",\n    \"        if name != 'BaseModel' and hasattr(cls, 'model_id'):\\n\",\n    \"            mcs._registry[cls.model_id] = cls\\n\",\n    \"            console.print(f\\\"[dim]🔧 Registered model: {cls.model_id} -> {name}[/dim]\\\")\\n\",\n    \"        \\n\",\n    \"        return cls\\n\",\n    \"    \\n\",\n    \"    @classmethod\\n\",\n    \"    def get_model(mcs, model_id: str) -> Optional[Type]:\\n\",\n    \"        return mcs._registry.get(model_id)\\n\",\n    \"    \\n\",\n    \"    @classmethod\\n\",\n    \"    def list_models(mcs) -> list:\\n\",\n    \"        return list(mcs._registry.keys())\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"class InstrumentedMeta(type):\\n\",\n    \"    \\\"\\\"\\\"Metaclass that adds automatic instrumentation.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __new__(mcs, name: str, bases: tuple, namespace: dict, **kwargs):\\n\",\n    \"        # Instrument methods that start with 'predict'\\n\",\n    \"        for attr_name, attr_value in namespace.items():\\n\",\n    \"            if (attr_name.startswith('predict') and \\n\",\n    \"                callable(attr_value) and \\n\",\n    \"                not attr_name.startswith('_')):\\n\",\n    \"                \\n\",\n    \"                namespace[attr_name] = mcs._instrument_method(attr_value, attr_name)\\n\",\n    \"        \\n\",\n    \"        return super().__new__(mcs, name, bases, namespace)\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def _instrument_method(method: Callable, method_name: str) -> Callable:\\n\",\n    \"        from functools import wraps\\n\",\n    \"        \\n\",\n    \"        @wraps(method)\\n\",\n    \"        def wrapper(self, *args, **kwargs):\\n\",\n    \"            start_time = time.time()\\n\",\n    \"            try:\\n\",\n    \"                result = method(self, *args, **kwargs)\\n\",\n    \"                duration = time.time() - start_time\\n\",\n    \"                \\n\",\n    \"                # Store metrics\\n\",\n    \"                if not hasattr(self, '_metrics'):\\n\",\n    \"                    self._metrics = {}\\n\",\n    \"                if method_name not in self._metrics:\\n\",\n    \"                    self._metrics[method_name] = []\\n\",\n    \"                \\n\",\n    \"                self._metrics[method_name].append({\\n\",\n    \"                    'duration': duration,\\n\",\n    \"                    'timestamp': start_time,\\n\",\n    \"                    'success': True\\n\",\n    \"                })\\n\",\n    \"                \\n\",\n    \"                console.print(f\\\"[dim]📊 {self.__class__.__name__}.{method_name} took {duration:.4f}s[/dim]\\\")\\n\",\n    \"                return result\\n\",\n    \"                \\n\",\n    \"            except Exception as e:\\n\",\n    \"                duration = time.time() - start_time\\n\",\n    \"                console.print(f\\\"[dim red]❌ {self.__class__.__name__}.{method_name} failed after {duration:.4f}s[/dim red]\\\")\\n\",\n    \"                raise\\n\",\n    \"        \\n\",\n    \"        return wrapper\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"# Base model with both metaclasses\\n\",\n    \"class BaseModel(metaclass=ModelRegistryMeta):\\n\",\n    \"    \\\"\\\"\\\"Base class for AI models.\\\"\\\"\\\"\\n\",\n    \"    pass\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"class GPTModel(BaseModel, metaclass=InstrumentedMeta):\\n\",\n    \"    \\\"\\\"\\\"GPT model with automatic instrumentation.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def predict_text(self, text: str) -> str:\\n\",\n    \"        time.sleep(0.05)  # Simulate prediction\\n\",\n    \"        return f\\\"GPT prediction for: {text}\\\"\\n\",\n    \"    \\n\",\n    \"    def predict_classification(self, text: str) -> Dict[str, float]:\\n\",\n    \"        time.sleep(0.03)\\n\",\n    \"        return {\\\"positive\\\": 0.8, \\\"negative\\\": 0.1, \\\"neutral\\\": 0.1}\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"class ClaudeModel(BaseModel, metaclass=InstrumentedMeta):\\n\",\n    \"    \\\"\\\"\\\"Claude model with automatic instrumentation.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def predict_text(self, text: str) -> str:\\n\",\n    \"        time.sleep(0.04)\\n\",\n    \"        return f\\\"Claude prediction for: {text}\\\"\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"console.print(\\\"[bold blue]🏭 Testing Metaclasses[/bold blue]\\\")\\n\",\n    \"\\n\",\n    \"# Show automatic registration\\n\",\n    \"registered_models = ModelRegistryMeta.list_models()\\n\",\n    \"console.print(f\\\"Registered models: {registered_models}\\\")\\n\",\n    \"\\n\",\n    \"# Create models from registry\\n\",\n    \"gpt_class = ModelRegistryMeta.get_model('gpt')\\n\",\n    \"claude_class = ModelRegistryMeta.get_model('claude')\\n\",\n    \"\\n\",\n    \"if gpt_class:\\n\",\n    \"    gpt = gpt_class()\\n\",\n    \"    result = gpt.predict_text(\\\"Hello world\\\")\\n\",\n    \"    console.print(f\\\"GPT: {result}\\\")\\n\",\n    \"\\n\",\n    \"if claude_class:\\n\",\n    \"    claude = claude_class()\\n\",\n    \"    result = claude.predict_text(\\\"Hello world\\\")\\n\",\n    \"    console.print(f\\\"Claude: {result}\\\")\\n\",\n    \"\\n\",\n    \"# Show automatic instrumentation\\n\",\n    \"if hasattr(gpt, '_metrics'):\\n\",\n    \"    for method, metrics in gpt._metrics.items():\\n\",\n    \"        avg_duration = sum(m['duration'] for m in metrics) / len(metrics)\\n\",\n    \"        console.print(f\\\"Metrics - {method}: {len(metrics)} calls, avg {avg_duration:.4f}s\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold green]First Principle:[/bold green] Metaclasses control class creation\\\")\\n\",\n    \"console.print(\\\"[bold yellow]Python Idiom:[/bold yellow] __new__ method in metaclass\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Cell 3: Dynamic Class Generation\\n\",\n    \"\\n\",\n    \"def create_model_class(\\n\",\n    \"    name: str, \\n\",\n    \"    attributes: Dict[str, Any], \\n\",\n    \"    methods: Dict[str, Callable] = None,\\n\",\n    \"    base_classes: tuple = ()\\n\",\n    \") -> Type:\\n\",\n    \"    \\\"\\\"\\\"Dynamically create a model class.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    if not base_classes:\\n\",\n    \"        base_classes = (object,)\\n\",\n    \"    \\n\",\n    \"    namespace = attributes.copy()\\n\",\n    \"    if methods:\\n\",\n    \"        namespace.update(methods)\\n\",\n    \"    \\n\",\n    \"    # Add default __init__ if not provided\\n\",\n    \"    if '__init__' not in namespace:\\n\",\n    \"        def __init__(self, **kwargs):\\n\",\n    \"            for key, value in kwargs.items():\\n\",\n    \"                setattr(self, key, value)\\n\",\n    \"        namespace['__init__'] = __init__\\n\",\n    \"    \\n\",\n    \"    return type(name, base_classes, namespace)\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"class ModelFactory:\\n\",\n    \"    \\\"\\\"\\\"Factory for creating model classes dynamically.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def create_simple_model(name: str, prediction_delay: float = 0.1) -> Type:\\n\",\n    \"        \\\"\\\"\\\"Create a simple model class.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        def predict(self, text: str) -> str:\\n\",\n    \"            time.sleep(prediction_delay)\\n\",\n    \"            return f\\\"{name} processed: {text}\\\"\\n\",\n    \"        \\n\",\n    \"        def get_info(self) -> Dict[str, Any]:\\n\",\n    \"            return {\\n\",\n    \"                \\\"model_name\\\": name,\\n\",\n    \"                \\\"prediction_delay\\\": prediction_delay,\\n\",\n    \"                \\\"class_name\\\": self.__class__.__name__\\n\",\n    \"            }\\n\",\n    \"        \\n\",\n    \"        return create_model_class(\\n\",\n    \"            name=f\\\"{name}Model\\\",\\n\",\n    \"            attributes={\\n\",\n    \"                \\\"model_name\\\": name,\\n\",\n    \"                \\\"prediction_delay\\\": prediction_delay\\n\",\n    \"            },\\n\",\n    \"            methods={\\n\",\n    \"                \\\"predict\\\": predict,\\n\",\n    \"                \\\"get_info\\\": get_info\\n\",\n    \"            },\\n\",\n    \"            base_classes=(BaseModel,)\\n\",\n    \"        )\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def create_ensemble_model(models: list) -> Type:\\n\",\n    \"        \\\"\\\"\\\"Create an ensemble model from multiple model classes.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        def predict(self, text: str) -> list:\\n\",\n    \"            results = []\\n\",\n    \"            for model_class in models:\\n\",\n    \"                model = model_class()\\n\",\n    \"                if hasattr(model, 'predict'):\\n\",\n    \"                    results.append(model.predict(text))\\n\",\n    \"                elif hasattr(model, 'predict_text'):\\n\",\n    \"                    results.append(model.predict_text(text))\\n\",\n    \"            return results\\n\",\n    \"        \\n\",\n    \"        def get_model_info(self) -> list:\\n\",\n    \"            return [model.__name__ for model in models]\\n\",\n    \"        \\n\",\n    \"        return create_model_class(\\n\",\n    \"            name=\\\"EnsembleModel\\\",\\n\",\n    \"            attributes={\\\"component_models\\\": models},\\n\",\n    \"            methods={\\n\",\n    \"                \\\"predict\\\": predict,\\n\",\n    \"                \\\"get_model_info\\\": get_model_info\\n\",\n    \"            }\\n\",\n    \"        )\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"console.print(\\\"[bold blue]⚡ Testing Dynamic Class Creation[/bold blue]\\\")\\n\",\n    \"\\n\",\n    \"# Create models using factory\\n\",\n    \"FastModel = ModelFactory.create_simple_model(\\\"FastAI\\\", prediction_delay=0.02)\\n\",\n    \"SlowModel = ModelFactory.create_simple_model(\\\"DeepThink\\\", prediction_delay=0.08)\\n\",\n    \"\\n\",\n    \"fast_model = FastModel()\\n\",\n    \"slow_model = SlowModel()\\n\",\n    \"\\n\",\n    \"console.print(f\\\"Fast model: {fast_model.get_info()}\\\")\\n\",\n    \"console.print(f\\\"Slow model: {slow_model.get_info()}\\\")\\n\",\n    \"\\n\",\n    \"# Test predictions\\n\",\n    \"start_time = time.time()\\n\",\n    \"fast_result = fast_model.predict(\\\"test input\\\")\\n\",\n    \"fast_time = time.time() - start_time\\n\",\n    \"\\n\",\n    \"start_time = time.time()\\n\",\n    \"slow_result = slow_model.predict(\\\"test input\\\")\\n\",\n    \"slow_time = time.time() - start_time\\n\",\n    \"\\n\",\n    \"console.print(f\\\"Performance - Fast: {fast_time:.4f}s, Slow: {slow_time:.4f}s\\\")\\n\",\n    \"\\n\",\n    \"# Create ensemble model\\n\",\n    \"EnsembleModel = ModelFactory.create_ensemble_model([FastModel, SlowModel])\\n\",\n    \"ensemble = EnsembleModel()\\n\",\n    \"\\n\",\n    \"ensemble_results = ensemble.predict(\\\"ensemble test\\\")\\n\",\n    \"console.print(f\\\"Ensemble results: {ensemble_results}\\\")\\n\",\n    \"console.print(f\\\"Component models: {ensemble.get_model_info()}\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold green]First Principle:[/bold green] Classes are objects that can be created at runtime\\\")\\n\",\n    \"console.print(\\\"[bold yellow]Python Idiom:[/bold yellow] type() function for dynamic class creation\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Cell 4: Advanced Decorators with State\\n\",\n    \"from functools import wraps\\n\",\n    \"\\n\",\n    \"class memoize_with_ttl:\\n\",\n    \"    \\\"\\\"\\\"Decorator that memoizes with time-to-live.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, ttl_seconds: float = 60.0):\\n\",\n    \"        self.ttl_seconds = ttl_seconds\\n\",\n    \"        self.cache = {}\\n\",\n    \"    \\n\",\n    \"    def __call__(self, func: Callable) -> Callable:\\n\",\n    \"        @wraps(func)\\n\",\n    \"        def wrapper(*args, **kwargs):\\n\",\n    \"            # Create cache key\\n\",\n    \"            key = str(args) + str(sorted(kwargs.items()))\\n\",\n    \"            current_time = time.time()\\n\",\n    \"            \\n\",\n    \"            # Check if cached and not expired\\n\",\n    \"            if key in self.cache:\\n\",\n    \"                result, timestamp = self.cache[key]\\n\",\n    \"                if current_time - timestamp < self.ttl_seconds:\\n\",\n    \"                    console.print(f\\\"[dim green]💾 Cache hit for {func.__name__}[/dim green]\\\")\\n\",\n    \"                    return result\\n\",\n    \"            \\n\",\n    \"            # Compute new result\\n\",\n    \"            result = func(*args, **kwargs)\\n\",\n    \"            self.cache[key] = (result, current_time)\\n\",\n    \"            console.print(f\\\"[dim yellow]🔄 Cache miss for {func.__name__}[/dim yellow]\\\")\\n\",\n    \"            return result\\n\",\n    \"        \\n\",\n    \"        # Add cache management methods\\n\",\n    \"        wrapper.clear_cache = lambda: self.cache.clear()\\n\",\n    \"        wrapper.cache_info = lambda: {\\n\",\n    \"            'size': len(self.cache),\\n\",\n    \"            'ttl_seconds': self.ttl_seconds\\n\",\n    \"        }\\n\",\n    \"        \\n\",\n    \"        return wrapper\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"class retry_with_backoff:\\n\",\n    \"    \\\"\\\"\\\"Decorator that retries with exponential backoff.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, max_retries: int = 3, base_delay: float = 1.0):\\n\",\n    \"        self.max_retries = max_retries\\n\",\n    \"        self.base_delay = base_delay\\n\",\n    \"    \\n\",\n    \"    def __call__(self, func: Callable) -> Callable:\\n\",\n    \"        @wraps(func)\\n\",\n    \"        def wrapper(*args, **kwargs):\\n\",\n    \"            last_exception = None\\n\",\n    \"            \\n\",\n    \"            for attempt in range(self.max_retries + 1):\\n\",\n    \"                try:\\n\",\n    \"                    return func(*args, **kwargs)\\n\",\n    \"                except Exception as e:\\n\",\n    \"                    last_exception = e\\n\",\n    \"                    \\n\",\n    \"                    if attempt < self.max_retries:\\n\",\n    \"                        delay = self.base_delay * (2 ** attempt)\\n\",\n    \"                        console.print(f\\\"[yellow]🔄 Retry {attempt + 1}/{self.max_retries} in {delay:.1f}s[/yellow]\\\")\\n\",\n    \"                        time.sleep(delay)\\n\",\n    \"                    else:\\n\",\n    \"                        console.print(f\\\"[red]❌ All retries exhausted for {func.__name__}[/red]\\\")\\n\",\n    \"            \\n\",\n    \"            raise last_exception\\n\",\n    \"        \\n\",\n    \"        return wrapper\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"console.print(\\\"[bold blue]🎨 Testing Advanced Decorators[/bold blue]\\\")\\n\",\n    \"\\n\",\n    \"@memoize_with_ttl(ttl_seconds=2.0)\\n\",\n    \"@retry_with_backoff(max_retries=2, base_delay=0.5)\\n\",\n    \"def expensive_ai_call(query: str, fail_rate: float = 0.0) -> str:\\n\",\n    \"    \\\"\\\"\\\"Simulate expensive AI call that might fail.\\\"\\\"\\\"\\n\",\n    \"    import random\\n\",\n    \"    \\n\",\n    \"    if random.random() < fail_rate:\\n\",\n    \"        raise ConnectionError(\\\"Simulated API failure\\\")\\n\",\n    \"    \\n\",\n    \"    time.sleep(0.1)  # Simulate processing time\\n\",\n    \"    return f\\\"AI response to: {query}\\\"\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"# Test decorated function\\n\",\n    \"result1 = expensive_ai_call(\\\"What is AI?\\\")\\n\",\n    \"console.print(f\\\"Result 1: {result1}\\\")\\n\",\n    \"\\n\",\n    \"result2 = expensive_ai_call(\\\"What is AI?\\\")  # Should use cache\\n\",\n    \"console.print(f\\\"Result 2: {result2}\\\")\\n\",\n    \"\\n\",\n    \"# Test with failures\\n\",\n    \"try:\\n\",\n    \"    result3 = expensive_ai_call(\\\"Risky query\\\", fail_rate=0.7)\\n\",\n    \"    console.print(f\\\"Success: {result3}\\\")\\n\",\n    \"except Exception as e:\\n\",\n    \"    console.print(f\\\"Failed: {e}\\\")\\n\",\n    \"\\n\",\n    \"cache_info = expensive_ai_call.cache_info()\\n\",\n    \"console.print(f\\\"Cache info: {cache_info}\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold green]First Principle:[/bold green] Decorators modify function behavior\\\")\\n\",\n    \"console.print(\\\"[bold yellow]Python Idiom:[/bold yellow] __call__ method for stateful decorators\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Cell 5: Property Factory - Type-Safe Dynamic Properties\\n\",\n    \"\\n\",\n    \"def typed_property(property_type: Type, default: Any = None, validator: Callable = None):\\n\",\n    \"    \\\"\\\"\\\"Factory for creating typed properties with optional validation.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def property_decorator(func: Callable) -> property:\\n\",\n    \"        name = func.__name__\\n\",\n    \"        private_name = f'_{name}'\\n\",\n    \"        \\n\",\n    \"        def getter(self):\\n\",\n    \"            return getattr(self, private_name, default)\\n\",\n    \"        \\n\",\n    \"        def setter(self, value):\\n\",\n    \"            # Type checking\\n\",\n    \"            if not isinstance(value, property_type):\\n\",\n    \"                try:\\n\",\n    \"                    value = property_type(value)\\n\",\n    \"                except (ValueError, TypeError):\\n\",\n    \"                    raise TypeError(f\\\"{name} must be of type {property_type.__name__}\\\")\\n\",\n    \"            \\n\",\n    \"            # Optional validation\\n\",\n    \"            if validator and not validator(value):\\n\",\n    \"                raise ValueError(f\\\"Invalid value for {name}: {value}\\\")\\n\",\n    \"            \\n\",\n    \"            setattr(self, private_name, value)\\n\",\n    \"        \\n\",\n    \"        return property(getter, setter, doc=func.__doc__)\\n\",\n    \"    \\n\",\n    \"    return property_decorator\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"class ConfigurableModel:\\n\",\n    \"    \\\"\\\"\\\"Model with typed properties using property factory.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    @typed_property(float, default=0.7, validator=lambda x: 0.0 <= x <= 2.0)\\n\",\n    \"    def temperature(self):\\n\",\n    \"        \\\"\\\"\\\"Model temperature parameter.\\\"\\\"\\\"\\n\",\n    \"        pass\\n\",\n    \"    \\n\",\n    \"    @typed_property(int, default=1000, validator=lambda x: x > 0)\\n\",\n    \"    def max_tokens(self):\\n\",\n    \"        \\\"\\\"\\\"Maximum tokens to generate.\\\"\\\"\\\"\\n\",\n    \"        pass\\n\",\n    \"    \\n\",\n    \"    @typed_property(str, default=\\\"gpt-4\\\")\\n\",\n    \"    def model_name(self):\\n\",\n    \"        \\\"\\\"\\\"Name of the model.\\\"\\\"\\\"\\n\",\n    \"        pass\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"console.print(\\\"[bold blue]🏷️ Testing Typed Properties[/bold blue]\\\")\\n\",\n    \"\\n\",\n    \"model = ConfigurableModel()\\n\",\n    \"\\n\",\n    \"# Test default values\\n\",\n    \"console.print(f\\\"Default temperature: {model.temperature}\\\")\\n\",\n    \"console.print(f\\\"Default max_tokens: {model.max_tokens}\\\")\\n\",\n    \"console.print(f\\\"Default model_name: {model.model_name}\\\")\\n\",\n    \"\\n\",\n    \"# Test type conversion\\n\",\n    \"model.temperature = \\\"1.2\\\"  # String should convert to float\\n\",\n    \"model.max_tokens = \\\"500\\\"   # String should convert to int\\n\",\n    \"\\n\",\n    \"console.print(f\\\"Converted temperature: {model.temperature} (type: {type(model.temperature)})\\\")\\n\",\n    \"console.print(f\\\"Converted max_tokens: {model.max_tokens} (type: {type(model.max_tokens)})\\\")\\n\",\n    \"\\n\",\n    \"# Test validation\\n\",\n    \"try:\\n\",\n    \"    model.temperature = 3.0  # Should fail validation\\nexcept ValueError as e:\\n\",\n    \"    console.print(f\\\"❌ Validation error: {e}\\\")\\n\",\n    \"\\n\",\n    \"try:\\n\",\n    \"    model.max_tokens = -100  # Should fail validation\\nexcept ValueError as e:\\n\",\n    \"    console.print(f\\\"❌ Validation error: {e}\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold green]First Principle:[/bold green] Properties provide controlled attribute access\\\")\\n\",\n    \"console.print(\\\"[bold yellow]Python Idiom:[/bold yellow] Property factory pattern for dynamic properties\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Cell 6: Dynamic Configuration Context Manager\\n\",\n    \"\\n\",\n    \"class DynamicConfig:\\n\",\n    \"    \\\"\\\"\\\"Context manager that temporarily modifies class attributes.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, target_class: Type, **config_changes):\\n\",\n    \"        self.target_class = target_class\\n\",\n    \"        self.config_changes = config_changes\\n\",\n    \"        self.original_values = {}\\n\",\n    \"    \\n\",\n    \"    def __enter__(self):\\n\",\n    \"        # Save original values\\n\",\n    \"        for attr_name, new_value in self.config_changes.items():\\n\",\n    \"            if hasattr(self.target_class, attr_name):\\n\",\n    \"                self.original_values[attr_name] = getattr(self.target_class, attr_name)\\n\",\n    \"            setattr(self.target_class, attr_name, new_value)\\n\",\n    \"        return self\\n\",\n    \"    \\n\",\n    \"    def __exit__(self, exc_type, exc_val, exc_tb):\\n\",\n    \"        # Restore original values\\n\",\n    \"        for attr_name, original_value in self.original_values.items():\\n\",\n    \"            setattr(self.target_class, attr_name, original_value)\\n\",\n    \"        \\n\",\n    \"        # Remove attributes that didn't exist originally\\n\",\n    \"        for attr_name in self.config_changes:\\n\",\n    \"            if attr_name not in self.original_values:\\n\",\n    \"                delattr(self.target_class, attr_name)\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"# Example service class\\n\",\n    \"class AIService:\\n\",\n    \"    timeout = 30.0\\n\",\n    \"    retry_count = 3\\n\",\n    \"    debug_mode = False\\n\",\n    \"    \\n\",\n    \"    @classmethod\\n\",\n    \"    def get_config(cls) -> Dict[str, Any]:\\n\",\n    \"        return {\\n\",\n    \"            \\\"timeout\\\": cls.timeout,\\n\",\n    \"            \\\"retry_count\\\": cls.retry_count,\\n\",\n    \"            \\\"debug_mode\\\": cls.debug_mode\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"console.print(\\\"[bold blue]⚙️ Testing Dynamic Configuration[/bold blue]\\\")\\n\",\n    \"\\n\",\n    \"console.print(f\\\"Original configuration: {AIService.get_config()}\\\")\\n\",\n    \"\\n\",\n    \"# Temporarily modify configuration\\n\",\n    \"with DynamicConfig(AIService, timeout=60.0, debug_mode=True, new_feature=True):\\n\",\n    \"    console.print(f\\\"Inside context: {AIService.get_config()}\\\")\\n\",\n    \"    console.print(f\\\"New feature: {getattr(AIService, 'new_feature', 'Not found')}\\\")\\n\",\n    \"\\n\",\n    \"console.print(f\\\"After context: {AIService.get_config()}\\\")\\n\",\n    \"console.print(f\\\"New feature: {getattr(AIService, 'new_feature', 'Not found')}\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold green]First Principle:[/bold green] Context managers provide resource management\\\")\\n\",\n    \"console.print(\\\"[bold yellow]Python Idiom:[/bold yellow] __enter__ and __exit__ methods\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Cell 7: Reflection and Introspection\\n\",\n    \"import inspect\\n\",\n    \"from typing import get_type_hints, get_origin, get_args\\n\",\n    \"\\n\",\n    \"def analyze_function_signature(func: Callable) -> Dict[str, Any]:\\n\",\n    \"    \\\"\\\"\\\"Metaprogramming function to analyze function signatures.\\\"\\\"\\\"\\n\",\n    \"    sig = inspect.signature(func)\\n\",\n    \"    type_hints = get_type_hints(func)\\n\",\n    \"    \\n\",\n    \"    return {\\n\",\n    \"        \\\"name\\\": func.__name__,\\n\",\n    \"        \\\"parameters\\\": {\\n\",\n    \"            name: {\\n\",\n    \"                \\\"annotation\\\": type_hints.get(name, param.annotation),\\n\",\n    \"                \\\"default\\\": param.default if param.default != param.empty else None,\\n\",\n    \"                \\\"kind\\\": param.kind.name\\n\",\n    \"            }\\n\",\n    \"            for name, param in sig.parameters.items()\\n\",\n    \"        },\\n\",\n    \"        \\\"return_type\\\": type_hints.get('return', sig.return_annotation),\\n\",\n    \"        \\\"docstring\\\": inspect.getdoc(func)\\n\",\n    \"    }\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"def analyze_class_structure(cls: Type) -> Dict[str, Any]:\\n\",\n    \"    \\\"\\\"\\\"Analyze class structure using reflection.\\\"\\\"\\\"\\n\",\n    \"    instance = cls() if not inspect.isabstract(cls) else None\\n\",\n    \"    \\n\",\n    \"    methods = [name for name, method in inspect.getmembers(cls, predicate=inspect.ismethod)\\n\",\n    \"               if not name.startswith('_')]\\n\",\n    \"    \\n\",\n    \"    functions = [name for name, func in inspect.getmembers(cls, predicate=inspect.isfunction)\\n\",\n    \"                 if not name.startswith('_')]\\n\",\n    \"    \\n\",\n    \"    properties = [name for name in dir(cls) \\n\",\n    \"                  if isinstance(getattr(cls, name, None), property)]\\n\",\n    \"    \\n\",\n    \"    return {\\n\",\n    \"        \\\"class_name\\\": cls.__name__,\\n\",\n    \"        \\\"methods\\\": methods,\\n\",\n    \"        \\\"functions\\\": functions,\\n\",\n    \"        \\\"properties\\\": properties,\\n\",\n    \"        \\\"mro\\\": [c.__name__ for c in cls.__mro__],\\n\",\n    \"        \\\"docstring\\\": inspect.getdoc(cls)\\n\",\n    \"    }\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"console.print(\\\"[bold blue]🔍 Testing Reflection & Introspection[/bold blue]\\\")\\n\",\n    \"\\n\",\n    \"# Analyze function signatures\\n\",\n    \"def sample_ai_function(text: str, temperature: float = 0.7, max_tokens: Optional[int] = None) -> Dict[str, Any]:\\n\",\n    \"    \\\"\\\"\\\"Sample AI function for analysis.\\\"\\\"\\\"\\n\",\n    \"    return {\\\"processed\\\": text, \\\"config\\\": {\\\"temperature\\\": temperature, \\\"max_tokens\\\": max_tokens}}\\n\",\n    \"\\n\",\n    \"analysis = analyze_function_signature(sample_ai_function)\\n\",\n    \"\\n\",\n    \"console.print(f\\\"Function: {analysis['name']}\\\")\\n\",\n    \"console.print(f\\\"Return type: {analysis['return_type']}\\\")\\n\",\n    \"console.print(\\\"Parameters:\\\")\\n\",\n    \"for param_name, param_info in analysis['parameters'].items():\\n\",\n    \"    console.print(f\\\"  {param_name}: {param_info['annotation']} (default: {param_info['default']})\\\")\\n\",\n    \"\\n\",\n    \"# Analyze class structure\\n\",\n    \"class_analysis = analyze_class_structure(GPTModel)\\n\",\n    \"\\n\",\n    \"console.print(f\\\"\\\\nClass: {class_analysis['class_name']}\\\")\\n\",\n    \"console.print(f\\\"Methods: {class_analysis['methods']}\\\")\\n\",\n    \"console.print(f\\\"Functions: {class_analysis['functions']}\\\")\\n\",\n    \"console.print(f\\\"Properties: {class_analysis['properties']}\\\")\\n\",\n    \"console.print(f\\\"MRO: {class_analysis['mro']}\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold green]First Principle:[/bold green] Reflection enables runtime introspection\\\")\\n\",\n    \"console.print(\\\"[bold yellow]Python Idiom:[/bold yellow] inspect module for code analysis\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Cell 8: Complete Metaprogramming AI Framework\\n\",\n    \"\\n\",\n    \"class AdaptiveAIFramework:\\n\",\n    \"    \\\"\\\"\\\"Complete AI framework using all metaprogramming patterns.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self):\\n\",\n    \"        self.models = {}\\n\",\n    \"        self.configurations = {}\\n\",\n    \"        self.performance_metrics = {}\\n\",\n    \"    \\n\",\n    \"    def register_model_class(self, model_class: Type, config: Dict[str, Any] = None):\\n\",\n    \"        \\\"\\\"\\\"Register a model class with optional configuration.\\\"\\\"\\\"\\n\",\n    \"        model_id = getattr(model_class, 'model_id', model_class.__name__.lower())\\n\",\n    \"        self.models[model_id] = {\\n\",\n    \"            'class': model_class,\\n\",\n    \"            'config': config or {},\\n\",\n    \"            'analysis': analyze_class_structure(model_class)\\n\",\n    \"        }\\n\",\n    \"        console.print(f\\\"[dim]✅ Registered {model_id} with framework[/dim]\\\")\\n\",\n    \"    \\n\",\n    \"    def create_model(self, model_id: str, **kwargs) -> Any:\\n\",\n    \"        \\\"\\\"\\\"Create model instance with configuration.\\\"\\\"\\\"\\n\",\n    \"        if model_id not in self.models:\\n\",\n    \"            raise ValueError(f\\\"Model {model_id} not registered\\\")\\n\",\n    \"        \\n\",\n    \"        model_info = self.models[model_id]\\n\",\n    \"        config = {**model_info['config'], **kwargs}\\n\",\n    \"        \\n\",\n    \"        return model_info['class'](**config)\\n\",\n    \"    \\n\",\n    \"    def create_dynamic_ensemble(self, model_ids: list, ensemble_strategy: str = \\\"average\\\") -> Type:\\n\",\n    \"        \\\"\\\"\\\"Create dynamic ensemble from registered models.\\\"\\\"\\\"\\n\",\n    \"        model_classes = [self.models[mid]['class'] for mid in model_ids if mid in self.models]\\n\",\n    \"        \\n\",\n    \"        def ensemble_predict(self, text: str) -> Dict[str, Any]:\\n\",\n    \"            predictions = []\\n\",\n    \"            for model_class in model_classes:\\n\",\n    \"                model = model_class()\\n\",\n    \"                if hasattr(model, 'predict_text'):\\n\",\n    \"                    pred = model.predict_text(text)\\n\",\n    \"                    predictions.append(pred)\\n\",\n    \"                elif hasattr(model, 'predict'):\\n\",\n    \"                    pred = model.predict(text)\\n\",\n    \"                    predictions.append(pred)\\n\",\n    \"            \\n\",\n    \"            return {\\n\",\n    \"                \\\"ensemble_result\\\": predictions,\\n\",\n    \"                \\\"strategy\\\": ensemble_strategy,\\n\",\n    \"                \\\"model_count\\\": len(predictions)\\n\",\n    \"            }\\n\",\n    \"        \\n\",\n    \"        ensemble_class = create_model_class(\\n\",\n    \"            name=f\\\"DynamicEnsemble_{ensemble_strategy}\\\",\\n\",\n    \"            attributes={\\n\",\n    \"                \\\"component_models\\\": model_classes,\\n\",\n    \"                \\\"strategy\\\": ensemble_strategy\\n\",\n    \"            },\\n\",\n    \"            methods={\\\"predict_text\\\": ensemble_predict}\\n\",\n    \"        )\\n\",\n    \"        \\n\",\n    \"        return ensemble_class\\n\",\n    \"    \\n\",\n    \"    def analyze_framework(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Comprehensive framework analysis.\\\"\\\"\\\"\\n\",\n    \"        return {\\n\",\n    \"            \\\"registered_models\\\": list(self.models.keys()),\\n\",\n    \"            \\\"model_details\\\": {\\n\",\n    \"                mid: {\\n\",\n    \"                    \\\"class_name\\\": info['class'].__name__,\\n\",\n    \"                    \\\"methods\\\": info['analysis']['functions'],\\n\",\n    \"                    \\\"config_keys\\\": list(info['config'].keys())\\n\",\n    \"                }\\n\",\n    \"                for mid, info in self.models.items()\\n\",\n    \"            },\\n\",\n    \"            \\\"framework_capabilities\\\": [\\n\",\n    \"                \\\"Dynamic model registration\\\",\\n\",\n    \"                \\\"Automatic instrumentation\\\",\\n\",\n    \"                \\\"Runtime ensemble creation\\\",\\n\",\n    \"                \\\"Configuration management\\\",\\n\",\n    \"                \\\"Performance monitoring\\\"\\n\",\n    \"            ]\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"console.print(\\\"[bold blue]🚀 Testing Complete Metaprogramming AI Framework[/bold blue]\\\")\\n\",\n    \"\\n\",\n    \"# Create framework instance\\n\",\n    \"framework = AdaptiveAIFramework()\\n\",\n    \"\\n\",\n    \"# Register models with configurations\\n\",\n    \"framework.register_model_class(GPTModel, {\\\"temperature\\\": 0.8})\\n\",\n    \"framework.register_model_class(ClaudeModel, {\\\"temperature\\\": 0.6})\\n\",\n    \"\\n\",\n    \"# Create individual models\\n\",\n    \"gpt_model = framework.create_model(\\\"gptmodel\\\", max_tokens=500)\\n\",\n    \"claude_model = framework.create_model(\\\"claudemodel\\\")\\n\",\n    \"\\n\",\n    \"# Test predictions\\n\",\n    \"test_text = \\\"Explain quantum computing\\\"\\n\",\n    \"gpt_result = gpt_model.predict_text(test_text)\\n\",\n    \"claude_result = claude_model.predict_text(test_text)\\n\",\n    \"\\n\",\n    \"console.print(f\\\"GPT: {gpt_result}\\\")\\n\",\n    \"console.print(f\\\"Claude: {claude_result}\\\")\\n\",\n    \"\\n\",\n    \"# Create dynamic ensemble\\n\",\n    \"EnsembleClass = framework.create_dynamic_ensemble([\\\"gptmodel\\\", \\\"claudemodel\\\"], \\\"consensus\\\")\\n\",\n    \"ensemble = EnsembleClass()\\n\",\n    \"\\n\",\n    \"ensemble_result = ensemble.predict_text(test_text)\\n\",\n    \"console.print(f\\\"Ensemble: {ensemble_result}\\\")\\n\",\n    \"\\n\",\n    \"# Framework analysis\\n\",\n    \"analysis = framework.analyze_framework()\\n\",\n    \"console.print(f\\\"\\\\nFramework Analysis:\\\")\\n\",\n    \"console.print(f\\\"Registered models: {analysis['registered_models']}\\\")\\n\",\n    \"console.print(f\\\"Capabilities: {analysis['framework_capabilities']}\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold green]🎯 Metaprogramming Mastery Achieved![/bold green]\\\")\\n\",\n    \"console.print(\\\"[bold yellow]Key Patterns:[/bold yellow] Descriptors, Metaclasses, Dynamic Classes, Decorators, Reflection\\\")\\n\",\n    \"console.print(\\\"[bold cyan]Production Benefits:[/bold cyan] Flexible, self-adapting, maintainable AI systems\\\")\"\n   ]\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"Python 3\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.8.5\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 4\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":30505,"cache_read_input_tokens":15686,"output_tokens":1}},"requestId":"req_vrtx_011CRhT5NxvheVJdmpDzBavw","type":"assistant","uuid":"c75e198c-9548-48c7-9599-4266cbedc341","timestamp":"2025-08-01T18:21:37.564Z"}
{"parentUuid":"c75e198c-9548-48c7-9599-4266cbedc341","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_vrtx_01LaPQXY1PdDL7iy3yoAp7gk","type":"tool_result","content":"File created successfully at: /home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/notebooks/04_metaprogramming_learning.ipynb"}]},"uuid":"0e6c0a3f-ca13-42b2-b62a-949e0509d956","timestamp":"2025-08-01T18:21:37.592Z","toolUseResult":{"type":"create","filePath":"/home/skamenan/git/code/ai-patterns-hands-on/03-python-idioms/notebooks/04_metaprogramming_learning.ipynb","content":"{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"# 🏭 Metaprogramming for AI Systems - Learning Notebook\\n\",\n    \"\\n\",\n    \"**First Principles**: Metaprogramming is code that manipulates code. It allows us to create flexible, self-adapting systems that can modify their behavior at runtime.\\n\",\n    \"\\n\",\n    \"**Python Idioms**: Descriptors, metaclasses, decorators, dynamic class generation, and introspection enable powerful metaprogramming patterns.\\n\",\n    \"\\n\",\n    \"**AI Applications**: Dynamic model registration, automatic instrumentation, configuration management, and adaptive behavior.\\n\",\n    \"\\n\",\n    \"---\\n\",\n    \"\\n\",\n    \"## Learning Path\\n\",\n    \"1. **Descriptors** - Custom attribute access patterns\\n\",\n    \"2. **Metaclasses** - Class creation and automatic registration\\n\",\n    \"3. **Dynamic Classes** - Runtime class generation\\n\",\n    \"4. **Advanced Decorators** - Behavior modification patterns\\n\",\n    \"5. **Property Factories** - Type-safe dynamic properties\\n\",\n    \"6. **Context Managers** - Dynamic configuration management\\n\",\n    \"7. **Reflection** - Runtime introspection capabilities\\n\",\n    \"8. **Complete AI Framework** - Production-ready metaprogramming system\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Cell 1: Descriptors - Custom Attribute Access\\n\",\n    \"from typing import Any, Type, Callable, Dict, Optional\\n\",\n    \"from functools import update_wrapper\\n\",\n    \"import time\\n\",\n    \"from rich.console import Console\\n\",\n    \"\\n\",\n    \"console = Console()\\n\",\n    \"\\n\",\n    \"class ValidatedProperty:\\n\",\n    \"    \\\"\\\"\\\"Descriptor that validates property values.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, validator: Callable[[Any], bool], error_msg: str):\\n\",\n    \"        self.validator = validator\\n\",\n    \"        self.error_msg = error_msg\\n\",\n    \"        self.name = None\\n\",\n    \"    \\n\",\n    \"    def __set_name__(self, owner: Type, name: str):\\n\",\n    \"        \\\"\\\"\\\"Called when descriptor is assigned to a class attribute.\\\"\\\"\\\"\\n\",\n    \"        self.name = name\\n\",\n    \"        self.private_name = f'_{name}'\\n\",\n    \"    \\n\",\n    \"    def __get__(self, obj: Any, objtype: Type = None) -> Any:\\n\",\n    \"        if obj is None:\\n\",\n    \"            return self\\n\",\n    \"        return getattr(obj, self.private_name, None)\\n\",\n    \"    \\n\",\n    \"    def __set__(self, obj: Any, value: Any) -> None:\\n\",\n    \"        if not self.validator(value):\\n\",\n    \"            raise ValueError(f\\\"{self.error_msg}: {value}\\\")\\n\",\n    \"        setattr(obj, self.private_name, value)\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"class CachedProperty:\\n\",\n    \"    \\\"\\\"\\\"Descriptor that caches expensive computations.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, func: Callable):\\n\",\n    \"        self.func = func\\n\",\n    \"        self.name = func.__name__\\n\",\n    \"        update_wrapper(self, func)\\n\",\n    \"    \\n\",\n    \"    def __get__(self, obj: Any, objtype: Type = None) -> Any:\\n\",\n    \"        if obj is None:\\n\",\n    \"            return self\\n\",\n    \"        \\n\",\n    \"        cache_name = f'_cached_{self.name}'\\n\",\n    \"        if hasattr(obj, cache_name):\\n\",\n    \"            console.print(f\\\"[dim green]💾 Cache hit for {self.name}[/dim green]\\\")\\n\",\n    \"            return getattr(obj, cache_name)\\n\",\n    \"        \\n\",\n    \"        console.print(f\\\"[dim yellow]🔄 Computing {self.name}[/dim yellow]\\\")\\n\",\n    \"        value = self.func(obj)\\n\",\n    \"        setattr(obj, cache_name, value)\\n\",\n    \"        return value\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"# Example: AI Model with Validated Properties\\n\",\n    \"class AIModel:\\n\",\n    \"    \\\"\\\"\\\"AI model with validated properties using descriptors.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    temperature = ValidatedProperty(\\n\",\n    \"        lambda x: 0.0 <= x <= 2.0,\\n\",\n    \"        \\\"Temperature must be between 0.0 and 2.0\\\"\\n\",\n    \"    )\\n\",\n    \"    \\n\",\n    \"    max_tokens = ValidatedProperty(\\n\",\n    \"        lambda x: isinstance(x, int) and x > 0,\\n\",\n    \"        \\\"Max tokens must be a positive integer\\\"\\n\",\n    \"    )\\n\",\n    \"    \\n\",\n    \"    def __init__(self, temperature: float = 0.7, max_tokens: int = 1000):\\n\",\n    \"        self.temperature = temperature\\n\",\n    \"        self.max_tokens = max_tokens\\n\",\n    \"    \\n\",\n    \"    @CachedProperty\\n\",\n    \"    def model_signature(self) -> str:\\n\",\n    \"        \\\"\\\"\\\"Expensive computation that gets cached.\\\"\\\"\\\"\\n\",\n    \"        time.sleep(0.1)  # Simulate expensive computation\\n\",\n    \"        return f\\\"Model_{hash(str(self.temperature) + str(self.max_tokens))}\\\"\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"console.print(\\\"[bold blue]🔍 Testing Descriptors[/bold blue]\\\")\\n\",\n    \"\\n\",\n    \"# Test validation\\n\",\n    \"model = AIModel()\\n\",\n    \"console.print(f\\\"Default temperature: {model.temperature}\\\")\\n\",\n    \"\\n\",\n    \"model.temperature = 1.5\\n\",\n    \"console.print(f\\\"✅ Set temperature to {model.temperature}\\\")\\n\",\n    \"\\n\",\n    \"try:\\n\",\n    \"    model.temperature = 3.0  # Should fail\\nexcept ValueError as e:\\n\",\n    \"    console.print(f\\\"❌ Validation caught: {e}\\\")\\n\",\n    \"\\n\",\n    \"# Test cached property\\n\",\n    \"sig1 = model.model_signature  # Should compute\\n\",\n    \"sig2 = model.model_signature  # Should use cache\\n\",\n    \"console.print(f\\\"Signatures match: {sig1 == sig2}\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold green]First Principle:[/bold green] Descriptors control attribute access\\\")\\n\",\n    \"console.print(\\\"[bold yellow]Python Idiom:[/bold yellow] __get__, __set__, __set_name__ methods\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Cell 2: Metaclasses - Automatic Registration and Instrumentation\\n\",\n    \"\\n\",\n    \"class ModelRegistryMeta(type):\\n\",\n    \"    \\\"\\\"\\\"Metaclass that automatically registers AI models.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    _registry: Dict[str, Type] = {}\\n\",\n    \"    \\n\",\n    \"    def __new__(mcs, name: str, bases: tuple, namespace: dict, **kwargs):\\n\",\n    \"        # Add automatic ID generation\\n\",\n    \"        if 'model_id' not in namespace and name != 'BaseModel':\\n\",\n    \"            namespace['model_id'] = name.lower().replace('model', '')\\n\",\n    \"        \\n\",\n    \"        cls = super().__new__(mcs, name, bases, namespace)\\n\",\n    \"        \\n\",\n    \"        # Register the model\\n\",\n    \"        if name != 'BaseModel' and hasattr(cls, 'model_id'):\\n\",\n    \"            mcs._registry[cls.model_id] = cls\\n\",\n    \"            console.print(f\\\"[dim]🔧 Registered model: {cls.model_id} -> {name}[/dim]\\\")\\n\",\n    \"        \\n\",\n    \"        return cls\\n\",\n    \"    \\n\",\n    \"    @classmethod\\n\",\n    \"    def get_model(mcs, model_id: str) -> Optional[Type]:\\n\",\n    \"        return mcs._registry.get(model_id)\\n\",\n    \"    \\n\",\n    \"    @classmethod\\n\",\n    \"    def list_models(mcs) -> list:\\n\",\n    \"        return list(mcs._registry.keys())\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"class InstrumentedMeta(type):\\n\",\n    \"    \\\"\\\"\\\"Metaclass that adds automatic instrumentation.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __new__(mcs, name: str, bases: tuple, namespace: dict, **kwargs):\\n\",\n    \"        # Instrument methods that start with 'predict'\\n\",\n    \"        for attr_name, attr_value in namespace.items():\\n\",\n    \"            if (attr_name.startswith('predict') and \\n\",\n    \"                callable(attr_value) and \\n\",\n    \"                not attr_name.startswith('_')):\\n\",\n    \"                \\n\",\n    \"                namespace[attr_name] = mcs._instrument_method(attr_value, attr_name)\\n\",\n    \"        \\n\",\n    \"        return super().__new__(mcs, name, bases, namespace)\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def _instrument_method(method: Callable, method_name: str) -> Callable:\\n\",\n    \"        from functools import wraps\\n\",\n    \"        \\n\",\n    \"        @wraps(method)\\n\",\n    \"        def wrapper(self, *args, **kwargs):\\n\",\n    \"            start_time = time.time()\\n\",\n    \"            try:\\n\",\n    \"                result = method(self, *args, **kwargs)\\n\",\n    \"                duration = time.time() - start_time\\n\",\n    \"                \\n\",\n    \"                # Store metrics\\n\",\n    \"                if not hasattr(self, '_metrics'):\\n\",\n    \"                    self._metrics = {}\\n\",\n    \"                if method_name not in self._metrics:\\n\",\n    \"                    self._metrics[method_name] = []\\n\",\n    \"                \\n\",\n    \"                self._metrics[method_name].append({\\n\",\n    \"                    'duration': duration,\\n\",\n    \"                    'timestamp': start_time,\\n\",\n    \"                    'success': True\\n\",\n    \"                })\\n\",\n    \"                \\n\",\n    \"                console.print(f\\\"[dim]📊 {self.__class__.__name__}.{method_name} took {duration:.4f}s[/dim]\\\")\\n\",\n    \"                return result\\n\",\n    \"                \\n\",\n    \"            except Exception as e:\\n\",\n    \"                duration = time.time() - start_time\\n\",\n    \"                console.print(f\\\"[dim red]❌ {self.__class__.__name__}.{method_name} failed after {duration:.4f}s[/dim red]\\\")\\n\",\n    \"                raise\\n\",\n    \"        \\n\",\n    \"        return wrapper\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"# Base model with both metaclasses\\n\",\n    \"class BaseModel(metaclass=ModelRegistryMeta):\\n\",\n    \"    \\\"\\\"\\\"Base class for AI models.\\\"\\\"\\\"\\n\",\n    \"    pass\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"class GPTModel(BaseModel, metaclass=InstrumentedMeta):\\n\",\n    \"    \\\"\\\"\\\"GPT model with automatic instrumentation.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def predict_text(self, text: str) -> str:\\n\",\n    \"        time.sleep(0.05)  # Simulate prediction\\n\",\n    \"        return f\\\"GPT prediction for: {text}\\\"\\n\",\n    \"    \\n\",\n    \"    def predict_classification(self, text: str) -> Dict[str, float]:\\n\",\n    \"        time.sleep(0.03)\\n\",\n    \"        return {\\\"positive\\\": 0.8, \\\"negative\\\": 0.1, \\\"neutral\\\": 0.1}\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"class ClaudeModel(BaseModel, metaclass=InstrumentedMeta):\\n\",\n    \"    \\\"\\\"\\\"Claude model with automatic instrumentation.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def predict_text(self, text: str) -> str:\\n\",\n    \"        time.sleep(0.04)\\n\",\n    \"        return f\\\"Claude prediction for: {text}\\\"\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"console.print(\\\"[bold blue]🏭 Testing Metaclasses[/bold blue]\\\")\\n\",\n    \"\\n\",\n    \"# Show automatic registration\\n\",\n    \"registered_models = ModelRegistryMeta.list_models()\\n\",\n    \"console.print(f\\\"Registered models: {registered_models}\\\")\\n\",\n    \"\\n\",\n    \"# Create models from registry\\n\",\n    \"gpt_class = ModelRegistryMeta.get_model('gpt')\\n\",\n    \"claude_class = ModelRegistryMeta.get_model('claude')\\n\",\n    \"\\n\",\n    \"if gpt_class:\\n\",\n    \"    gpt = gpt_class()\\n\",\n    \"    result = gpt.predict_text(\\\"Hello world\\\")\\n\",\n    \"    console.print(f\\\"GPT: {result}\\\")\\n\",\n    \"\\n\",\n    \"if claude_class:\\n\",\n    \"    claude = claude_class()\\n\",\n    \"    result = claude.predict_text(\\\"Hello world\\\")\\n\",\n    \"    console.print(f\\\"Claude: {result}\\\")\\n\",\n    \"\\n\",\n    \"# Show automatic instrumentation\\n\",\n    \"if hasattr(gpt, '_metrics'):\\n\",\n    \"    for method, metrics in gpt._metrics.items():\\n\",\n    \"        avg_duration = sum(m['duration'] for m in metrics) / len(metrics)\\n\",\n    \"        console.print(f\\\"Metrics - {method}: {len(metrics)} calls, avg {avg_duration:.4f}s\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold green]First Principle:[/bold green] Metaclasses control class creation\\\")\\n\",\n    \"console.print(\\\"[bold yellow]Python Idiom:[/bold yellow] __new__ method in metaclass\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Cell 3: Dynamic Class Generation\\n\",\n    \"\\n\",\n    \"def create_model_class(\\n\",\n    \"    name: str, \\n\",\n    \"    attributes: Dict[str, Any], \\n\",\n    \"    methods: Dict[str, Callable] = None,\\n\",\n    \"    base_classes: tuple = ()\\n\",\n    \") -> Type:\\n\",\n    \"    \\\"\\\"\\\"Dynamically create a model class.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    if not base_classes:\\n\",\n    \"        base_classes = (object,)\\n\",\n    \"    \\n\",\n    \"    namespace = attributes.copy()\\n\",\n    \"    if methods:\\n\",\n    \"        namespace.update(methods)\\n\",\n    \"    \\n\",\n    \"    # Add default __init__ if not provided\\n\",\n    \"    if '__init__' not in namespace:\\n\",\n    \"        def __init__(self, **kwargs):\\n\",\n    \"            for key, value in kwargs.items():\\n\",\n    \"                setattr(self, key, value)\\n\",\n    \"        namespace['__init__'] = __init__\\n\",\n    \"    \\n\",\n    \"    return type(name, base_classes, namespace)\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"class ModelFactory:\\n\",\n    \"    \\\"\\\"\\\"Factory for creating model classes dynamically.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def create_simple_model(name: str, prediction_delay: float = 0.1) -> Type:\\n\",\n    \"        \\\"\\\"\\\"Create a simple model class.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        def predict(self, text: str) -> str:\\n\",\n    \"            time.sleep(prediction_delay)\\n\",\n    \"            return f\\\"{name} processed: {text}\\\"\\n\",\n    \"        \\n\",\n    \"        def get_info(self) -> Dict[str, Any]:\\n\",\n    \"            return {\\n\",\n    \"                \\\"model_name\\\": name,\\n\",\n    \"                \\\"prediction_delay\\\": prediction_delay,\\n\",\n    \"                \\\"class_name\\\": self.__class__.__name__\\n\",\n    \"            }\\n\",\n    \"        \\n\",\n    \"        return create_model_class(\\n\",\n    \"            name=f\\\"{name}Model\\\",\\n\",\n    \"            attributes={\\n\",\n    \"                \\\"model_name\\\": name,\\n\",\n    \"                \\\"prediction_delay\\\": prediction_delay\\n\",\n    \"            },\\n\",\n    \"            methods={\\n\",\n    \"                \\\"predict\\\": predict,\\n\",\n    \"                \\\"get_info\\\": get_info\\n\",\n    \"            },\\n\",\n    \"            base_classes=(BaseModel,)\\n\",\n    \"        )\\n\",\n    \"    \\n\",\n    \"    @staticmethod\\n\",\n    \"    def create_ensemble_model(models: list) -> Type:\\n\",\n    \"        \\\"\\\"\\\"Create an ensemble model from multiple model classes.\\\"\\\"\\\"\\n\",\n    \"        \\n\",\n    \"        def predict(self, text: str) -> list:\\n\",\n    \"            results = []\\n\",\n    \"            for model_class in models:\\n\",\n    \"                model = model_class()\\n\",\n    \"                if hasattr(model, 'predict'):\\n\",\n    \"                    results.append(model.predict(text))\\n\",\n    \"                elif hasattr(model, 'predict_text'):\\n\",\n    \"                    results.append(model.predict_text(text))\\n\",\n    \"            return results\\n\",\n    \"        \\n\",\n    \"        def get_model_info(self) -> list:\\n\",\n    \"            return [model.__name__ for model in models]\\n\",\n    \"        \\n\",\n    \"        return create_model_class(\\n\",\n    \"            name=\\\"EnsembleModel\\\",\\n\",\n    \"            attributes={\\\"component_models\\\": models},\\n\",\n    \"            methods={\\n\",\n    \"                \\\"predict\\\": predict,\\n\",\n    \"                \\\"get_model_info\\\": get_model_info\\n\",\n    \"            }\\n\",\n    \"        )\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"console.print(\\\"[bold blue]⚡ Testing Dynamic Class Creation[/bold blue]\\\")\\n\",\n    \"\\n\",\n    \"# Create models using factory\\n\",\n    \"FastModel = ModelFactory.create_simple_model(\\\"FastAI\\\", prediction_delay=0.02)\\n\",\n    \"SlowModel = ModelFactory.create_simple_model(\\\"DeepThink\\\", prediction_delay=0.08)\\n\",\n    \"\\n\",\n    \"fast_model = FastModel()\\n\",\n    \"slow_model = SlowModel()\\n\",\n    \"\\n\",\n    \"console.print(f\\\"Fast model: {fast_model.get_info()}\\\")\\n\",\n    \"console.print(f\\\"Slow model: {slow_model.get_info()}\\\")\\n\",\n    \"\\n\",\n    \"# Test predictions\\n\",\n    \"start_time = time.time()\\n\",\n    \"fast_result = fast_model.predict(\\\"test input\\\")\\n\",\n    \"fast_time = time.time() - start_time\\n\",\n    \"\\n\",\n    \"start_time = time.time()\\n\",\n    \"slow_result = slow_model.predict(\\\"test input\\\")\\n\",\n    \"slow_time = time.time() - start_time\\n\",\n    \"\\n\",\n    \"console.print(f\\\"Performance - Fast: {fast_time:.4f}s, Slow: {slow_time:.4f}s\\\")\\n\",\n    \"\\n\",\n    \"# Create ensemble model\\n\",\n    \"EnsembleModel = ModelFactory.create_ensemble_model([FastModel, SlowModel])\\n\",\n    \"ensemble = EnsembleModel()\\n\",\n    \"\\n\",\n    \"ensemble_results = ensemble.predict(\\\"ensemble test\\\")\\n\",\n    \"console.print(f\\\"Ensemble results: {ensemble_results}\\\")\\n\",\n    \"console.print(f\\\"Component models: {ensemble.get_model_info()}\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold green]First Principle:[/bold green] Classes are objects that can be created at runtime\\\")\\n\",\n    \"console.print(\\\"[bold yellow]Python Idiom:[/bold yellow] type() function for dynamic class creation\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Cell 4: Advanced Decorators with State\\n\",\n    \"from functools import wraps\\n\",\n    \"\\n\",\n    \"class memoize_with_ttl:\\n\",\n    \"    \\\"\\\"\\\"Decorator that memoizes with time-to-live.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, ttl_seconds: float = 60.0):\\n\",\n    \"        self.ttl_seconds = ttl_seconds\\n\",\n    \"        self.cache = {}\\n\",\n    \"    \\n\",\n    \"    def __call__(self, func: Callable) -> Callable:\\n\",\n    \"        @wraps(func)\\n\",\n    \"        def wrapper(*args, **kwargs):\\n\",\n    \"            # Create cache key\\n\",\n    \"            key = str(args) + str(sorted(kwargs.items()))\\n\",\n    \"            current_time = time.time()\\n\",\n    \"            \\n\",\n    \"            # Check if cached and not expired\\n\",\n    \"            if key in self.cache:\\n\",\n    \"                result, timestamp = self.cache[key]\\n\",\n    \"                if current_time - timestamp < self.ttl_seconds:\\n\",\n    \"                    console.print(f\\\"[dim green]💾 Cache hit for {func.__name__}[/dim green]\\\")\\n\",\n    \"                    return result\\n\",\n    \"            \\n\",\n    \"            # Compute new result\\n\",\n    \"            result = func(*args, **kwargs)\\n\",\n    \"            self.cache[key] = (result, current_time)\\n\",\n    \"            console.print(f\\\"[dim yellow]🔄 Cache miss for {func.__name__}[/dim yellow]\\\")\\n\",\n    \"            return result\\n\",\n    \"        \\n\",\n    \"        # Add cache management methods\\n\",\n    \"        wrapper.clear_cache = lambda: self.cache.clear()\\n\",\n    \"        wrapper.cache_info = lambda: {\\n\",\n    \"            'size': len(self.cache),\\n\",\n    \"            'ttl_seconds': self.ttl_seconds\\n\",\n    \"        }\\n\",\n    \"        \\n\",\n    \"        return wrapper\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"class retry_with_backoff:\\n\",\n    \"    \\\"\\\"\\\"Decorator that retries with exponential backoff.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, max_retries: int = 3, base_delay: float = 1.0):\\n\",\n    \"        self.max_retries = max_retries\\n\",\n    \"        self.base_delay = base_delay\\n\",\n    \"    \\n\",\n    \"    def __call__(self, func: Callable) -> Callable:\\n\",\n    \"        @wraps(func)\\n\",\n    \"        def wrapper(*args, **kwargs):\\n\",\n    \"            last_exception = None\\n\",\n    \"            \\n\",\n    \"            for attempt in range(self.max_retries + 1):\\n\",\n    \"                try:\\n\",\n    \"                    return func(*args, **kwargs)\\n\",\n    \"                except Exception as e:\\n\",\n    \"                    last_exception = e\\n\",\n    \"                    \\n\",\n    \"                    if attempt < self.max_retries:\\n\",\n    \"                        delay = self.base_delay * (2 ** attempt)\\n\",\n    \"                        console.print(f\\\"[yellow]🔄 Retry {attempt + 1}/{self.max_retries} in {delay:.1f}s[/yellow]\\\")\\n\",\n    \"                        time.sleep(delay)\\n\",\n    \"                    else:\\n\",\n    \"                        console.print(f\\\"[red]❌ All retries exhausted for {func.__name__}[/red]\\\")\\n\",\n    \"            \\n\",\n    \"            raise last_exception\\n\",\n    \"        \\n\",\n    \"        return wrapper\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"console.print(\\\"[bold blue]🎨 Testing Advanced Decorators[/bold blue]\\\")\\n\",\n    \"\\n\",\n    \"@memoize_with_ttl(ttl_seconds=2.0)\\n\",\n    \"@retry_with_backoff(max_retries=2, base_delay=0.5)\\n\",\n    \"def expensive_ai_call(query: str, fail_rate: float = 0.0) -> str:\\n\",\n    \"    \\\"\\\"\\\"Simulate expensive AI call that might fail.\\\"\\\"\\\"\\n\",\n    \"    import random\\n\",\n    \"    \\n\",\n    \"    if random.random() < fail_rate:\\n\",\n    \"        raise ConnectionError(\\\"Simulated API failure\\\")\\n\",\n    \"    \\n\",\n    \"    time.sleep(0.1)  # Simulate processing time\\n\",\n    \"    return f\\\"AI response to: {query}\\\"\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"# Test decorated function\\n\",\n    \"result1 = expensive_ai_call(\\\"What is AI?\\\")\\n\",\n    \"console.print(f\\\"Result 1: {result1}\\\")\\n\",\n    \"\\n\",\n    \"result2 = expensive_ai_call(\\\"What is AI?\\\")  # Should use cache\\n\",\n    \"console.print(f\\\"Result 2: {result2}\\\")\\n\",\n    \"\\n\",\n    \"# Test with failures\\n\",\n    \"try:\\n\",\n    \"    result3 = expensive_ai_call(\\\"Risky query\\\", fail_rate=0.7)\\n\",\n    \"    console.print(f\\\"Success: {result3}\\\")\\n\",\n    \"except Exception as e:\\n\",\n    \"    console.print(f\\\"Failed: {e}\\\")\\n\",\n    \"\\n\",\n    \"cache_info = expensive_ai_call.cache_info()\\n\",\n    \"console.print(f\\\"Cache info: {cache_info}\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold green]First Principle:[/bold green] Decorators modify function behavior\\\")\\n\",\n    \"console.print(\\\"[bold yellow]Python Idiom:[/bold yellow] __call__ method for stateful decorators\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Cell 5: Property Factory - Type-Safe Dynamic Properties\\n\",\n    \"\\n\",\n    \"def typed_property(property_type: Type, default: Any = None, validator: Callable = None):\\n\",\n    \"    \\\"\\\"\\\"Factory for creating typed properties with optional validation.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def property_decorator(func: Callable) -> property:\\n\",\n    \"        name = func.__name__\\n\",\n    \"        private_name = f'_{name}'\\n\",\n    \"        \\n\",\n    \"        def getter(self):\\n\",\n    \"            return getattr(self, private_name, default)\\n\",\n    \"        \\n\",\n    \"        def setter(self, value):\\n\",\n    \"            # Type checking\\n\",\n    \"            if not isinstance(value, property_type):\\n\",\n    \"                try:\\n\",\n    \"                    value = property_type(value)\\n\",\n    \"                except (ValueError, TypeError):\\n\",\n    \"                    raise TypeError(f\\\"{name} must be of type {property_type.__name__}\\\")\\n\",\n    \"            \\n\",\n    \"            # Optional validation\\n\",\n    \"            if validator and not validator(value):\\n\",\n    \"                raise ValueError(f\\\"Invalid value for {name}: {value}\\\")\\n\",\n    \"            \\n\",\n    \"            setattr(self, private_name, value)\\n\",\n    \"        \\n\",\n    \"        return property(getter, setter, doc=func.__doc__)\\n\",\n    \"    \\n\",\n    \"    return property_decorator\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"class ConfigurableModel:\\n\",\n    \"    \\\"\\\"\\\"Model with typed properties using property factory.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    @typed_property(float, default=0.7, validator=lambda x: 0.0 <= x <= 2.0)\\n\",\n    \"    def temperature(self):\\n\",\n    \"        \\\"\\\"\\\"Model temperature parameter.\\\"\\\"\\\"\\n\",\n    \"        pass\\n\",\n    \"    \\n\",\n    \"    @typed_property(int, default=1000, validator=lambda x: x > 0)\\n\",\n    \"    def max_tokens(self):\\n\",\n    \"        \\\"\\\"\\\"Maximum tokens to generate.\\\"\\\"\\\"\\n\",\n    \"        pass\\n\",\n    \"    \\n\",\n    \"    @typed_property(str, default=\\\"gpt-4\\\")\\n\",\n    \"    def model_name(self):\\n\",\n    \"        \\\"\\\"\\\"Name of the model.\\\"\\\"\\\"\\n\",\n    \"        pass\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"console.print(\\\"[bold blue]🏷️ Testing Typed Properties[/bold blue]\\\")\\n\",\n    \"\\n\",\n    \"model = ConfigurableModel()\\n\",\n    \"\\n\",\n    \"# Test default values\\n\",\n    \"console.print(f\\\"Default temperature: {model.temperature}\\\")\\n\",\n    \"console.print(f\\\"Default max_tokens: {model.max_tokens}\\\")\\n\",\n    \"console.print(f\\\"Default model_name: {model.model_name}\\\")\\n\",\n    \"\\n\",\n    \"# Test type conversion\\n\",\n    \"model.temperature = \\\"1.2\\\"  # String should convert to float\\n\",\n    \"model.max_tokens = \\\"500\\\"   # String should convert to int\\n\",\n    \"\\n\",\n    \"console.print(f\\\"Converted temperature: {model.temperature} (type: {type(model.temperature)})\\\")\\n\",\n    \"console.print(f\\\"Converted max_tokens: {model.max_tokens} (type: {type(model.max_tokens)})\\\")\\n\",\n    \"\\n\",\n    \"# Test validation\\n\",\n    \"try:\\n\",\n    \"    model.temperature = 3.0  # Should fail validation\\nexcept ValueError as e:\\n\",\n    \"    console.print(f\\\"❌ Validation error: {e}\\\")\\n\",\n    \"\\n\",\n    \"try:\\n\",\n    \"    model.max_tokens = -100  # Should fail validation\\nexcept ValueError as e:\\n\",\n    \"    console.print(f\\\"❌ Validation error: {e}\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold green]First Principle:[/bold green] Properties provide controlled attribute access\\\")\\n\",\n    \"console.print(\\\"[bold yellow]Python Idiom:[/bold yellow] Property factory pattern for dynamic properties\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Cell 6: Dynamic Configuration Context Manager\\n\",\n    \"\\n\",\n    \"class DynamicConfig:\\n\",\n    \"    \\\"\\\"\\\"Context manager that temporarily modifies class attributes.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self, target_class: Type, **config_changes):\\n\",\n    \"        self.target_class = target_class\\n\",\n    \"        self.config_changes = config_changes\\n\",\n    \"        self.original_values = {}\\n\",\n    \"    \\n\",\n    \"    def __enter__(self):\\n\",\n    \"        # Save original values\\n\",\n    \"        for attr_name, new_value in self.config_changes.items():\\n\",\n    \"            if hasattr(self.target_class, attr_name):\\n\",\n    \"                self.original_values[attr_name] = getattr(self.target_class, attr_name)\\n\",\n    \"            setattr(self.target_class, attr_name, new_value)\\n\",\n    \"        return self\\n\",\n    \"    \\n\",\n    \"    def __exit__(self, exc_type, exc_val, exc_tb):\\n\",\n    \"        # Restore original values\\n\",\n    \"        for attr_name, original_value in self.original_values.items():\\n\",\n    \"            setattr(self.target_class, attr_name, original_value)\\n\",\n    \"        \\n\",\n    \"        # Remove attributes that didn't exist originally\\n\",\n    \"        for attr_name in self.config_changes:\\n\",\n    \"            if attr_name not in self.original_values:\\n\",\n    \"                delattr(self.target_class, attr_name)\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"# Example service class\\n\",\n    \"class AIService:\\n\",\n    \"    timeout = 30.0\\n\",\n    \"    retry_count = 3\\n\",\n    \"    debug_mode = False\\n\",\n    \"    \\n\",\n    \"    @classmethod\\n\",\n    \"    def get_config(cls) -> Dict[str, Any]:\\n\",\n    \"        return {\\n\",\n    \"            \\\"timeout\\\": cls.timeout,\\n\",\n    \"            \\\"retry_count\\\": cls.retry_count,\\n\",\n    \"            \\\"debug_mode\\\": cls.debug_mode\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"console.print(\\\"[bold blue]⚙️ Testing Dynamic Configuration[/bold blue]\\\")\\n\",\n    \"\\n\",\n    \"console.print(f\\\"Original configuration: {AIService.get_config()}\\\")\\n\",\n    \"\\n\",\n    \"# Temporarily modify configuration\\n\",\n    \"with DynamicConfig(AIService, timeout=60.0, debug_mode=True, new_feature=True):\\n\",\n    \"    console.print(f\\\"Inside context: {AIService.get_config()}\\\")\\n\",\n    \"    console.print(f\\\"New feature: {getattr(AIService, 'new_feature', 'Not found')}\\\")\\n\",\n    \"\\n\",\n    \"console.print(f\\\"After context: {AIService.get_config()}\\\")\\n\",\n    \"console.print(f\\\"New feature: {getattr(AIService, 'new_feature', 'Not found')}\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold green]First Principle:[/bold green] Context managers provide resource management\\\")\\n\",\n    \"console.print(\\\"[bold yellow]Python Idiom:[/bold yellow] __enter__ and __exit__ methods\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Cell 7: Reflection and Introspection\\n\",\n    \"import inspect\\n\",\n    \"from typing import get_type_hints, get_origin, get_args\\n\",\n    \"\\n\",\n    \"def analyze_function_signature(func: Callable) -> Dict[str, Any]:\\n\",\n    \"    \\\"\\\"\\\"Metaprogramming function to analyze function signatures.\\\"\\\"\\\"\\n\",\n    \"    sig = inspect.signature(func)\\n\",\n    \"    type_hints = get_type_hints(func)\\n\",\n    \"    \\n\",\n    \"    return {\\n\",\n    \"        \\\"name\\\": func.__name__,\\n\",\n    \"        \\\"parameters\\\": {\\n\",\n    \"            name: {\\n\",\n    \"                \\\"annotation\\\": type_hints.get(name, param.annotation),\\n\",\n    \"                \\\"default\\\": param.default if param.default != param.empty else None,\\n\",\n    \"                \\\"kind\\\": param.kind.name\\n\",\n    \"            }\\n\",\n    \"            for name, param in sig.parameters.items()\\n\",\n    \"        },\\n\",\n    \"        \\\"return_type\\\": type_hints.get('return', sig.return_annotation),\\n\",\n    \"        \\\"docstring\\\": inspect.getdoc(func)\\n\",\n    \"    }\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"def analyze_class_structure(cls: Type) -> Dict[str, Any]:\\n\",\n    \"    \\\"\\\"\\\"Analyze class structure using reflection.\\\"\\\"\\\"\\n\",\n    \"    instance = cls() if not inspect.isabstract(cls) else None\\n\",\n    \"    \\n\",\n    \"    methods = [name for name, method in inspect.getmembers(cls, predicate=inspect.ismethod)\\n\",\n    \"               if not name.startswith('_')]\\n\",\n    \"    \\n\",\n    \"    functions = [name for name, func in inspect.getmembers(cls, predicate=inspect.isfunction)\\n\",\n    \"                 if not name.startswith('_')]\\n\",\n    \"    \\n\",\n    \"    properties = [name for name in dir(cls) \\n\",\n    \"                  if isinstance(getattr(cls, name, None), property)]\\n\",\n    \"    \\n\",\n    \"    return {\\n\",\n    \"        \\\"class_name\\\": cls.__name__,\\n\",\n    \"        \\\"methods\\\": methods,\\n\",\n    \"        \\\"functions\\\": functions,\\n\",\n    \"        \\\"properties\\\": properties,\\n\",\n    \"        \\\"mro\\\": [c.__name__ for c in cls.__mro__],\\n\",\n    \"        \\\"docstring\\\": inspect.getdoc(cls)\\n\",\n    \"    }\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"console.print(\\\"[bold blue]🔍 Testing Reflection & Introspection[/bold blue]\\\")\\n\",\n    \"\\n\",\n    \"# Analyze function signatures\\n\",\n    \"def sample_ai_function(text: str, temperature: float = 0.7, max_tokens: Optional[int] = None) -> Dict[str, Any]:\\n\",\n    \"    \\\"\\\"\\\"Sample AI function for analysis.\\\"\\\"\\\"\\n\",\n    \"    return {\\\"processed\\\": text, \\\"config\\\": {\\\"temperature\\\": temperature, \\\"max_tokens\\\": max_tokens}}\\n\",\n    \"\\n\",\n    \"analysis = analyze_function_signature(sample_ai_function)\\n\",\n    \"\\n\",\n    \"console.print(f\\\"Function: {analysis['name']}\\\")\\n\",\n    \"console.print(f\\\"Return type: {analysis['return_type']}\\\")\\n\",\n    \"console.print(\\\"Parameters:\\\")\\n\",\n    \"for param_name, param_info in analysis['parameters'].items():\\n\",\n    \"    console.print(f\\\"  {param_name}: {param_info['annotation']} (default: {param_info['default']})\\\")\\n\",\n    \"\\n\",\n    \"# Analyze class structure\\n\",\n    \"class_analysis = analyze_class_structure(GPTModel)\\n\",\n    \"\\n\",\n    \"console.print(f\\\"\\\\nClass: {class_analysis['class_name']}\\\")\\n\",\n    \"console.print(f\\\"Methods: {class_analysis['methods']}\\\")\\n\",\n    \"console.print(f\\\"Functions: {class_analysis['functions']}\\\")\\n\",\n    \"console.print(f\\\"Properties: {class_analysis['properties']}\\\")\\n\",\n    \"console.print(f\\\"MRO: {class_analysis['mro']}\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold green]First Principle:[/bold green] Reflection enables runtime introspection\\\")\\n\",\n    \"console.print(\\\"[bold yellow]Python Idiom:[/bold yellow] inspect module for code analysis\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Cell 8: Complete Metaprogramming AI Framework\\n\",\n    \"\\n\",\n    \"class AdaptiveAIFramework:\\n\",\n    \"    \\\"\\\"\\\"Complete AI framework using all metaprogramming patterns.\\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    def __init__(self):\\n\",\n    \"        self.models = {}\\n\",\n    \"        self.configurations = {}\\n\",\n    \"        self.performance_metrics = {}\\n\",\n    \"    \\n\",\n    \"    def register_model_class(self, model_class: Type, config: Dict[str, Any] = None):\\n\",\n    \"        \\\"\\\"\\\"Register a model class with optional configuration.\\\"\\\"\\\"\\n\",\n    \"        model_id = getattr(model_class, 'model_id', model_class.__name__.lower())\\n\",\n    \"        self.models[model_id] = {\\n\",\n    \"            'class': model_class,\\n\",\n    \"            'config': config or {},\\n\",\n    \"            'analysis': analyze_class_structure(model_class)\\n\",\n    \"        }\\n\",\n    \"        console.print(f\\\"[dim]✅ Registered {model_id} with framework[/dim]\\\")\\n\",\n    \"    \\n\",\n    \"    def create_model(self, model_id: str, **kwargs) -> Any:\\n\",\n    \"        \\\"\\\"\\\"Create model instance with configuration.\\\"\\\"\\\"\\n\",\n    \"        if model_id not in self.models:\\n\",\n    \"            raise ValueError(f\\\"Model {model_id} not registered\\\")\\n\",\n    \"        \\n\",\n    \"        model_info = self.models[model_id]\\n\",\n    \"        config = {**model_info['config'], **kwargs}\\n\",\n    \"        \\n\",\n    \"        return model_info['class'](**config)\\n\",\n    \"    \\n\",\n    \"    def create_dynamic_ensemble(self, model_ids: list, ensemble_strategy: str = \\\"average\\\") -> Type:\\n\",\n    \"        \\\"\\\"\\\"Create dynamic ensemble from registered models.\\\"\\\"\\\"\\n\",\n    \"        model_classes = [self.models[mid]['class'] for mid in model_ids if mid in self.models]\\n\",\n    \"        \\n\",\n    \"        def ensemble_predict(self, text: str) -> Dict[str, Any]:\\n\",\n    \"            predictions = []\\n\",\n    \"            for model_class in model_classes:\\n\",\n    \"                model = model_class()\\n\",\n    \"                if hasattr(model, 'predict_text'):\\n\",\n    \"                    pred = model.predict_text(text)\\n\",\n    \"                    predictions.append(pred)\\n\",\n    \"                elif hasattr(model, 'predict'):\\n\",\n    \"                    pred = model.predict(text)\\n\",\n    \"                    predictions.append(pred)\\n\",\n    \"            \\n\",\n    \"            return {\\n\",\n    \"                \\\"ensemble_result\\\": predictions,\\n\",\n    \"                \\\"strategy\\\": ensemble_strategy,\\n\",\n    \"                \\\"model_count\\\": len(predictions)\\n\",\n    \"            }\\n\",\n    \"        \\n\",\n    \"        ensemble_class = create_model_class(\\n\",\n    \"            name=f\\\"DynamicEnsemble_{ensemble_strategy}\\\",\\n\",\n    \"            attributes={\\n\",\n    \"                \\\"component_models\\\": model_classes,\\n\",\n    \"                \\\"strategy\\\": ensemble_strategy\\n\",\n    \"            },\\n\",\n    \"            methods={\\\"predict_text\\\": ensemble_predict}\\n\",\n    \"        )\\n\",\n    \"        \\n\",\n    \"        return ensemble_class\\n\",\n    \"    \\n\",\n    \"    def analyze_framework(self) -> Dict[str, Any]:\\n\",\n    \"        \\\"\\\"\\\"Comprehensive framework analysis.\\\"\\\"\\\"\\n\",\n    \"        return {\\n\",\n    \"            \\\"registered_models\\\": list(self.models.keys()),\\n\",\n    \"            \\\"model_details\\\": {\\n\",\n    \"                mid: {\\n\",\n    \"                    \\\"class_name\\\": info['class'].__name__,\\n\",\n    \"                    \\\"methods\\\": info['analysis']['functions'],\\n\",\n    \"                    \\\"config_keys\\\": list(info['config'].keys())\\n\",\n    \"                }\\n\",\n    \"                for mid, info in self.models.items()\\n\",\n    \"            },\\n\",\n    \"            \\\"framework_capabilities\\\": [\\n\",\n    \"                \\\"Dynamic model registration\\\",\\n\",\n    \"                \\\"Automatic instrumentation\\\",\\n\",\n    \"                \\\"Runtime ensemble creation\\\",\\n\",\n    \"                \\\"Configuration management\\\",\\n\",\n    \"                \\\"Performance monitoring\\\"\\n\",\n    \"            ]\\n\",\n    \"        }\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"console.print(\\\"[bold blue]🚀 Testing Complete Metaprogramming AI Framework[/bold blue]\\\")\\n\",\n    \"\\n\",\n    \"# Create framework instance\\n\",\n    \"framework = AdaptiveAIFramework()\\n\",\n    \"\\n\",\n    \"# Register models with configurations\\n\",\n    \"framework.register_model_class(GPTModel, {\\\"temperature\\\": 0.8})\\n\",\n    \"framework.register_model_class(ClaudeModel, {\\\"temperature\\\": 0.6})\\n\",\n    \"\\n\",\n    \"# Create individual models\\n\",\n    \"gpt_model = framework.create_model(\\\"gptmodel\\\", max_tokens=500)\\n\",\n    \"claude_model = framework.create_model(\\\"claudemodel\\\")\\n\",\n    \"\\n\",\n    \"# Test predictions\\n\",\n    \"test_text = \\\"Explain quantum computing\\\"\\n\",\n    \"gpt_result = gpt_model.predict_text(test_text)\\n\",\n    \"claude_result = claude_model.predict_text(test_text)\\n\",\n    \"\\n\",\n    \"console.print(f\\\"GPT: {gpt_result}\\\")\\n\",\n    \"console.print(f\\\"Claude: {claude_result}\\\")\\n\",\n    \"\\n\",\n    \"# Create dynamic ensemble\\n\",\n    \"EnsembleClass = framework.create_dynamic_ensemble([\\\"gptmodel\\\", \\\"claudemodel\\\"], \\\"consensus\\\")\\n\",\n    \"ensemble = EnsembleClass()\\n\",\n    \"\\n\",\n    \"ensemble_result = ensemble.predict_text(test_text)\\n\",\n    \"console.print(f\\\"Ensemble: {ensemble_result}\\\")\\n\",\n    \"\\n\",\n    \"# Framework analysis\\n\",\n    \"analysis = framework.analyze_framework()\\n\",\n    \"console.print(f\\\"\\\\nFramework Analysis:\\\")\\n\",\n    \"console.print(f\\\"Registered models: {analysis['registered_models']}\\\")\\n\",\n    \"console.print(f\\\"Capabilities: {analysis['framework_capabilities']}\\\")\\n\",\n    \"\\n\",\n    \"console.print(\\\"\\\\n[bold green]🎯 Metaprogramming Mastery Achieved![/bold green]\\\")\\n\",\n    \"console.print(\\\"[bold yellow]Key Patterns:[/bold yellow] Descriptors, Metaclasses, Dynamic Classes, Decorators, Reflection\\\")\\n\",\n    \"console.print(\\\"[bold cyan]Production Benefits:[/bold cyan] Flexible, self-adapting, maintainable AI systems\\\")\"\n   ]\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"Python 3\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.8.5\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 4\n}","structuredPatch":[]}}
{"parentUuid":"0e6c0a3f-ca13-42b2-b62a-949e0509d956","isSidechain":false,"userType":"external","cwd":"/home/skamenan/git/code/ai-patterns-hands-on","sessionId":"7341357d-7df3-4d52-acd0-2d3b8e57d414","version":"1.0.65","gitBranch":"","message":{"id":"msg_vrtx_01YQDQv2QW5jUarRFDpY8oJ7","type":"message","role":"assistant","model":"claude-sonnet-4-20250514","content":[{"type":"text","text":"Perfect! I've completed the final notebook in the requested sequence. The metaprogramming learning notebook covers all the advanced Python patterns for creating flexible, self-adapting AI systems:\n\n**Notebooks Created (in requested order 3, 2, 5, 4):**\n1. ✅ `03_functional_programming_learning.ipynb` \n2. ✅ `02_async_patterns_learning.ipynb`\n3. ✅ `05_performance_optimization_learning.ipynb`\n4. ✅ `04_metaprogramming_learning.ipynb` (just completed)\n\n**The Metaprogramming notebook contains 8 progressive cells:**\n\n1. **Descriptors** - Custom attribute access with validation and caching\n2. **Metaclasses** - Automatic model registration and instrumentation\n3. **Dynamic Classes** - Runtime class generation and model factories\n4. **Advanced Decorators** - Stateful decorators with TTL caching and retry logic\n5. **Property Factories** - Type-safe dynamic properties with validation\n6. **Context Managers** - Dynamic configuration management\n7. **Reflection** - Runtime introspection and code analysis\n8. **Complete Framework** - Production-ready metaprogramming AI system\n\nEach cell demonstrates first principles, Python idioms, and practical AI applications with rich console output for interactive learning."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":13018,"cache_read_input_tokens":46191,"output_tokens":1}},"requestId":"req_vrtx_011CRhTJSenoddskuqzwWqiR","type":"assistant","uuid":"403dcfda-b369-470a-931d-fe05d414c626","timestamp":"2025-08-01T18:21:46.173Z"}
